'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

async function copyServiceFiles() {
    const fixerPath = nova.path.join(nova.extension.path, 'php');
    const dependencyDir = nova.path.join(nova.extension.globalStoragePath, 'php');
    const exists = nova.fs.stat(dependencyDir);

    if (!exists) {
        await nova.fs.copy(fixerPath, dependencyDir);
        await makeFileExecutable(nova.path.join(dependencyDir, 'php-cs-fixer'));
    }

    return dependencyDir;
}

async function makeFileExecutable(file) {
    return new Promise((resolve, reject) => {
        const process = new Process('/usr/bin/env', {
            args: ['chmod', 'u+x', file],
        });
        process.onDidExit((status) => {
            if (status === 0) {
                resolve();
            } else {
                reject(status);
            }
        });
        process.start();
    });
}

async function extensionInstaller(disposable, logFn = null) {
    try {
        await copyServiceFiles();
    } catch (err) {
        throw err;
    }
}

var installer = extensionInstaller;

class SingleProcess {
    constructor(port, processConfig) {
        this.events = [];
        this.processConfig = processConfig;
        this.port = port;
    }

    async start() {
        const stdOut = [];
        const stdErr = [];
        const processInstance = new Process('/usr/bin/env', this.processConfig);

        processInstance.onStdout((result) => {
            stdOut.push(result);
        });
        processInstance.onStderr((line) => {
            stdErr.push(line);
        });
        processInstance.onDidExit((status) => {
            this.didExit(status, stdOut, stdErr.join(' '));
        });

        processInstance.start();
        this.singleProcess = processInstance;

        return processInstance;
    }

    didExit(exitCode, stdOut, stdErr) {
        if (!this.singleProcess) {
            return;
        }

        this.trigger('exit', {
            exitCode,
            stdOut,
            stdErr,
            port: this.port,
        });
    }
    getProcess() {
        return this.singleProcess;
    }
    stop() {
        this.trigger('exit', { status: 0, stdOut: 'stop', stdErr: '', port: this.port });
        this.singleProcess.terminate();
    }
    reload() {
        this.trigger('reload');
        this.singleProcess.terminate();
        this.start();
    }
    on(evt, callback, once = false) {
        this.events.push({ evt, once, callback });
    }
    once(evt, callback) {
        this.on(evt, callback, true);
    }
    trigger(eventName, data = null) {
        const onceTriggered = [];

        this.events.forEach((event, i) => {
            const { evt, once, callback } = event;

            if (evt == eventName) {
                callback(data);
                if (once) {
                    onceTriggered.push(i);
                }
            }
        });
        if (onceTriggered.length) {
            onceTriggered.forEach((i) => this.events.splice(i, 1));
        }
    }
}

var process_1 = SingleProcess;

const options = {
    phppath: '',
    csfixerpath: '',
    onsave: '',
    ignoreremote: '',
    port: '',
    server: '',
    log: '',
    rules: '',
    phpcsconfig: '',
    htmltry: '',
    htmladditional: '',
    htmlUseTabs: false,
    htmlTabWidth: 4,
    htmlrules: '',
    twig: '',
    twigUseTabs: false,
    twigTabWidth: 4,
    twigrules: '',
    blade: '',
    bladeUseTabs: false,
    bladeTabWidth: 4,
    bladerules: ''
};

let cachedOptions = false;
let observing = false;

function getGlobalConfig() {
    let extOptions = {};
    for (const key in options) {
        if (options.hasOwnProperty(key)) {
            const optionID = nova.extension.identifier + '.' + key;
            const opt = nova.config.get(optionID);
            extOptions[key] = opt;
        }
    }

    return extOptions;
}

function getWordspaceConfig() {
    let worksapceOptions = {};

    if (nova.workspace.config.get(nova.extension.identifier + '.workspaceconfigenable') == 'disable') {
        return worksapceOptions;
    }

    for (const key in options) {
        const optionID = nova.extension.identifier + '.' + key;
        const opt = nova.workspace.config.get(optionID);

        if (typeof opt !== 'object') {
            worksapceOptions[key] = opt;
        }
    }

    return worksapceOptions;
}

function observeOptionChange(options) {
    if (observing) {
        return false;
    }

    for (const key in options) {
        const optionID = nova.extension.identifier + '.' + key;
        nova.config.onDidChange(optionID, (val) => {
            reloadExtensionConfig(options);
        });

        nova.workspace.config.onDidChange(optionID, (val) => {
            reloadExtensionConfig(options);
        });
    }

    nova.workspace.config.onDidChange(nova.extension.identifier + '.workspaceconfigenable', (val) => {
        reloadExtensionConfig(options);
    });

    observing = true;
}

function reloadExtensionConfig(options) {
    let config = getGlobalConfig();
    let workspaceOptions = getWordspaceConfig();

    let newOptions = Object.assign({}, config, workspaceOptions);

    for (const key in newOptions) {
        options[key] = newOptions[key];
    }
}

function extensionConfig() {
    if (cachedOptions) {
        return cachedOptions;
    }

    let config = getGlobalConfig();
    let workspaceOptions = getWordspaceConfig();

    config = Object.assign({}, config, workspaceOptions);
    cachedOptions = config;

    observeOptionChange(config);

    return config;
}

var config = extensionConfig;

function log(message, force) {
    const config$1 = config();
    if (nova.inDevMode() || config$1.log || force) {
        console.log(message);
    }
}

function showNotification(id, title, body) {
    let request = new NotificationRequest(id);

    request.title = nova.localize(title);
    request.body = nova.localize(body);
    request.actions = [nova.localize('OK')];

    nova.notifications.add(request).catch((err) => console.error(err, err.stack));
}

function showActionableNotification(id, title, body, actions, callback) {
    let request = new NotificationRequest(id);

    request.title = nova.localize(title);
    request.body = nova.localize(body);
    request.actions = actions.map((action) => nova.localize(action));

    nova.notifications
        .add(request)
        .then((response) => callback(response.actionIdx))
        .catch((err) => console.error(err, err.stack));
}

function cleanDirectory(folderPath, extension = '') {
    try {
        const filesInDir = nova.fs.listdir(folderPath);

        filesInDir.forEach((file) => {
            const filePath = nova.path.join(folderPath, file);
            nova.fs.remove(filePath);
        });
    } catch (error) {
        console.error(error);
    }
}

var helpers = {
    log,
    showNotification,
    showActionableNotification,
    cleanDirectory,
};

const compositeDisposable = new CompositeDisposable();
const { log: log$1 } = helpers;

class Server {
    constructor(name) {
        this.extensionConfig = config();
        this.serverrunning = false;
        this.processes = new Map();
        this.processesArr = [];

        // Listen for changes ine extension config to adjust the server
        nova.config.onDidChange(nova.extension.identifier + '.server', (val) => {
            if (val) {
                this.start();
            } else {
                this.stop();
            }
        });
        nova.config.observe(nova.extension.identifier + '.port', (val, prevVal) => {
            if (!prevVal) {
                // Extension is initializing, ignore event
                return;
            }
            const previousServer = this.processes.get(parseInt(prevVal));
            if (previousServer) {
                try {
                    previousServer.terminate();
                } catch (error) {}
            }
            log$1(`PHP Server changed port to ${val}, restart server...`);
            this.start();
        });
    }

    async start() {
        if (!this.extensionConfig.server) {
            return false;
        }

        const serverPath = nova.path.join(nova.extension.globalStoragePath, 'php');
        const script = nova.path.join(nova.extension.globalStoragePath, 'php', 'index.php');

        let phpPath = this.extensionConfig.phppath;

        if (!phpPath) {
            phpPath = 'php';
        }

        this.mainProcess = new process_1(this.extensionConfig.port, {
            args: [phpPath, '-S', 'localhost:' + this.extensionConfig.port, script],
            cwd: serverPath,
            shell: true,
        });

        this.mainProcess.on('start', () => {
            log$1('PHP CS Fixer Server Start');
        });
        this.mainProcess.on('exit', ({ status, stdOut, stdErr, port }) => {
            if (this.processes.get(port)) {
                this.processes.delete(port);
            }
            if (stdOut == 'stop') {
                return this.onServerStop();
            }
            let error = stdErr.trim();
            if (error) {
                this.onExit(error);
            }
        });

        this.mainProcess.start();
        this.processes.set(this.extensionConfig.port, this.mainProcess.getProcess());
    }
    stop() {
        if (!this.mainProcess) {
            return;
        }
        this.mainProcess.stop();
    }
    reload() {
        if (!this.mainProcess) {
            return;
        }
        log$1('PHP CS Fixer Reloading Server');
        this.mainProcess.reload();
    }
    onServerStop() {
        log$1('PHP CS Fixer Server stopped correctly');
    }
    async onExit(error) {
        // Calling the process returned an error
        // it could be that another workspace already
        // started the server so we need to make sure our server
        // is running otherwise show an error notice
        const serverURL = `http://localhost:${this.extensionConfig.port}/index.php`;
        const rawResponse = await fetch(serverURL, {
            method: 'post',
            headers: { Accept: 'application/json', 'Content-Type': 'application/json' },
        });

        if (rawResponse.ok) {
            let response = false;

            try {
                response = await rawResponse.json();
            } catch (error) {
                log$1(error, true);
            }

            // Our server is already runnig, ignore error
            if (typeof response == 'object' && response.id == 'phpcsfixer') {
                console.log('already runnign server');
                return true;
            }
        }

        log$1('PHP CS Fixer Server did not started, see the error below:', true);
        log$1(error, true);

        nova.notifications.cancel('phpfixer-success');
        let request = new NotificationRequest('phpfixer-error');

        request.title = nova.localize('PHP Server Error');
        request.body = error;
        request.actions = [nova.localize('Dismiss')];

        let promise = nova.notifications.add(request);
        nova._notificationPostCSSTimer = setTimeout(() => {
            nova.notifications.cancel('phpfixer-error');
        }, 15000);
    }
}

var server = Server;

function createCommonjsModule(fn, basedir, module) {
	return module = {
	  path: basedir,
	  exports: {},
	  require: function (path, base) {
      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    }
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

/*jshint node:true */

function OutputLine(parent) {
  this.__parent = parent;
  this.__character_count = 0;
  // use indent_count as a marker for this.__lines that have preserved indentation
  this.__indent_count = -1;
  this.__alignment_count = 0;
  this.__wrap_point_index = 0;
  this.__wrap_point_character_count = 0;
  this.__wrap_point_indent_count = -1;
  this.__wrap_point_alignment_count = 0;

  this.__items = [];
}

OutputLine.prototype.clone_empty = function() {
  var line = new OutputLine(this.__parent);
  line.set_indent(this.__indent_count, this.__alignment_count);
  return line;
};

OutputLine.prototype.item = function(index) {
  if (index < 0) {
    return this.__items[this.__items.length + index];
  } else {
    return this.__items[index];
  }
};

OutputLine.prototype.has_match = function(pattern) {
  for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {
    if (this.__items[lastCheckedOutput].match(pattern)) {
      return true;
    }
  }
  return false;
};

OutputLine.prototype.set_indent = function(indent, alignment) {
  if (this.is_empty()) {
    this.__indent_count = indent || 0;
    this.__alignment_count = alignment || 0;
    this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
  }
};

OutputLine.prototype._set_wrap_point = function() {
  if (this.__parent.wrap_line_length) {
    this.__wrap_point_index = this.__items.length;
    this.__wrap_point_character_count = this.__character_count;
    this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
    this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
  }
};

OutputLine.prototype._should_wrap = function() {
  return this.__wrap_point_index &&
    this.__character_count > this.__parent.wrap_line_length &&
    this.__wrap_point_character_count > this.__parent.next_line.__character_count;
};

OutputLine.prototype._allow_wrap = function() {
  if (this._should_wrap()) {
    this.__parent.add_new_line();
    var next = this.__parent.current_line;
    next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
    next.__items = this.__items.slice(this.__wrap_point_index);
    this.__items = this.__items.slice(0, this.__wrap_point_index);

    next.__character_count += this.__character_count - this.__wrap_point_character_count;
    this.__character_count = this.__wrap_point_character_count;

    if (next.__items[0] === " ") {
      next.__items.splice(0, 1);
      next.__character_count -= 1;
    }
    return true;
  }
  return false;
};

OutputLine.prototype.is_empty = function() {
  return this.__items.length === 0;
};

OutputLine.prototype.last = function() {
  if (!this.is_empty()) {
    return this.__items[this.__items.length - 1];
  } else {
    return null;
  }
};

OutputLine.prototype.push = function(item) {
  this.__items.push(item);
  var last_newline_index = item.lastIndexOf('\n');
  if (last_newline_index !== -1) {
    this.__character_count = item.length - last_newline_index;
  } else {
    this.__character_count += item.length;
  }
};

OutputLine.prototype.pop = function() {
  var item = null;
  if (!this.is_empty()) {
    item = this.__items.pop();
    this.__character_count -= item.length;
  }
  return item;
};


OutputLine.prototype._remove_indent = function() {
  if (this.__indent_count > 0) {
    this.__indent_count -= 1;
    this.__character_count -= this.__parent.indent_size;
  }
};

OutputLine.prototype._remove_wrap_indent = function() {
  if (this.__wrap_point_indent_count > 0) {
    this.__wrap_point_indent_count -= 1;
  }
};
OutputLine.prototype.trim = function() {
  while (this.last() === ' ') {
    this.__items.pop();
    this.__character_count -= 1;
  }
};

OutputLine.prototype.toString = function() {
  var result = '';
  if (this.is_empty()) {
    if (this.__parent.indent_empty_lines) {
      result = this.__parent.get_indent_string(this.__indent_count);
    }
  } else {
    result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
    result += this.__items.join('');
  }
  return result;
};

function IndentStringCache(options, baseIndentString) {
  this.__cache = [''];
  this.__indent_size = options.indent_size;
  this.__indent_string = options.indent_char;
  if (!options.indent_with_tabs) {
    this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);
  }

  // Set to null to continue support for auto detection of base indent
  baseIndentString = baseIndentString || '';
  if (options.indent_level > 0) {
    baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);
  }

  this.__base_string = baseIndentString;
  this.__base_string_length = baseIndentString.length;
}

IndentStringCache.prototype.get_indent_size = function(indent, column) {
  var result = this.__base_string_length;
  column = column || 0;
  if (indent < 0) {
    result = 0;
  }
  result += indent * this.__indent_size;
  result += column;
  return result;
};

IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
  var result = this.__base_string;
  column = column || 0;
  if (indent_level < 0) {
    indent_level = 0;
    result = '';
  }
  column += indent_level * this.__indent_size;
  this.__ensure_cache(column);
  result += this.__cache[column];
  return result;
};

IndentStringCache.prototype.__ensure_cache = function(column) {
  while (column >= this.__cache.length) {
    this.__add_column();
  }
};

IndentStringCache.prototype.__add_column = function() {
  var column = this.__cache.length;
  var indent = 0;
  var result = '';
  if (this.__indent_size && column >= this.__indent_size) {
    indent = Math.floor(column / this.__indent_size);
    column -= indent * this.__indent_size;
    result = new Array(indent + 1).join(this.__indent_string);
  }
  if (column) {
    result += new Array(column + 1).join(' ');
  }

  this.__cache.push(result);
};

function Output(options, baseIndentString) {
  this.__indent_cache = new IndentStringCache(options, baseIndentString);
  this.raw = false;
  this._end_with_newline = options.end_with_newline;
  this.indent_size = options.indent_size;
  this.wrap_line_length = options.wrap_line_length;
  this.indent_empty_lines = options.indent_empty_lines;
  this.__lines = [];
  this.previous_line = null;
  this.current_line = null;
  this.next_line = new OutputLine(this);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = false;
  // initialize
  this.__add_outputline();
}

Output.prototype.__add_outputline = function() {
  this.previous_line = this.current_line;
  this.current_line = this.next_line.clone_empty();
  this.__lines.push(this.current_line);
};

Output.prototype.get_line_number = function() {
  return this.__lines.length;
};

Output.prototype.get_indent_string = function(indent, column) {
  return this.__indent_cache.get_indent_string(indent, column);
};

Output.prototype.get_indent_size = function(indent, column) {
  return this.__indent_cache.get_indent_size(indent, column);
};

Output.prototype.is_empty = function() {
  return !this.previous_line && this.current_line.is_empty();
};

Output.prototype.add_new_line = function(force_newline) {
  // never newline at the start of file
  // otherwise, newline only if we didn't just add one or we're forced
  if (this.is_empty() ||
    (!force_newline && this.just_added_newline())) {
    return false;
  }

  // if raw output is enabled, don't print additional newlines,
  // but still return True as though you had
  if (!this.raw) {
    this.__add_outputline();
  }
  return true;
};

Output.prototype.get_code = function(eol) {
  this.trim(true);

  // handle some edge cases where the last tokens
  // has text that ends with newline(s)
  var last_item = this.current_line.pop();
  if (last_item) {
    if (last_item[last_item.length - 1] === '\n') {
      last_item = last_item.replace(/\n+$/g, '');
    }
    this.current_line.push(last_item);
  }

  if (this._end_with_newline) {
    this.__add_outputline();
  }

  var sweet_code = this.__lines.join('\n');

  if (eol !== '\n') {
    sweet_code = sweet_code.replace(/[\n]/g, eol);
  }
  return sweet_code;
};

Output.prototype.set_wrap_point = function() {
  this.current_line._set_wrap_point();
};

Output.prototype.set_indent = function(indent, alignment) {
  indent = indent || 0;
  alignment = alignment || 0;

  // Next line stores alignment values
  this.next_line.set_indent(indent, alignment);

  // Never indent your first output indent at the start of the file
  if (this.__lines.length > 1) {
    this.current_line.set_indent(indent, alignment);
    return true;
  }

  this.current_line.set_indent();
  return false;
};

Output.prototype.add_raw_token = function(token) {
  for (var x = 0; x < token.newlines; x++) {
    this.__add_outputline();
  }
  this.current_line.set_indent(-1);
  this.current_line.push(token.whitespace_before);
  this.current_line.push(token.text);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = false;
};

Output.prototype.add_token = function(printable_token) {
  this.__add_space_before_token();
  this.current_line.push(printable_token);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = this.current_line._allow_wrap();
};

Output.prototype.__add_space_before_token = function() {
  if (this.space_before_token && !this.just_added_newline()) {
    if (!this.non_breaking_space) {
      this.set_wrap_point();
    }
    this.current_line.push(' ');
  }
};

Output.prototype.remove_indent = function(index) {
  var output_length = this.__lines.length;
  while (index < output_length) {
    this.__lines[index]._remove_indent();
    index++;
  }
  this.current_line._remove_wrap_indent();
};

Output.prototype.trim = function(eat_newlines) {
  eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

  this.current_line.trim();

  while (eat_newlines && this.__lines.length > 1 &&
    this.current_line.is_empty()) {
    this.__lines.pop();
    this.current_line = this.__lines[this.__lines.length - 1];
    this.current_line.trim();
  }

  this.previous_line = this.__lines.length > 1 ?
    this.__lines[this.__lines.length - 2] : null;
};

Output.prototype.just_added_newline = function() {
  return this.current_line.is_empty();
};

Output.prototype.just_added_blankline = function() {
  return this.is_empty() ||
    (this.current_line.is_empty() && this.previous_line.is_empty());
};

Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
  var index = this.__lines.length - 2;
  while (index >= 0) {
    var potentialEmptyLine = this.__lines[index];
    if (potentialEmptyLine.is_empty()) {
      break;
    } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 &&
      potentialEmptyLine.item(-1) !== ends_with) {
      this.__lines.splice(index + 1, 0, new OutputLine(this));
      this.previous_line = this.__lines[this.__lines.length - 2];
      break;
    }
    index--;
  }
};

var Output_1 = Output;

var output = {
	Output: Output_1
};

/*jshint node:true */

function Token(type, text, newlines, whitespace_before) {
  this.type = type;
  this.text = text;

  // comments_before are
  // comments that have a new line before them
  // and may or may not have a newline after
  // this is a set of comments before
  this.comments_before = null; /* inline comment*/


  // this.comments_after =  new TokenStream(); // no new line before and newline after
  this.newlines = newlines || 0;
  this.whitespace_before = whitespace_before || '';
  this.parent = null;
  this.next = null;
  this.previous = null;
  this.opened = null;
  this.closed = null;
  this.directives = null;
}


var Token_1 = Token;

var token = {
	Token: Token_1
};

var acorn = createCommonjsModule(function (module, exports) {

// acorn used char codes to squeeze the last bit of performance out
// Beautifier is okay without that, so we're using regex
// permit # (23), $ (36), and @ (64). @ is used in ES7 decorators.
// 65 through 91 are uppercase letters.
// permit _ (95).
// 97 through 123 are lowercase letters.
var baseASCIIidentifierStartChars = "\\x23\\x24\\x40\\x41-\\x5a\\x5f\\x61-\\x7a";

// inside an identifier @ is not allowed but 0-9 are.
var baseASCIIidentifierChars = "\\x24\\x30-\\x39\\x41-\\x5a\\x5f\\x61-\\x7a";

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
var nonASCIIidentifierStartChars = "\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc";
var nonASCIIidentifierChars = "\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f";
//var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
//var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

var identifierStart = "(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars + "])";
var identifierChars = "(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])*";

exports.identifier = new RegExp(identifierStart + identifierChars, 'g');
exports.identifierStart = new RegExp(identifierStart);
exports.identifierMatch = new RegExp("(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])+");

// Whether a single character denotes a newline.

exports.newline = /[\n\r\u2028\u2029]/;

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

// in javascript, these two differ
// in python they are the same, different methods are called on them
exports.lineBreak = new RegExp('\r\n|' + exports.newline.source);
exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');
});

/*jshint node:true */

function Options(options, merge_child_field) {
  this.raw_options = _mergeOpts(options, merge_child_field);

  // Support passing the source text back with no change
  this.disabled = this._get_boolean('disabled');

  this.eol = this._get_characters('eol', 'auto');
  this.end_with_newline = this._get_boolean('end_with_newline');
  this.indent_size = this._get_number('indent_size', 4);
  this.indent_char = this._get_characters('indent_char', ' ');
  this.indent_level = this._get_number('indent_level');

  this.preserve_newlines = this._get_boolean('preserve_newlines', true);
  this.max_preserve_newlines = this._get_number('max_preserve_newlines', 32786);
  if (!this.preserve_newlines) {
    this.max_preserve_newlines = 0;
  }

  this.indent_with_tabs = this._get_boolean('indent_with_tabs', this.indent_char === '\t');
  if (this.indent_with_tabs) {
    this.indent_char = '\t';

    // indent_size behavior changed after 1.8.6
    // It used to be that indent_size would be
    // set to 1 for indent_with_tabs. That is no longer needed and
    // actually doesn't make sense - why not use spaces? Further,
    // that might produce unexpected behavior - tabs being used
    // for single-column alignment. So, when indent_with_tabs is true
    // and indent_size is 1, reset indent_size to 4.
    if (this.indent_size === 1) {
      this.indent_size = 4;
    }
  }

  // Backwards compat with 1.3.x
  this.wrap_line_length = this._get_number('wrap_line_length', this._get_number('max_char'));

  this.indent_empty_lines = this._get_boolean('indent_empty_lines');

  // valid templating languages ['django', 'erb', 'handlebars', 'php']
  // For now, 'auto' = all off for javascript, all on for html (and inline javascript).
  // other values ignored
  this.templating = this._get_selection_list('templating', ['auto', 'none', 'django', 'erb', 'handlebars', 'php'], ['auto']);
}

Options.prototype._get_array = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = default_value || [];
  if (typeof option_value === 'object') {
    if (option_value !== null && typeof option_value.concat === 'function') {
      result = option_value.concat();
    }
  } else if (typeof option_value === 'string') {
    result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
  }
  return result;
};

Options.prototype._get_boolean = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = option_value === undefined ? !!default_value : !!option_value;
  return result;
};

Options.prototype._get_characters = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = default_value || '';
  if (typeof option_value === 'string') {
    result = option_value.replace(/\\r/, '\r').replace(/\\n/, '\n').replace(/\\t/, '\t');
  }
  return result;
};

Options.prototype._get_number = function(name, default_value) {
  var option_value = this.raw_options[name];
  default_value = parseInt(default_value, 10);
  if (isNaN(default_value)) {
    default_value = 0;
  }
  var result = parseInt(option_value, 10);
  if (isNaN(result)) {
    result = default_value;
  }
  return result;
};

Options.prototype._get_selection = function(name, selection_list, default_value) {
  var result = this._get_selection_list(name, selection_list, default_value);
  if (result.length !== 1) {
    throw new Error(
      "Invalid Option Value: The option '" + name + "' can only be one of the following values:\n" +
      selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
  }

  return result[0];
};


Options.prototype._get_selection_list = function(name, selection_list, default_value) {
  if (!selection_list || selection_list.length === 0) {
    throw new Error("Selection list cannot be empty.");
  }

  default_value = default_value || [selection_list[0]];
  if (!this._is_valid_selection(default_value, selection_list)) {
    throw new Error("Invalid Default Value!");
  }

  var result = this._get_array(name, default_value);
  if (!this._is_valid_selection(result, selection_list)) {
    throw new Error(
      "Invalid Option Value: The option '" + name + "' can contain only the following values:\n" +
      selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
  }

  return result;
};

Options.prototype._is_valid_selection = function(result, selection_list) {
  return result.length && selection_list.length &&
    !result.some(function(item) { return selection_list.indexOf(item) === -1; });
};


// merges child options up with the parent options object
// Example: obj = {a: 1, b: {a: 2}}
//          mergeOpts(obj, 'b')
//
//          Returns: {a: 2}
function _mergeOpts(allOptions, childFieldName) {
  var finalOpts = {};
  allOptions = _normalizeOpts(allOptions);
  var name;

  for (name in allOptions) {
    if (name !== childFieldName) {
      finalOpts[name] = allOptions[name];
    }
  }

  //merge in the per type settings for the childFieldName
  if (childFieldName && allOptions[childFieldName]) {
    for (name in allOptions[childFieldName]) {
      finalOpts[name] = allOptions[childFieldName][name];
    }
  }
  return finalOpts;
}

function _normalizeOpts(options) {
  var convertedOpts = {};
  var key;

  for (key in options) {
    var newKey = key.replace(/-/g, "_");
    convertedOpts[newKey] = options[key];
  }
  return convertedOpts;
}

var Options_1 = Options;
var normalizeOpts = _normalizeOpts;
var mergeOpts = _mergeOpts;

var options$1 = {
	Options: Options_1,
	normalizeOpts: normalizeOpts,
	mergeOpts: mergeOpts
};

var BaseOptions = options$1.Options;

var validPositionValues = ['before-newline', 'after-newline', 'preserve-newline'];

function Options$1(options) {
  BaseOptions.call(this, options, 'js');

  // compatibility, re
  var raw_brace_style = this.raw_options.brace_style || null;
  if (raw_brace_style === "expand-strict") { //graceful handling of deprecated option
    this.raw_options.brace_style = "expand";
  } else if (raw_brace_style === "collapse-preserve-inline") { //graceful handling of deprecated option
    this.raw_options.brace_style = "collapse,preserve-inline";
  } else if (this.raw_options.braces_on_own_line !== undefined) { //graceful handling of deprecated option
    this.raw_options.brace_style = this.raw_options.braces_on_own_line ? "expand" : "collapse";
    // } else if (!raw_brace_style) { //Nothing exists to set it
    //   raw_brace_style = "collapse";
  }

  //preserve-inline in delimited string will trigger brace_preserve_inline, everything
  //else is considered a brace_style and the last one only will have an effect

  var brace_style_split = this._get_selection_list('brace_style', ['collapse', 'expand', 'end-expand', 'none', 'preserve-inline']);

  this.brace_preserve_inline = false; //Defaults in case one or other was not specified in meta-option
  this.brace_style = "collapse";

  for (var bs = 0; bs < brace_style_split.length; bs++) {
    if (brace_style_split[bs] === "preserve-inline") {
      this.brace_preserve_inline = true;
    } else {
      this.brace_style = brace_style_split[bs];
    }
  }

  this.unindent_chained_methods = this._get_boolean('unindent_chained_methods');
  this.break_chained_methods = this._get_boolean('break_chained_methods');
  this.space_in_paren = this._get_boolean('space_in_paren');
  this.space_in_empty_paren = this._get_boolean('space_in_empty_paren');
  this.jslint_happy = this._get_boolean('jslint_happy');
  this.space_after_anon_function = this._get_boolean('space_after_anon_function');
  this.space_after_named_function = this._get_boolean('space_after_named_function');
  this.keep_array_indentation = this._get_boolean('keep_array_indentation');
  this.space_before_conditional = this._get_boolean('space_before_conditional', true);
  this.unescape_strings = this._get_boolean('unescape_strings');
  this.e4x = this._get_boolean('e4x');
  this.comma_first = this._get_boolean('comma_first');
  this.operator_position = this._get_selection('operator_position', validPositionValues);

  // For testing of beautify preserve:start directive
  this.test_output_raw = this._get_boolean('test_output_raw');

  // force this._options.space_after_anon_function to true if this._options.jslint_happy
  if (this.jslint_happy) {
    this.space_after_anon_function = true;
  }

}
Options$1.prototype = new BaseOptions();



var Options_1$1 = Options$1;

var options$2 = {
	Options: Options_1$1
};

/*jshint node:true */

var regexp_has_sticky = RegExp.prototype.hasOwnProperty('sticky');

function InputScanner(input_string) {
  this.__input = input_string || '';
  this.__input_length = this.__input.length;
  this.__position = 0;
}

InputScanner.prototype.restart = function() {
  this.__position = 0;
};

InputScanner.prototype.back = function() {
  if (this.__position > 0) {
    this.__position -= 1;
  }
};

InputScanner.prototype.hasNext = function() {
  return this.__position < this.__input_length;
};

InputScanner.prototype.next = function() {
  var val = null;
  if (this.hasNext()) {
    val = this.__input.charAt(this.__position);
    this.__position += 1;
  }
  return val;
};

InputScanner.prototype.peek = function(index) {
  var val = null;
  index = index || 0;
  index += this.__position;
  if (index >= 0 && index < this.__input_length) {
    val = this.__input.charAt(index);
  }
  return val;
};

// This is a JavaScript only helper function (not in python)
// Javascript doesn't have a match method
// and not all implementation support "sticky" flag.
// If they do not support sticky then both this.match() and this.test() method
// must get the match and check the index of the match.
// If sticky is supported and set, this method will use it.
// Otherwise it will check that global is set, and fall back to the slower method.
InputScanner.prototype.__match = function(pattern, index) {
  pattern.lastIndex = index;
  var pattern_match = pattern.exec(this.__input);

  if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {
    if (pattern_match.index !== index) {
      pattern_match = null;
    }
  }

  return pattern_match;
};

InputScanner.prototype.test = function(pattern, index) {
  index = index || 0;
  index += this.__position;

  if (index >= 0 && index < this.__input_length) {
    return !!this.__match(pattern, index);
  } else {
    return false;
  }
};

InputScanner.prototype.testChar = function(pattern, index) {
  // test one character regex match
  var val = this.peek(index);
  pattern.lastIndex = 0;
  return val !== null && pattern.test(val);
};

InputScanner.prototype.match = function(pattern) {
  var pattern_match = this.__match(pattern, this.__position);
  if (pattern_match) {
    this.__position += pattern_match[0].length;
  } else {
    pattern_match = null;
  }
  return pattern_match;
};

InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
  var val = '';
  var match;
  if (starting_pattern) {
    match = this.match(starting_pattern);
    if (match) {
      val += match[0];
    }
  }
  if (until_pattern && (match || !starting_pattern)) {
    val += this.readUntil(until_pattern, until_after);
  }
  return val;
};

InputScanner.prototype.readUntil = function(pattern, until_after) {
  var val = '';
  var match_index = this.__position;
  pattern.lastIndex = this.__position;
  var pattern_match = pattern.exec(this.__input);
  if (pattern_match) {
    match_index = pattern_match.index;
    if (until_after) {
      match_index += pattern_match[0].length;
    }
  } else {
    match_index = this.__input_length;
  }

  val = this.__input.substring(this.__position, match_index);
  this.__position = match_index;
  return val;
};

InputScanner.prototype.readUntilAfter = function(pattern) {
  return this.readUntil(pattern, true);
};

InputScanner.prototype.get_regexp = function(pattern, match_from) {
  var result = null;
  var flags = 'g';
  if (match_from && regexp_has_sticky) {
    flags = 'y';
  }
  // strings are converted to regexp
  if (typeof pattern === "string" && pattern !== '') {
    // result = new RegExp(pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), flags);
    result = new RegExp(pattern, flags);
  } else if (pattern) {
    result = new RegExp(pattern.source, flags);
  }
  return result;
};

InputScanner.prototype.get_literal_regexp = function(literal_string) {
  return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
};

/* css beautifier legacy helpers */
InputScanner.prototype.peekUntilAfter = function(pattern) {
  var start = this.__position;
  var val = this.readUntilAfter(pattern);
  this.__position = start;
  return val;
};

InputScanner.prototype.lookBack = function(testVal) {
  var start = this.__position - 1;
  return start >= testVal.length && this.__input.substring(start - testVal.length, start)
    .toLowerCase() === testVal;
};

var InputScanner_1 = InputScanner;

var inputscanner = {
	InputScanner: InputScanner_1
};

/*jshint node:true */

function TokenStream(parent_token) {
  // private
  this.__tokens = [];
  this.__tokens_length = this.__tokens.length;
  this.__position = 0;
  this.__parent_token = parent_token;
}

TokenStream.prototype.restart = function() {
  this.__position = 0;
};

TokenStream.prototype.isEmpty = function() {
  return this.__tokens_length === 0;
};

TokenStream.prototype.hasNext = function() {
  return this.__position < this.__tokens_length;
};

TokenStream.prototype.next = function() {
  var val = null;
  if (this.hasNext()) {
    val = this.__tokens[this.__position];
    this.__position += 1;
  }
  return val;
};

TokenStream.prototype.peek = function(index) {
  var val = null;
  index = index || 0;
  index += this.__position;
  if (index >= 0 && index < this.__tokens_length) {
    val = this.__tokens[index];
  }
  return val;
};

TokenStream.prototype.add = function(token) {
  if (this.__parent_token) {
    token.parent = this.__parent_token;
  }
  this.__tokens.push(token);
  this.__tokens_length += 1;
};

var TokenStream_1 = TokenStream;

var tokenstream = {
	TokenStream: TokenStream_1
};

/*jshint node:true */

function Pattern(input_scanner, parent) {
  this._input = input_scanner;
  this._starting_pattern = null;
  this._match_pattern = null;
  this._until_pattern = null;
  this._until_after = false;

  if (parent) {
    this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);
    this._match_pattern = this._input.get_regexp(parent._match_pattern, true);
    this._until_pattern = this._input.get_regexp(parent._until_pattern);
    this._until_after = parent._until_after;
  }
}

Pattern.prototype.read = function() {
  var result = this._input.read(this._starting_pattern);
  if (!this._starting_pattern || result) {
    result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);
  }
  return result;
};

Pattern.prototype.read_match = function() {
  return this._input.match(this._match_pattern);
};

Pattern.prototype.until_after = function(pattern) {
  var result = this._create();
  result._until_after = true;
  result._until_pattern = this._input.get_regexp(pattern);
  result._update();
  return result;
};

Pattern.prototype.until = function(pattern) {
  var result = this._create();
  result._until_after = false;
  result._until_pattern = this._input.get_regexp(pattern);
  result._update();
  return result;
};

Pattern.prototype.starting_with = function(pattern) {
  var result = this._create();
  result._starting_pattern = this._input.get_regexp(pattern, true);
  result._update();
  return result;
};

Pattern.prototype.matching = function(pattern) {
  var result = this._create();
  result._match_pattern = this._input.get_regexp(pattern, true);
  result._update();
  return result;
};

Pattern.prototype._create = function() {
  return new Pattern(this._input, this);
};

Pattern.prototype._update = function() {};

var Pattern_1 = Pattern;

var pattern = {
	Pattern: Pattern_1
};

var Pattern$1 = pattern.Pattern;

function WhitespacePattern(input_scanner, parent) {
  Pattern$1.call(this, input_scanner, parent);
  if (parent) {
    this._line_regexp = this._input.get_regexp(parent._line_regexp);
  } else {
    this.__set_whitespace_patterns('', '');
  }

  this.newline_count = 0;
  this.whitespace_before_token = '';
}
WhitespacePattern.prototype = new Pattern$1();

WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {
  whitespace_chars += '\\t ';
  newline_chars += '\\n\\r';

  this._match_pattern = this._input.get_regexp(
    '[' + whitespace_chars + newline_chars + ']+', true);
  this._newline_regexp = this._input.get_regexp(
    '\\r\\n|[' + newline_chars + ']');
};

WhitespacePattern.prototype.read = function() {
  this.newline_count = 0;
  this.whitespace_before_token = '';

  var resulting_string = this._input.read(this._match_pattern);
  if (resulting_string === ' ') {
    this.whitespace_before_token = ' ';
  } else if (resulting_string) {
    var matches = this.__split(this._newline_regexp, resulting_string);
    this.newline_count = matches.length - 1;
    this.whitespace_before_token = matches[this.newline_count];
  }

  return resulting_string;
};

WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {
  var result = this._create();
  result.__set_whitespace_patterns(whitespace_chars, newline_chars);
  result._update();
  return result;
};

WhitespacePattern.prototype._create = function() {
  return new WhitespacePattern(this._input, this);
};

WhitespacePattern.prototype.__split = function(regexp, input_string) {
  regexp.lastIndex = 0;
  var start_index = 0;
  var result = [];
  var next_match = regexp.exec(input_string);
  while (next_match) {
    result.push(input_string.substring(start_index, next_match.index));
    start_index = next_match.index + next_match[0].length;
    next_match = regexp.exec(input_string);
  }

  if (start_index < input_string.length) {
    result.push(input_string.substring(start_index, input_string.length));
  } else {
    result.push('');
  }

  return result;
};



var WhitespacePattern_1 = WhitespacePattern;

var whitespacepattern = {
	WhitespacePattern: WhitespacePattern_1
};

var InputScanner$1 = inputscanner.InputScanner;
var Token$1 = token.Token;
var TokenStream$1 = tokenstream.TokenStream;
var WhitespacePattern$1 = whitespacepattern.WhitespacePattern;

var TOKEN = {
  START: 'TK_START',
  RAW: 'TK_RAW',
  EOF: 'TK_EOF'
};

var Tokenizer = function(input_string, options) {
  this._input = new InputScanner$1(input_string);
  this._options = options || {};
  this.__tokens = null;

  this._patterns = {};
  this._patterns.whitespace = new WhitespacePattern$1(this._input);
};

Tokenizer.prototype.tokenize = function() {
  this._input.restart();
  this.__tokens = new TokenStream$1();

  this._reset();

  var current;
  var previous = new Token$1(TOKEN.START, '');
  var open_token = null;
  var open_stack = [];
  var comments = new TokenStream$1();

  while (previous.type !== TOKEN.EOF) {
    current = this._get_next_token(previous, open_token);
    while (this._is_comment(current)) {
      comments.add(current);
      current = this._get_next_token(previous, open_token);
    }

    if (!comments.isEmpty()) {
      current.comments_before = comments;
      comments = new TokenStream$1();
    }

    current.parent = open_token;

    if (this._is_opening(current)) {
      open_stack.push(open_token);
      open_token = current;
    } else if (open_token && this._is_closing(current, open_token)) {
      current.opened = open_token;
      open_token.closed = current;
      open_token = open_stack.pop();
      current.parent = open_token;
    }

    current.previous = previous;
    previous.next = current;

    this.__tokens.add(current);
    previous = current;
  }

  return this.__tokens;
};


Tokenizer.prototype._is_first_token = function() {
  return this.__tokens.isEmpty();
};

Tokenizer.prototype._reset = function() {};

Tokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
  this._readWhitespace();
  var resulting_string = this._input.read(/.+/g);
  if (resulting_string) {
    return this._create_token(TOKEN.RAW, resulting_string);
  } else {
    return this._create_token(TOKEN.EOF, '');
  }
};

Tokenizer.prototype._is_comment = function(current_token) { // jshint unused:false
  return false;
};

Tokenizer.prototype._is_opening = function(current_token) { // jshint unused:false
  return false;
};

Tokenizer.prototype._is_closing = function(current_token, open_token) { // jshint unused:false
  return false;
};

Tokenizer.prototype._create_token = function(type, text) {
  var token = new Token$1(type, text,
    this._patterns.whitespace.newline_count,
    this._patterns.whitespace.whitespace_before_token);
  return token;
};

Tokenizer.prototype._readWhitespace = function() {
  return this._patterns.whitespace.read();
};



var Tokenizer_1 = Tokenizer;
var TOKEN_1 = TOKEN;

var tokenizer = {
	Tokenizer: Tokenizer_1,
	TOKEN: TOKEN_1
};

/*jshint node:true */

function Directives(start_block_pattern, end_block_pattern) {
  start_block_pattern = typeof start_block_pattern === 'string' ? start_block_pattern : start_block_pattern.source;
  end_block_pattern = typeof end_block_pattern === 'string' ? end_block_pattern : end_block_pattern.source;
  this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, 'g');
  this.__directive_pattern = / (\w+)[:](\w+)/g;

  this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, 'g');
}

Directives.prototype.get_directives = function(text) {
  if (!text.match(this.__directives_block_pattern)) {
    return null;
  }

  var directives = {};
  this.__directive_pattern.lastIndex = 0;
  var directive_match = this.__directive_pattern.exec(text);

  while (directive_match) {
    directives[directive_match[1]] = directive_match[2];
    directive_match = this.__directive_pattern.exec(text);
  }

  return directives;
};

Directives.prototype.readIgnored = function(input) {
  return input.readUntilAfter(this.__directives_end_ignore_pattern);
};


var Directives_1 = Directives;

var directives = {
	Directives: Directives_1
};

var Pattern$2 = pattern.Pattern;


var template_names = {
  django: false,
  erb: false,
  handlebars: false,
  php: false
};

// This lets templates appear anywhere we would do a readUntil
// The cost is higher but it is pay to play.
function TemplatablePattern(input_scanner, parent) {
  Pattern$2.call(this, input_scanner, parent);
  this.__template_pattern = null;
  this._disabled = Object.assign({}, template_names);
  this._excluded = Object.assign({}, template_names);

  if (parent) {
    this.__template_pattern = this._input.get_regexp(parent.__template_pattern);
    this._excluded = Object.assign(this._excluded, parent._excluded);
    this._disabled = Object.assign(this._disabled, parent._disabled);
  }
  var pattern = new Pattern$2(input_scanner);
  this.__patterns = {
    handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),
    handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),
    handlebars: pattern.starting_with(/{{/).until_after(/}}/),
    php: pattern.starting_with(/<\?(?:[=]|php)/).until_after(/\?>/),
    erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),
    // django coflicts with handlebars a bit.
    django: pattern.starting_with(/{%/).until_after(/%}/),
    django_value: pattern.starting_with(/{{/).until_after(/}}/),
    django_comment: pattern.starting_with(/{#/).until_after(/#}/)
  };
}
TemplatablePattern.prototype = new Pattern$2();

TemplatablePattern.prototype._create = function() {
  return new TemplatablePattern(this._input, this);
};

TemplatablePattern.prototype._update = function() {
  this.__set_templated_pattern();
};

TemplatablePattern.prototype.disable = function(language) {
  var result = this._create();
  result._disabled[language] = true;
  result._update();
  return result;
};

TemplatablePattern.prototype.read_options = function(options) {
  var result = this._create();
  for (var language in template_names) {
    result._disabled[language] = options.templating.indexOf(language) === -1;
  }
  result._update();
  return result;
};

TemplatablePattern.prototype.exclude = function(language) {
  var result = this._create();
  result._excluded[language] = true;
  result._update();
  return result;
};

TemplatablePattern.prototype.read = function() {
  var result = '';
  if (this._match_pattern) {
    result = this._input.read(this._starting_pattern);
  } else {
    result = this._input.read(this._starting_pattern, this.__template_pattern);
  }
  var next = this._read_template();
  while (next) {
    if (this._match_pattern) {
      next += this._input.read(this._match_pattern);
    } else {
      next += this._input.readUntil(this.__template_pattern);
    }
    result += next;
    next = this._read_template();
  }

  if (this._until_after) {
    result += this._input.readUntilAfter(this._until_pattern);
  }
  return result;
};

TemplatablePattern.prototype.__set_templated_pattern = function() {
  var items = [];

  if (!this._disabled.php) {
    items.push(this.__patterns.php._starting_pattern.source);
  }
  if (!this._disabled.handlebars) {
    items.push(this.__patterns.handlebars._starting_pattern.source);
  }
  if (!this._disabled.erb) {
    items.push(this.__patterns.erb._starting_pattern.source);
  }
  if (!this._disabled.django) {
    items.push(this.__patterns.django._starting_pattern.source);
    items.push(this.__patterns.django_value._starting_pattern.source);
    items.push(this.__patterns.django_comment._starting_pattern.source);
  }

  if (this._until_pattern) {
    items.push(this._until_pattern.source);
  }
  this.__template_pattern = this._input.get_regexp('(?:' + items.join('|') + ')');
};

TemplatablePattern.prototype._read_template = function() {
  var resulting_string = '';
  var c = this._input.peek();
  if (c === '<') {
    var peek1 = this._input.peek(1);
    //if we're in a comment, do something special
    // We treat all comments as literals, even more than preformatted tags
    // we just look for the appropriate close tag
    if (!this._disabled.php && !this._excluded.php && peek1 === '?') {
      resulting_string = resulting_string ||
        this.__patterns.php.read();
    }
    if (!this._disabled.erb && !this._excluded.erb && peek1 === '%') {
      resulting_string = resulting_string ||
        this.__patterns.erb.read();
    }
  } else if (c === '{') {
    if (!this._disabled.handlebars && !this._excluded.handlebars) {
      resulting_string = resulting_string ||
        this.__patterns.handlebars_comment.read();
      resulting_string = resulting_string ||
        this.__patterns.handlebars_unescaped.read();
      resulting_string = resulting_string ||
        this.__patterns.handlebars.read();
    }
    if (!this._disabled.django) {
      // django coflicts with handlebars a bit.
      if (!this._excluded.django && !this._excluded.handlebars) {
        resulting_string = resulting_string ||
          this.__patterns.django_value.read();
      }
      if (!this._excluded.django) {
        resulting_string = resulting_string ||
          this.__patterns.django_comment.read();
        resulting_string = resulting_string ||
          this.__patterns.django.read();
      }
    }
  }
  return resulting_string;
};


var TemplatablePattern_1 = TemplatablePattern;

var templatablepattern = {
	TemplatablePattern: TemplatablePattern_1
};

var InputScanner$2 = inputscanner.InputScanner;
var BaseTokenizer = tokenizer.Tokenizer;
var BASETOKEN = tokenizer.TOKEN;
var Directives$1 = directives.Directives;

var Pattern$3 = pattern.Pattern;
var TemplatablePattern$1 = templatablepattern.TemplatablePattern;


function in_array(what, arr) {
  return arr.indexOf(what) !== -1;
}


var TOKEN$1 = {
  START_EXPR: 'TK_START_EXPR',
  END_EXPR: 'TK_END_EXPR',
  START_BLOCK: 'TK_START_BLOCK',
  END_BLOCK: 'TK_END_BLOCK',
  WORD: 'TK_WORD',
  RESERVED: 'TK_RESERVED',
  SEMICOLON: 'TK_SEMICOLON',
  STRING: 'TK_STRING',
  EQUALS: 'TK_EQUALS',
  OPERATOR: 'TK_OPERATOR',
  COMMA: 'TK_COMMA',
  BLOCK_COMMENT: 'TK_BLOCK_COMMENT',
  COMMENT: 'TK_COMMENT',
  DOT: 'TK_DOT',
  UNKNOWN: 'TK_UNKNOWN',
  START: BASETOKEN.START,
  RAW: BASETOKEN.RAW,
  EOF: BASETOKEN.EOF
};


var directives_core = new Directives$1(/\/\*/, /\*\//);

var number_pattern = /0[xX][0123456789abcdefABCDEF]*|0[oO][01234567]*|0[bB][01]*|\d+n|(?:\.\d+|\d+\.?\d*)(?:[eE][+-]?\d+)?/;

var digit = /[0-9]/;

// Dot "." must be distinguished from "..." and decimal
var dot_pattern = /[^\d\.]/;

var positionable_operators = (
  ">>> === !== " +
  "<< && >= ** != == <= >> || ?? |> " +
  "< / - + > : & % ? ^ | *").split(' ');

// IMPORTANT: this must be sorted longest to shortest or tokenizing many not work.
// Also, you must update possitionable operators separately from punct
var punct =
  ">>>= " +
  "... >>= <<= === >>> !== **= " +
  "=> ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> " +
  "= ! ? > < : / ^ - + * & % ~ |";

punct = punct.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
// ?. but not if followed by a number 
punct = '\\?\\.(?!\\d) ' + punct;
punct = punct.replace(/ /g, '|');

var punct_pattern = new RegExp(punct);

// words which should always start on new line.
var line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export'.split(',');
var reserved_words = line_starters.concat(['do', 'in', 'of', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof', 'yield', 'async', 'await', 'from', 'as']);
var reserved_word_pattern = new RegExp('^(?:' + reserved_words.join('|') + ')$');

// var template_pattern = /(?:(?:<\?php|<\?=)[\s\S]*?\?>)|(?:<%[\s\S]*?%>)/g;

var in_html_comment;

var Tokenizer$1 = function(input_string, options) {
  BaseTokenizer.call(this, input_string, options);

  this._patterns.whitespace = this._patterns.whitespace.matching(
    /\u00A0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff/.source,
    /\u2028\u2029/.source);

  var pattern_reader = new Pattern$3(this._input);
  var templatable = new TemplatablePattern$1(this._input)
    .read_options(this._options);

  this.__patterns = {
    template: templatable,
    identifier: templatable.starting_with(acorn.identifier).matching(acorn.identifierMatch),
    number: pattern_reader.matching(number_pattern),
    punct: pattern_reader.matching(punct_pattern),
    // comment ends just before nearest linefeed or end of file
    comment: pattern_reader.starting_with(/\/\//).until(/[\n\r\u2028\u2029]/),
    //  /* ... */ comment ends with nearest */ or end of file
    block_comment: pattern_reader.starting_with(/\/\*/).until_after(/\*\//),
    html_comment_start: pattern_reader.matching(/<!--/),
    html_comment_end: pattern_reader.matching(/-->/),
    include: pattern_reader.starting_with(/#include/).until_after(acorn.lineBreak),
    shebang: pattern_reader.starting_with(/#!/).until_after(acorn.lineBreak),
    xml: pattern_reader.matching(/[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[\s\S]+?}|!\[CDATA\[[\s\S]*?\]\])(\s+{[\s\S]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{[\s\S]+?}))*\s*(\/?)\s*>/),
    single_quote: templatable.until(/['\\\n\r\u2028\u2029]/),
    double_quote: templatable.until(/["\\\n\r\u2028\u2029]/),
    template_text: templatable.until(/[`\\$]/),
    template_expression: templatable.until(/[`}\\]/)
  };

};
Tokenizer$1.prototype = new BaseTokenizer();

Tokenizer$1.prototype._is_comment = function(current_token) {
  return current_token.type === TOKEN$1.COMMENT || current_token.type === TOKEN$1.BLOCK_COMMENT || current_token.type === TOKEN$1.UNKNOWN;
};

Tokenizer$1.prototype._is_opening = function(current_token) {
  return current_token.type === TOKEN$1.START_BLOCK || current_token.type === TOKEN$1.START_EXPR;
};

Tokenizer$1.prototype._is_closing = function(current_token, open_token) {
  return (current_token.type === TOKEN$1.END_BLOCK || current_token.type === TOKEN$1.END_EXPR) &&
    (open_token && (
      (current_token.text === ']' && open_token.text === '[') ||
      (current_token.text === ')' && open_token.text === '(') ||
      (current_token.text === '}' && open_token.text === '{')));
};

Tokenizer$1.prototype._reset = function() {
  in_html_comment = false;
};

Tokenizer$1.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
  var token = null;
  this._readWhitespace();
  var c = this._input.peek();

  if (c === null) {
    return this._create_token(TOKEN$1.EOF, '');
  }

  token = token || this._read_non_javascript(c);
  token = token || this._read_string(c);
  token = token || this._read_word(previous_token);
  token = token || this._read_singles(c);
  token = token || this._read_comment(c);
  token = token || this._read_regexp(c, previous_token);
  token = token || this._read_xml(c, previous_token);
  token = token || this._read_punctuation();
  token = token || this._create_token(TOKEN$1.UNKNOWN, this._input.next());

  return token;
};

Tokenizer$1.prototype._read_word = function(previous_token) {
  var resulting_string;
  resulting_string = this.__patterns.identifier.read();
  if (resulting_string !== '') {
    resulting_string = resulting_string.replace(acorn.allLineBreaks, '\n');
    if (!(previous_token.type === TOKEN$1.DOT ||
        (previous_token.type === TOKEN$1.RESERVED && (previous_token.text === 'set' || previous_token.text === 'get'))) &&
      reserved_word_pattern.test(resulting_string)) {
      if (resulting_string === 'in' || resulting_string === 'of') { // hack for 'in' and 'of' operators
        return this._create_token(TOKEN$1.OPERATOR, resulting_string);
      }
      return this._create_token(TOKEN$1.RESERVED, resulting_string);
    }
    return this._create_token(TOKEN$1.WORD, resulting_string);
  }

  resulting_string = this.__patterns.number.read();
  if (resulting_string !== '') {
    return this._create_token(TOKEN$1.WORD, resulting_string);
  }
};

Tokenizer$1.prototype._read_singles = function(c) {
  var token = null;
  if (c === '(' || c === '[') {
    token = this._create_token(TOKEN$1.START_EXPR, c);
  } else if (c === ')' || c === ']') {
    token = this._create_token(TOKEN$1.END_EXPR, c);
  } else if (c === '{') {
    token = this._create_token(TOKEN$1.START_BLOCK, c);
  } else if (c === '}') {
    token = this._create_token(TOKEN$1.END_BLOCK, c);
  } else if (c === ';') {
    token = this._create_token(TOKEN$1.SEMICOLON, c);
  } else if (c === '.' && dot_pattern.test(this._input.peek(1))) {
    token = this._create_token(TOKEN$1.DOT, c);
  } else if (c === ',') {
    token = this._create_token(TOKEN$1.COMMA, c);
  }

  if (token) {
    this._input.next();
  }
  return token;
};

Tokenizer$1.prototype._read_punctuation = function() {
  var resulting_string = this.__patterns.punct.read();

  if (resulting_string !== '') {
    if (resulting_string === '=') {
      return this._create_token(TOKEN$1.EQUALS, resulting_string);
    } else if (resulting_string === '?.') {
      return this._create_token(TOKEN$1.DOT, resulting_string);
    } else {
      return this._create_token(TOKEN$1.OPERATOR, resulting_string);
    }
  }
};

Tokenizer$1.prototype._read_non_javascript = function(c) {
  var resulting_string = '';

  if (c === '#') {
    if (this._is_first_token()) {
      resulting_string = this.__patterns.shebang.read();

      if (resulting_string) {
        return this._create_token(TOKEN$1.UNKNOWN, resulting_string.trim() + '\n');
      }
    }

    // handles extendscript #includes
    resulting_string = this.__patterns.include.read();

    if (resulting_string) {
      return this._create_token(TOKEN$1.UNKNOWN, resulting_string.trim() + '\n');
    }

    c = this._input.next();

    // Spidermonkey-specific sharp variables for circular references. Considered obsolete.
    var sharp = '#';
    if (this._input.hasNext() && this._input.testChar(digit)) {
      do {
        c = this._input.next();
        sharp += c;
      } while (this._input.hasNext() && c !== '#' && c !== '=');
      if (c === '#') ; else if (this._input.peek() === '[' && this._input.peek(1) === ']') {
        sharp += '[]';
        this._input.next();
        this._input.next();
      } else if (this._input.peek() === '{' && this._input.peek(1) === '}') {
        sharp += '{}';
        this._input.next();
        this._input.next();
      }
      return this._create_token(TOKEN$1.WORD, sharp);
    }

    this._input.back();

  } else if (c === '<' && this._is_first_token()) {
    resulting_string = this.__patterns.html_comment_start.read();
    if (resulting_string) {
      while (this._input.hasNext() && !this._input.testChar(acorn.newline)) {
        resulting_string += this._input.next();
      }
      in_html_comment = true;
      return this._create_token(TOKEN$1.COMMENT, resulting_string);
    }
  } else if (in_html_comment && c === '-') {
    resulting_string = this.__patterns.html_comment_end.read();
    if (resulting_string) {
      in_html_comment = false;
      return this._create_token(TOKEN$1.COMMENT, resulting_string);
    }
  }

  return null;
};

Tokenizer$1.prototype._read_comment = function(c) {
  var token = null;
  if (c === '/') {
    var comment = '';
    if (this._input.peek(1) === '*') {
      // peek for comment /* ... */
      comment = this.__patterns.block_comment.read();
      var directives = directives_core.get_directives(comment);
      if (directives && directives.ignore === 'start') {
        comment += directives_core.readIgnored(this._input);
      }
      comment = comment.replace(acorn.allLineBreaks, '\n');
      token = this._create_token(TOKEN$1.BLOCK_COMMENT, comment);
      token.directives = directives;
    } else if (this._input.peek(1) === '/') {
      // peek for comment // ...
      comment = this.__patterns.comment.read();
      token = this._create_token(TOKEN$1.COMMENT, comment);
    }
  }
  return token;
};

Tokenizer$1.prototype._read_string = function(c) {
  if (c === '`' || c === "'" || c === '"') {
    var resulting_string = this._input.next();
    this.has_char_escapes = false;

    if (c === '`') {
      resulting_string += this._read_string_recursive('`', true, '${');
    } else {
      resulting_string += this._read_string_recursive(c);
    }

    if (this.has_char_escapes && this._options.unescape_strings) {
      resulting_string = unescape_string(resulting_string);
    }

    if (this._input.peek() === c) {
      resulting_string += this._input.next();
    }

    resulting_string = resulting_string.replace(acorn.allLineBreaks, '\n');

    return this._create_token(TOKEN$1.STRING, resulting_string);
  }

  return null;
};

Tokenizer$1.prototype._allow_regexp_or_xml = function(previous_token) {
  // regex and xml can only appear in specific locations during parsing
  return (previous_token.type === TOKEN$1.RESERVED && in_array(previous_token.text, ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||
    (previous_token.type === TOKEN$1.END_EXPR && previous_token.text === ')' &&
      previous_token.opened.previous.type === TOKEN$1.RESERVED && in_array(previous_token.opened.previous.text, ['if', 'while', 'for'])) ||
    (in_array(previous_token.type, [TOKEN$1.COMMENT, TOKEN$1.START_EXPR, TOKEN$1.START_BLOCK, TOKEN$1.START,
      TOKEN$1.END_BLOCK, TOKEN$1.OPERATOR, TOKEN$1.EQUALS, TOKEN$1.EOF, TOKEN$1.SEMICOLON, TOKEN$1.COMMA
    ]));
};

Tokenizer$1.prototype._read_regexp = function(c, previous_token) {

  if (c === '/' && this._allow_regexp_or_xml(previous_token)) {
    // handle regexp
    //
    var resulting_string = this._input.next();
    var esc = false;

    var in_char_class = false;
    while (this._input.hasNext() &&
      ((esc || in_char_class || this._input.peek() !== c) &&
        !this._input.testChar(acorn.newline))) {
      resulting_string += this._input.peek();
      if (!esc) {
        esc = this._input.peek() === '\\';
        if (this._input.peek() === '[') {
          in_char_class = true;
        } else if (this._input.peek() === ']') {
          in_char_class = false;
        }
      } else {
        esc = false;
      }
      this._input.next();
    }

    if (this._input.peek() === c) {
      resulting_string += this._input.next();

      // regexps may have modifiers /regexp/MOD , so fetch those, too
      // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.
      resulting_string += this._input.read(acorn.identifier);
    }
    return this._create_token(TOKEN$1.STRING, resulting_string);
  }
  return null;
};

Tokenizer$1.prototype._read_xml = function(c, previous_token) {

  if (this._options.e4x && c === "<" && this._allow_regexp_or_xml(previous_token)) {
    var xmlStr = '';
    var match = this.__patterns.xml.read_match();
    // handle e4x xml literals
    //
    if (match) {
      // Trim root tag to attempt to
      var rootTag = match[2].replace(/^{\s+/, '{').replace(/\s+}$/, '}');
      var isCurlyRoot = rootTag.indexOf('{') === 0;
      var depth = 0;
      while (match) {
        var isEndTag = !!match[1];
        var tagName = match[2];
        var isSingletonTag = (!!match[match.length - 1]) || (tagName.slice(0, 8) === "![CDATA[");
        if (!isSingletonTag &&
          (tagName === rootTag || (isCurlyRoot && tagName.replace(/^{\s+/, '{').replace(/\s+}$/, '}')))) {
          if (isEndTag) {
            --depth;
          } else {
            ++depth;
          }
        }
        xmlStr += match[0];
        if (depth <= 0) {
          break;
        }
        match = this.__patterns.xml.read_match();
      }
      // if we didn't close correctly, keep unformatted.
      if (!match) {
        xmlStr += this._input.match(/[\s\S]*/g)[0];
      }
      xmlStr = xmlStr.replace(acorn.allLineBreaks, '\n');
      return this._create_token(TOKEN$1.STRING, xmlStr);
    }
  }

  return null;
};

function unescape_string(s) {
  // You think that a regex would work for this
  // return s.replace(/\\x([0-9a-f]{2})/gi, function(match, val) {
  //         return String.fromCharCode(parseInt(val, 16));
  //     })
  // However, dealing with '\xff', '\\xff', '\\\xff' makes this more fun.
  var out = '',
    escaped = 0;

  var input_scan = new InputScanner$2(s);
  var matched = null;

  while (input_scan.hasNext()) {
    // Keep any whitespace, non-slash characters
    // also keep slash pairs.
    matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);

    if (matched) {
      out += matched[0];
    }

    if (input_scan.peek() === '\\') {
      input_scan.next();
      if (input_scan.peek() === 'x') {
        matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
      } else if (input_scan.peek() === 'u') {
        matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
      } else {
        out += '\\';
        if (input_scan.hasNext()) {
          out += input_scan.next();
        }
        continue;
      }

      // If there's some error decoding, return the original string
      if (!matched) {
        return s;
      }

      escaped = parseInt(matched[1], 16);

      if (escaped > 0x7e && escaped <= 0xff && matched[0].indexOf('x') === 0) {
        // we bail out on \x7f..\xff,
        // leaving whole string escaped,
        // as it's probably completely binary
        return s;
      } else if (escaped >= 0x00 && escaped < 0x20) {
        // leave 0x00...0x1f escaped
        out += '\\' + matched[0];
        continue;
      } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
        // single-quote, apostrophe, backslash - escape these
        out += '\\' + String.fromCharCode(escaped);
      } else {
        out += String.fromCharCode(escaped);
      }
    }
  }

  return out;
}

// handle string
//
Tokenizer$1.prototype._read_string_recursive = function(delimiter, allow_unescaped_newlines, start_sub) {
  var current_char;
  var pattern;
  if (delimiter === '\'') {
    pattern = this.__patterns.single_quote;
  } else if (delimiter === '"') {
    pattern = this.__patterns.double_quote;
  } else if (delimiter === '`') {
    pattern = this.__patterns.template_text;
  } else if (delimiter === '}') {
    pattern = this.__patterns.template_expression;
  }

  var resulting_string = pattern.read();
  var next = '';
  while (this._input.hasNext()) {
    next = this._input.next();
    if (next === delimiter ||
      (!allow_unescaped_newlines && acorn.newline.test(next))) {
      this._input.back();
      break;
    } else if (next === '\\' && this._input.hasNext()) {
      current_char = this._input.peek();

      if (current_char === 'x' || current_char === 'u') {
        this.has_char_escapes = true;
      } else if (current_char === '\r' && this._input.peek(1) === '\n') {
        this._input.next();
      }
      next += this._input.next();
    } else if (start_sub) {
      if (start_sub === '${' && next === '$' && this._input.peek() === '{') {
        next += this._input.next();
      }

      if (start_sub === next) {
        if (delimiter === '`') {
          next += this._read_string_recursive('}', allow_unescaped_newlines, '`');
        } else {
          next += this._read_string_recursive('`', allow_unescaped_newlines, '${');
        }
        if (this._input.hasNext()) {
          next += this._input.next();
        }
      }
    }
    next += pattern.read();
    resulting_string += next;
  }

  return resulting_string;
};

var Tokenizer_1$1 = Tokenizer$1;
var TOKEN_1$1 = TOKEN$1;
var positionable_operators_1 = positionable_operators.slice();
var line_starters_1 = line_starters.slice();

var tokenizer$1 = {
	Tokenizer: Tokenizer_1$1,
	TOKEN: TOKEN_1$1,
	positionable_operators: positionable_operators_1,
	line_starters: line_starters_1
};

var Output$1 = output.Output;
var Token$2 = token.Token;

var Options$2 = options$2.Options;
var Tokenizer$2 = tokenizer$1.Tokenizer;
var line_starters$1 = tokenizer$1.line_starters;
var positionable_operators$1 = tokenizer$1.positionable_operators;
var TOKEN$2 = tokenizer$1.TOKEN;


function in_array$1(what, arr) {
  return arr.indexOf(what) !== -1;
}

function ltrim(s) {
  return s.replace(/^\s+/g, '');
}

function generateMapFromStrings(list) {
  var result = {};
  for (var x = 0; x < list.length; x++) {
    // make the mapped names underscored instead of dash
    result[list[x].replace(/-/g, '_')] = list[x];
  }
  return result;
}

function reserved_word(token, word) {
  return token && token.type === TOKEN$2.RESERVED && token.text === word;
}

function reserved_array(token, words) {
  return token && token.type === TOKEN$2.RESERVED && in_array$1(token.text, words);
}
// Unsure of what they mean, but they work. Worth cleaning up in future.
var special_words = ['case', 'return', 'do', 'if', 'throw', 'else', 'await', 'break', 'continue', 'async'];

var validPositionValues$1 = ['before-newline', 'after-newline', 'preserve-newline'];

// Generate map from array
var OPERATOR_POSITION = generateMapFromStrings(validPositionValues$1);

var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];

var MODE = {
  BlockStatement: 'BlockStatement', // 'BLOCK'
  Statement: 'Statement', // 'STATEMENT'
  ObjectLiteral: 'ObjectLiteral', // 'OBJECT',
  ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',
  ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',
  Conditional: 'Conditional', //'(COND-EXPRESSION)',
  Expression: 'Expression' //'(EXPRESSION)'
};

function remove_redundant_indentation(output, frame) {
  // This implementation is effective but has some issues:
  //     - can cause line wrap to happen too soon due to indent removal
  //           after wrap points are calculated
  // These issues are minor compared to ugly indentation.

  if (frame.multiline_frame ||
    frame.mode === MODE.ForInitializer ||
    frame.mode === MODE.Conditional) {
    return;
  }

  // remove one indent from each line inside this section
  output.remove_indent(frame.start_line_index);
}

// we could use just string.split, but
// IE doesn't like returning empty strings
function split_linebreaks(s) {
  //return s.split(/\x0d\x0a|\x0a/);

  s = s.replace(acorn.allLineBreaks, '\n');
  var out = [],
    idx = s.indexOf("\n");
  while (idx !== -1) {
    out.push(s.substring(0, idx));
    s = s.substring(idx + 1);
    idx = s.indexOf("\n");
  }
  if (s.length) {
    out.push(s);
  }
  return out;
}

function is_array(mode) {
  return mode === MODE.ArrayLiteral;
}

function is_expression(mode) {
  return in_array$1(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
}

function all_lines_start_with(lines, c) {
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i].trim();
    if (line.charAt(0) !== c) {
      return false;
    }
  }
  return true;
}

function each_line_matches_indent(lines, indent) {
  var i = 0,
    len = lines.length,
    line;
  for (; i < len; i++) {
    line = lines[i];
    // allow empty lines to pass through
    if (line && line.indexOf(indent) !== 0) {
      return false;
    }
  }
  return true;
}


function Beautifier(source_text, options) {
  options = options || {};
  this._source_text = source_text || '';

  this._output = null;
  this._tokens = null;
  this._last_last_text = null;
  this._flags = null;
  this._previous_flags = null;

  this._flag_store = null;
  this._options = new Options$2(options);
}

Beautifier.prototype.create_flags = function(flags_base, mode) {
  var next_indent_level = 0;
  if (flags_base) {
    next_indent_level = flags_base.indentation_level;
    if (!this._output.just_added_newline() &&
      flags_base.line_indent_level > next_indent_level) {
      next_indent_level = flags_base.line_indent_level;
    }
  }

  var next_flags = {
    mode: mode,
    parent: flags_base,
    last_token: flags_base ? flags_base.last_token : new Token$2(TOKEN$2.START_BLOCK, ''), // last token text
    last_word: flags_base ? flags_base.last_word : '', // last TOKEN.WORD passed
    declaration_statement: false,
    declaration_assignment: false,
    multiline_frame: false,
    inline_frame: false,
    if_block: false,
    else_block: false,
    do_block: false,
    do_while: false,
    import_block: false,
    in_case_statement: false, // switch(..){ INSIDE HERE }
    in_case: false, // we're on the exact line with "case 0:"
    case_body: false, // the indented case-action block
    indentation_level: next_indent_level,
    alignment: 0,
    line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
    start_line_index: this._output.get_line_number(),
    ternary_depth: 0
  };
  return next_flags;
};

Beautifier.prototype._reset = function(source_text) {
  var baseIndentString = source_text.match(/^[\t ]*/)[0];

  this._last_last_text = ''; // pre-last token text
  this._output = new Output$1(this._options, baseIndentString);

  // If testing the ignore directive, start with output disable set to true
  this._output.raw = this._options.test_output_raw;


  // Stack of parsing/formatting states, including MODE.
  // We tokenize, parse, and output in an almost purely a forward-only stream of token input
  // and formatted output.  This makes the beautifier less accurate than full parsers
  // but also far more tolerant of syntax errors.
  //
  // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
  // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
  // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
  // most full parsers would die, but the beautifier gracefully falls back to
  // MODE.BlockStatement and continues on.
  this._flag_store = [];
  this.set_mode(MODE.BlockStatement);
  var tokenizer = new Tokenizer$2(source_text, this._options);
  this._tokens = tokenizer.tokenize();
  return source_text;
};

Beautifier.prototype.beautify = function() {
  // if disabled, return the input unchanged.
  if (this._options.disabled) {
    return this._source_text;
  }

  var sweet_code;
  var source_text = this._reset(this._source_text);

  var eol = this._options.eol;
  if (this._options.eol === 'auto') {
    eol = '\n';
    if (source_text && acorn.lineBreak.test(source_text || '')) {
      eol = source_text.match(acorn.lineBreak)[0];
    }
  }

  var current_token = this._tokens.next();
  while (current_token) {
    this.handle_token(current_token);

    this._last_last_text = this._flags.last_token.text;
    this._flags.last_token = current_token;

    current_token = this._tokens.next();
  }

  sweet_code = this._output.get_code(eol);

  return sweet_code;
};

Beautifier.prototype.handle_token = function(current_token, preserve_statement_flags) {
  if (current_token.type === TOKEN$2.START_EXPR) {
    this.handle_start_expr(current_token);
  } else if (current_token.type === TOKEN$2.END_EXPR) {
    this.handle_end_expr(current_token);
  } else if (current_token.type === TOKEN$2.START_BLOCK) {
    this.handle_start_block(current_token);
  } else if (current_token.type === TOKEN$2.END_BLOCK) {
    this.handle_end_block(current_token);
  } else if (current_token.type === TOKEN$2.WORD) {
    this.handle_word(current_token);
  } else if (current_token.type === TOKEN$2.RESERVED) {
    this.handle_word(current_token);
  } else if (current_token.type === TOKEN$2.SEMICOLON) {
    this.handle_semicolon(current_token);
  } else if (current_token.type === TOKEN$2.STRING) {
    this.handle_string(current_token);
  } else if (current_token.type === TOKEN$2.EQUALS) {
    this.handle_equals(current_token);
  } else if (current_token.type === TOKEN$2.OPERATOR) {
    this.handle_operator(current_token);
  } else if (current_token.type === TOKEN$2.COMMA) {
    this.handle_comma(current_token);
  } else if (current_token.type === TOKEN$2.BLOCK_COMMENT) {
    this.handle_block_comment(current_token, preserve_statement_flags);
  } else if (current_token.type === TOKEN$2.COMMENT) {
    this.handle_comment(current_token, preserve_statement_flags);
  } else if (current_token.type === TOKEN$2.DOT) {
    this.handle_dot(current_token);
  } else if (current_token.type === TOKEN$2.EOF) {
    this.handle_eof(current_token);
  } else if (current_token.type === TOKEN$2.UNKNOWN) {
    this.handle_unknown(current_token, preserve_statement_flags);
  } else {
    this.handle_unknown(current_token, preserve_statement_flags);
  }
};

Beautifier.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {
  var newlines = current_token.newlines;
  var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);

  if (current_token.comments_before) {
    var comment_token = current_token.comments_before.next();
    while (comment_token) {
      // The cleanest handling of inline comments is to treat them as though they aren't there.
      // Just continue formatting and the behavior should be logical.
      // Also ignore unknown tokens.  Again, this should result in better behavior.
      this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);
      this.handle_token(comment_token, preserve_statement_flags);
      comment_token = current_token.comments_before.next();
    }
  }

  if (keep_whitespace) {
    for (var i = 0; i < newlines; i += 1) {
      this.print_newline(i > 0, preserve_statement_flags);
    }
  } else {
    if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {
      newlines = this._options.max_preserve_newlines;
    }

    if (this._options.preserve_newlines) {
      if (newlines > 1) {
        this.print_newline(false, preserve_statement_flags);
        for (var j = 1; j < newlines; j += 1) {
          this.print_newline(true, preserve_statement_flags);
        }
      }
    }
  }

};

var newline_restricted_tokens = ['async', 'break', 'continue', 'return', 'throw', 'yield'];

Beautifier.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {
  force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;

  // Never wrap the first token on a line
  if (this._output.just_added_newline()) {
    return;
  }

  var shouldPreserveOrForce = (this._options.preserve_newlines && current_token.newlines) || force_linewrap;
  var operatorLogicApplies = in_array$1(this._flags.last_token.text, positionable_operators$1) ||
    in_array$1(current_token.text, positionable_operators$1);

  if (operatorLogicApplies) {
    var shouldPrintOperatorNewline = (
        in_array$1(this._flags.last_token.text, positionable_operators$1) &&
        in_array$1(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)
      ) ||
      in_array$1(current_token.text, positionable_operators$1);
    shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
  }

  if (shouldPreserveOrForce) {
    this.print_newline(false, true);
  } else if (this._options.wrap_line_length) {
    if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {
      // These tokens should never have a newline inserted
      // between them and the following expression.
      return;
    }
    this._output.set_wrap_point();
  }
};

Beautifier.prototype.print_newline = function(force_newline, preserve_statement_flags) {
  if (!preserve_statement_flags) {
    if (this._flags.last_token.text !== ';' && this._flags.last_token.text !== ',' && this._flags.last_token.text !== '=' && (this._flags.last_token.type !== TOKEN$2.OPERATOR || this._flags.last_token.text === '--' || this._flags.last_token.text === '++')) {
      var next_token = this._tokens.peek();
      while (this._flags.mode === MODE.Statement &&
        !(this._flags.if_block && reserved_word(next_token, 'else')) &&
        !this._flags.do_block) {
        this.restore_mode();
      }
    }
  }

  if (this._output.add_new_line(force_newline)) {
    this._flags.multiline_frame = true;
  }
};

Beautifier.prototype.print_token_line_indentation = function(current_token) {
  if (this._output.just_added_newline()) {
    if (this._options.keep_array_indentation &&
      current_token.newlines &&
      (current_token.text === '[' || is_array(this._flags.mode))) {
      this._output.current_line.set_indent(-1);
      this._output.current_line.push(current_token.whitespace_before);
      this._output.space_before_token = false;
    } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {
      this._flags.line_indent_level = this._flags.indentation_level;
    }
  }
};

Beautifier.prototype.print_token = function(current_token) {
  if (this._output.raw) {
    this._output.add_raw_token(current_token);
    return;
  }

  if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN$2.COMMA &&
    this._output.just_added_newline()) {
    if (this._output.previous_line.last() === ',') {
      var popped = this._output.previous_line.pop();
      // if the comma was already at the start of the line,
      // pull back onto that line and reprint the indentation
      if (this._output.previous_line.is_empty()) {
        this._output.previous_line.push(popped);
        this._output.trim(true);
        this._output.current_line.pop();
        this._output.trim();
      }

      // add the comma in front of the next token
      this.print_token_line_indentation(current_token);
      this._output.add_token(',');
      this._output.space_before_token = true;
    }
  }

  this.print_token_line_indentation(current_token);
  this._output.non_breaking_space = true;
  this._output.add_token(current_token.text);
  if (this._output.previous_token_wrapped) {
    this._flags.multiline_frame = true;
  }
};

Beautifier.prototype.indent = function() {
  this._flags.indentation_level += 1;
  this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
};

Beautifier.prototype.deindent = function() {
  if (this._flags.indentation_level > 0 &&
    ((!this._flags.parent) || this._flags.indentation_level > this._flags.parent.indentation_level)) {
    this._flags.indentation_level -= 1;
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  }
};

Beautifier.prototype.set_mode = function(mode) {
  if (this._flags) {
    this._flag_store.push(this._flags);
    this._previous_flags = this._flags;
  } else {
    this._previous_flags = this.create_flags(null, mode);
  }

  this._flags = this.create_flags(this._previous_flags, mode);
  this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
};


Beautifier.prototype.restore_mode = function() {
  if (this._flag_store.length > 0) {
    this._previous_flags = this._flags;
    this._flags = this._flag_store.pop();
    if (this._previous_flags.mode === MODE.Statement) {
      remove_redundant_indentation(this._output, this._previous_flags);
    }
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  }
};

Beautifier.prototype.start_of_object_property = function() {
  return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (
    (this._flags.last_token.text === ':' && this._flags.ternary_depth === 0) || (reserved_array(this._flags.last_token, ['get', 'set'])));
};

Beautifier.prototype.start_of_statement = function(current_token) {
  var start = false;
  start = start || reserved_array(this._flags.last_token, ['var', 'let', 'const']) && current_token.type === TOKEN$2.WORD;
  start = start || reserved_word(this._flags.last_token, 'do');
  start = start || (!(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement)) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;
  start = start || reserved_word(this._flags.last_token, 'else') &&
    !(reserved_word(current_token, 'if') && !current_token.comments_before);
  start = start || (this._flags.last_token.type === TOKEN$2.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional));
  start = start || (this._flags.last_token.type === TOKEN$2.WORD && this._flags.mode === MODE.BlockStatement &&
    !this._flags.in_case &&
    !(current_token.text === '--' || current_token.text === '++') &&
    this._last_last_text !== 'function' &&
    current_token.type !== TOKEN$2.WORD && current_token.type !== TOKEN$2.RESERVED);
  start = start || (this._flags.mode === MODE.ObjectLiteral && (
    (this._flags.last_token.text === ':' && this._flags.ternary_depth === 0) || reserved_array(this._flags.last_token, ['get', 'set'])));

  if (start) {
    this.set_mode(MODE.Statement);
    this.indent();

    this.handle_whitespace_and_comments(current_token, true);

    // Issue #276:
    // If starting a new statement with [if, for, while, do], push to a new line.
    // if (a) if (b) if(c) d(); else e(); else f();
    if (!this.start_of_object_property()) {
      this.allow_wrap_or_preserved_newline(current_token,
        reserved_array(current_token, ['do', 'for', 'if', 'while']));
    }
    return true;
  }
  return false;
};

Beautifier.prototype.handle_start_expr = function(current_token) {
  // The conditional starts the statement if appropriate.
  if (!this.start_of_statement(current_token)) {
    this.handle_whitespace_and_comments(current_token);
  }

  var next_mode = MODE.Expression;
  if (current_token.text === '[') {

    if (this._flags.last_token.type === TOKEN$2.WORD || this._flags.last_token.text === ')') {
      // this is array index specifier, break immediately
      // a[x], fn()[x]
      if (reserved_array(this._flags.last_token, line_starters$1)) {
        this._output.space_before_token = true;
      }
      this.print_token(current_token);
      this.set_mode(next_mode);
      this.indent();
      if (this._options.space_in_paren) {
        this._output.space_before_token = true;
      }
      return;
    }

    next_mode = MODE.ArrayLiteral;
    if (is_array(this._flags.mode)) {
      if (this._flags.last_token.text === '[' ||
        (this._flags.last_token.text === ',' && (this._last_last_text === ']' || this._last_last_text === '}'))) {
        // ], [ goes to new line
        // }, [ goes to new line
        if (!this._options.keep_array_indentation) {
          this.print_newline();
        }
      }
    }

    if (!in_array$1(this._flags.last_token.type, [TOKEN$2.START_EXPR, TOKEN$2.END_EXPR, TOKEN$2.WORD, TOKEN$2.OPERATOR])) {
      this._output.space_before_token = true;
    }
  } else {
    if (this._flags.last_token.type === TOKEN$2.RESERVED) {
      if (this._flags.last_token.text === 'for') {
        this._output.space_before_token = this._options.space_before_conditional;
        next_mode = MODE.ForInitializer;
      } else if (in_array$1(this._flags.last_token.text, ['if', 'while'])) {
        this._output.space_before_token = this._options.space_before_conditional;
        next_mode = MODE.Conditional;
      } else if (in_array$1(this._flags.last_word, ['await', 'async'])) {
        // Should be a space between await and an IIFE, or async and an arrow function
        this._output.space_before_token = true;
      } else if (this._flags.last_token.text === 'import' && current_token.whitespace_before === '') {
        this._output.space_before_token = false;
      } else if (in_array$1(this._flags.last_token.text, line_starters$1) || this._flags.last_token.text === 'catch') {
        this._output.space_before_token = true;
      }
    } else if (this._flags.last_token.type === TOKEN$2.EQUALS || this._flags.last_token.type === TOKEN$2.OPERATOR) {
      // Support of this kind of newline preservation.
      // a = (b &&
      //     (c || d));
      if (!this.start_of_object_property()) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    } else if (this._flags.last_token.type === TOKEN$2.WORD) {
      this._output.space_before_token = false;

      // function name() vs function name ()
      // function* name() vs function* name ()
      // async name() vs async name ()
      // In ES6, you can also define the method properties of an object
      // var obj = {a: function() {}}
      // It can be abbreviated
      // var obj = {a() {}}
      // var obj = { a() {}} vs var obj = { a () {}}
      // var obj = { * a() {}} vs var obj = { * a () {}}
      var peek_back_two = this._tokens.peek(-3);
      if (this._options.space_after_named_function && peek_back_two) {
        // peek starts at next character so -1 is current token
        var peek_back_three = this._tokens.peek(-4);
        if (reserved_array(peek_back_two, ['async', 'function']) ||
          (peek_back_two.text === '*' && reserved_array(peek_back_three, ['async', 'function']))) {
          this._output.space_before_token = true;
        } else if (this._flags.mode === MODE.ObjectLiteral) {
          if ((peek_back_two.text === '{' || peek_back_two.text === ',') ||
            (peek_back_two.text === '*' && (peek_back_three.text === '{' || peek_back_three.text === ','))) {
            this._output.space_before_token = true;
          }
        }
      }
    } else {
      // Support preserving wrapped arrow function expressions
      // a.b('c',
      //     () => d.e
      // )
      this.allow_wrap_or_preserved_newline(current_token);
    }

    // function() vs function ()
    // yield*() vs yield* ()
    // function*() vs function* ()
    if ((this._flags.last_token.type === TOKEN$2.RESERVED && (this._flags.last_word === 'function' || this._flags.last_word === 'typeof')) ||
      (this._flags.last_token.text === '*' &&
        (in_array$1(this._last_last_text, ['function', 'yield']) ||
          (this._flags.mode === MODE.ObjectLiteral && in_array$1(this._last_last_text, ['{', ',']))))) {
      this._output.space_before_token = this._options.space_after_anon_function;
    }
  }

  if (this._flags.last_token.text === ';' || this._flags.last_token.type === TOKEN$2.START_BLOCK) {
    this.print_newline();
  } else if (this._flags.last_token.type === TOKEN$2.END_EXPR || this._flags.last_token.type === TOKEN$2.START_EXPR || this._flags.last_token.type === TOKEN$2.END_BLOCK || this._flags.last_token.text === '.' || this._flags.last_token.type === TOKEN$2.COMMA) {
    // do nothing on (( and )( and ][ and ]( and .(
    // TODO: Consider whether forcing this is required.  Review failing tests when removed.
    this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);
  }

  this.print_token(current_token);
  this.set_mode(next_mode);
  if (this._options.space_in_paren) {
    this._output.space_before_token = true;
  }

  // In all cases, if we newline while inside an expression it should be indented.
  this.indent();
};

Beautifier.prototype.handle_end_expr = function(current_token) {
  // statements inside expressions are not valid syntax, but...
  // statements must all be closed when their container closes
  while (this._flags.mode === MODE.Statement) {
    this.restore_mode();
  }

  this.handle_whitespace_and_comments(current_token);

  if (this._flags.multiline_frame) {
    this.allow_wrap_or_preserved_newline(current_token,
      current_token.text === ']' && is_array(this._flags.mode) && !this._options.keep_array_indentation);
  }

  if (this._options.space_in_paren) {
    if (this._flags.last_token.type === TOKEN$2.START_EXPR && !this._options.space_in_empty_paren) {
      // () [] no inner space in empty parens like these, ever, ref #320
      this._output.trim();
      this._output.space_before_token = false;
    } else {
      this._output.space_before_token = true;
    }
  }
  this.deindent();
  this.print_token(current_token);
  this.restore_mode();

  remove_redundant_indentation(this._output, this._previous_flags);

  // do {} while () // no statement required after
  if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {
    this._previous_flags.mode = MODE.Expression;
    this._flags.do_block = false;
    this._flags.do_while = false;

  }
};

Beautifier.prototype.handle_start_block = function(current_token) {
  this.handle_whitespace_and_comments(current_token);

  // Check if this is should be treated as a ObjectLiteral
  var next_token = this._tokens.peek();
  var second_token = this._tokens.peek(1);
  if (this._flags.last_word === 'switch' && this._flags.last_token.type === TOKEN$2.END_EXPR) {
    this.set_mode(MODE.BlockStatement);
    this._flags.in_case_statement = true;
  } else if (this._flags.case_body) {
    this.set_mode(MODE.BlockStatement);
  } else if (second_token && (
      (in_array$1(second_token.text, [':', ',']) && in_array$1(next_token.type, [TOKEN$2.STRING, TOKEN$2.WORD, TOKEN$2.RESERVED])) ||
      (in_array$1(next_token.text, ['get', 'set', '...']) && in_array$1(second_token.type, [TOKEN$2.WORD, TOKEN$2.RESERVED]))
    )) {
    // We don't support TypeScript,but we didn't break it for a very long time.
    // We'll try to keep not breaking it.
    if (!in_array$1(this._last_last_text, ['class', 'interface'])) {
      this.set_mode(MODE.ObjectLiteral);
    } else {
      this.set_mode(MODE.BlockStatement);
    }
  } else if (this._flags.last_token.type === TOKEN$2.OPERATOR && this._flags.last_token.text === '=>') {
    // arrow function: (param1, paramN) => { statements }
    this.set_mode(MODE.BlockStatement);
  } else if (in_array$1(this._flags.last_token.type, [TOKEN$2.EQUALS, TOKEN$2.START_EXPR, TOKEN$2.COMMA, TOKEN$2.OPERATOR]) ||
    reserved_array(this._flags.last_token, ['return', 'throw', 'import', 'default'])
  ) {
    // Detecting shorthand function syntax is difficult by scanning forward,
    //     so check the surrounding context.
    // If the block is being returned, imported, export default, passed as arg,
    //     assigned with = or assigned in a nested object, treat as an ObjectLiteral.
    this.set_mode(MODE.ObjectLiteral);
  } else {
    this.set_mode(MODE.BlockStatement);
  }

  var empty_braces = !next_token.comments_before && next_token.text === '}';
  var empty_anonymous_function = empty_braces && this._flags.last_word === 'function' &&
    this._flags.last_token.type === TOKEN$2.END_EXPR;

  if (this._options.brace_preserve_inline) // check for inline, set inline_frame if so
  {
    // search forward for a newline wanted inside this block
    var index = 0;
    var check_token = null;
    this._flags.inline_frame = true;
    do {
      index += 1;
      check_token = this._tokens.peek(index - 1);
      if (check_token.newlines) {
        this._flags.inline_frame = false;
        break;
      }
    } while (check_token.type !== TOKEN$2.EOF &&
      !(check_token.type === TOKEN$2.END_BLOCK && check_token.opened === current_token));
  }

  if ((this._options.brace_style === "expand" ||
      (this._options.brace_style === "none" && current_token.newlines)) &&
    !this._flags.inline_frame) {
    if (this._flags.last_token.type !== TOKEN$2.OPERATOR &&
      (empty_anonymous_function ||
        this._flags.last_token.type === TOKEN$2.EQUALS ||
        (reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== 'else'))) {
      this._output.space_before_token = true;
    } else {
      this.print_newline(false, true);
    }
  } else { // collapse || inline_frame
    if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN$2.START_EXPR || this._flags.last_token.type === TOKEN$2.COMMA)) {
      if (this._flags.last_token.type === TOKEN$2.COMMA || this._options.space_in_paren) {
        this._output.space_before_token = true;
      }

      if (this._flags.last_token.type === TOKEN$2.COMMA || (this._flags.last_token.type === TOKEN$2.START_EXPR && this._flags.inline_frame)) {
        this.allow_wrap_or_preserved_newline(current_token);
        this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;
        this._flags.multiline_frame = false;
      }
    }
    if (this._flags.last_token.type !== TOKEN$2.OPERATOR && this._flags.last_token.type !== TOKEN$2.START_EXPR) {
      if (this._flags.last_token.type === TOKEN$2.START_BLOCK && !this._flags.inline_frame) {
        this.print_newline();
      } else {
        this._output.space_before_token = true;
      }
    }
  }
  this.print_token(current_token);
  this.indent();

  // Except for specific cases, open braces are followed by a new line.
  if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {
    this.print_newline();
  }
};

Beautifier.prototype.handle_end_block = function(current_token) {
  // statements must all be closed when their container closes
  this.handle_whitespace_and_comments(current_token);

  while (this._flags.mode === MODE.Statement) {
    this.restore_mode();
  }

  var empty_braces = this._flags.last_token.type === TOKEN$2.START_BLOCK;

  if (this._flags.inline_frame && !empty_braces) { // try inline_frame (only set if this._options.braces-preserve-inline) first
    this._output.space_before_token = true;
  } else if (this._options.brace_style === "expand") {
    if (!empty_braces) {
      this.print_newline();
    }
  } else {
    // skip {}
    if (!empty_braces) {
      if (is_array(this._flags.mode) && this._options.keep_array_indentation) {
        // we REALLY need a newline here, but newliner would skip that
        this._options.keep_array_indentation = false;
        this.print_newline();
        this._options.keep_array_indentation = true;

      } else {
        this.print_newline();
      }
    }
  }
  this.restore_mode();
  this.print_token(current_token);
};

Beautifier.prototype.handle_word = function(current_token) {
  if (current_token.type === TOKEN$2.RESERVED) {
    if (in_array$1(current_token.text, ['set', 'get']) && this._flags.mode !== MODE.ObjectLiteral) {
      current_token.type = TOKEN$2.WORD;
    } else if (current_token.text === 'import' && this._tokens.peek().text === '(') {
      current_token.type = TOKEN$2.WORD;
    } else if (in_array$1(current_token.text, ['as', 'from']) && !this._flags.import_block) {
      current_token.type = TOKEN$2.WORD;
    } else if (this._flags.mode === MODE.ObjectLiteral) {
      var next_token = this._tokens.peek();
      if (next_token.text === ':') {
        current_token.type = TOKEN$2.WORD;
      }
    }
  }

  if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
    if (reserved_array(this._flags.last_token, ['var', 'let', 'const']) && current_token.type === TOKEN$2.WORD) {
      this._flags.declaration_statement = true;
    }
  } else if (current_token.newlines && !is_expression(this._flags.mode) &&
    (this._flags.last_token.type !== TOKEN$2.OPERATOR || (this._flags.last_token.text === '--' || this._flags.last_token.text === '++')) &&
    this._flags.last_token.type !== TOKEN$2.EQUALS &&
    (this._options.preserve_newlines || !reserved_array(this._flags.last_token, ['var', 'let', 'const', 'set', 'get']))) {
    this.handle_whitespace_and_comments(current_token);
    this.print_newline();
  } else {
    this.handle_whitespace_and_comments(current_token);
  }

  if (this._flags.do_block && !this._flags.do_while) {
    if (reserved_word(current_token, 'while')) {
      // do {} ## while ()
      this._output.space_before_token = true;
      this.print_token(current_token);
      this._output.space_before_token = true;
      this._flags.do_while = true;
      return;
    } else {
      // do {} should always have while as the next word.
      // if we don't see the expected while, recover
      this.print_newline();
      this._flags.do_block = false;
    }
  }

  // if may be followed by else, or not
  // Bare/inline ifs are tricky
  // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
  if (this._flags.if_block) {
    if (!this._flags.else_block && reserved_word(current_token, 'else')) {
      this._flags.else_block = true;
    } else {
      while (this._flags.mode === MODE.Statement) {
        this.restore_mode();
      }
      this._flags.if_block = false;
      this._flags.else_block = false;
    }
  }

  if (this._flags.in_case_statement && reserved_array(current_token, ['case', 'default'])) {
    this.print_newline();
    if (this._flags.last_token.type !== TOKEN$2.END_BLOCK && (this._flags.case_body || this._options.jslint_happy)) {
      // switch cases following one another
      this.deindent();
    }
    this._flags.case_body = false;

    this.print_token(current_token);
    this._flags.in_case = true;
    return;
  }

  if (this._flags.last_token.type === TOKEN$2.COMMA || this._flags.last_token.type === TOKEN$2.START_EXPR || this._flags.last_token.type === TOKEN$2.EQUALS || this._flags.last_token.type === TOKEN$2.OPERATOR) {
    if (!this.start_of_object_property()) {
      this.allow_wrap_or_preserved_newline(current_token);
    }
  }

  if (reserved_word(current_token, 'function')) {
    if (in_array$1(this._flags.last_token.text, ['}', ';']) ||
      (this._output.just_added_newline() && !(in_array$1(this._flags.last_token.text, ['(', '[', '{', ':', '=', ',']) || this._flags.last_token.type === TOKEN$2.OPERATOR))) {
      // make sure there is a nice clean space of at least one blank line
      // before a new function definition
      if (!this._output.just_added_blankline() && !current_token.comments_before) {
        this.print_newline();
        this.print_newline(true);
      }
    }
    if (this._flags.last_token.type === TOKEN$2.RESERVED || this._flags.last_token.type === TOKEN$2.WORD) {
      if (reserved_array(this._flags.last_token, ['get', 'set', 'new', 'export']) ||
        reserved_array(this._flags.last_token, newline_restricted_tokens)) {
        this._output.space_before_token = true;
      } else if (reserved_word(this._flags.last_token, 'default') && this._last_last_text === 'export') {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.text === 'declare') {
        // accomodates Typescript declare function formatting
        this._output.space_before_token = true;
      } else {
        this.print_newline();
      }
    } else if (this._flags.last_token.type === TOKEN$2.OPERATOR || this._flags.last_token.text === '=') {
      // foo = function
      this._output.space_before_token = true;
    } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode))) ; else {
      this.print_newline();
    }

    this.print_token(current_token);
    this._flags.last_word = current_token.text;
    return;
  }

  var prefix = 'NONE';

  if (this._flags.last_token.type === TOKEN$2.END_BLOCK) {

    if (this._previous_flags.inline_frame) {
      prefix = 'SPACE';
    } else if (!reserved_array(current_token, ['else', 'catch', 'finally', 'from'])) {
      prefix = 'NEWLINE';
    } else {
      if (this._options.brace_style === "expand" ||
        this._options.brace_style === "end-expand" ||
        (this._options.brace_style === "none" && current_token.newlines)) {
        prefix = 'NEWLINE';
      } else {
        prefix = 'SPACE';
        this._output.space_before_token = true;
      }
    }
  } else if (this._flags.last_token.type === TOKEN$2.SEMICOLON && this._flags.mode === MODE.BlockStatement) {
    // TODO: Should this be for STATEMENT as well?
    prefix = 'NEWLINE';
  } else if (this._flags.last_token.type === TOKEN$2.SEMICOLON && is_expression(this._flags.mode)) {
    prefix = 'SPACE';
  } else if (this._flags.last_token.type === TOKEN$2.STRING) {
    prefix = 'NEWLINE';
  } else if (this._flags.last_token.type === TOKEN$2.RESERVED || this._flags.last_token.type === TOKEN$2.WORD ||
    (this._flags.last_token.text === '*' &&
      (in_array$1(this._last_last_text, ['function', 'yield']) ||
        (this._flags.mode === MODE.ObjectLiteral && in_array$1(this._last_last_text, ['{', ',']))))) {
    prefix = 'SPACE';
  } else if (this._flags.last_token.type === TOKEN$2.START_BLOCK) {
    if (this._flags.inline_frame) {
      prefix = 'SPACE';
    } else {
      prefix = 'NEWLINE';
    }
  } else if (this._flags.last_token.type === TOKEN$2.END_EXPR) {
    this._output.space_before_token = true;
    prefix = 'NEWLINE';
  }

  if (reserved_array(current_token, line_starters$1) && this._flags.last_token.text !== ')') {
    if (this._flags.inline_frame || this._flags.last_token.text === 'else' || this._flags.last_token.text === 'export') {
      prefix = 'SPACE';
    } else {
      prefix = 'NEWLINE';
    }

  }

  if (reserved_array(current_token, ['else', 'catch', 'finally'])) {
    if ((!(this._flags.last_token.type === TOKEN$2.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) ||
        this._options.brace_style === "expand" ||
        this._options.brace_style === "end-expand" ||
        (this._options.brace_style === "none" && current_token.newlines)) &&
      !this._flags.inline_frame) {
      this.print_newline();
    } else {
      this._output.trim(true);
      var line = this._output.current_line;
      // If we trimmed and there's something other than a close block before us
      // put a newline back in.  Handles '} // comment' scenario.
      if (line.last() !== '}') {
        this.print_newline();
      }
      this._output.space_before_token = true;
    }
  } else if (prefix === 'NEWLINE') {
    if (reserved_array(this._flags.last_token, special_words)) {
      // no newline between 'return nnn'
      this._output.space_before_token = true;
    } else if (this._flags.last_token.text === 'declare' && reserved_array(current_token, ['var', 'let', 'const'])) {
      // accomodates Typescript declare formatting
      this._output.space_before_token = true;
    } else if (this._flags.last_token.type !== TOKEN$2.END_EXPR) {
      if ((this._flags.last_token.type !== TOKEN$2.START_EXPR || !reserved_array(current_token, ['var', 'let', 'const'])) && this._flags.last_token.text !== ':') {
        // no need to force newline on 'var': for (var x = 0...)
        if (reserved_word(current_token, 'if') && reserved_word(current_token.previous, 'else')) {
          // no newline for } else if {
          this._output.space_before_token = true;
        } else {
          this.print_newline();
        }
      }
    } else if (reserved_array(current_token, line_starters$1) && this._flags.last_token.text !== ')') {
      this.print_newline();
    }
  } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === ',' && this._last_last_text === '}') {
    this.print_newline(); // }, in lists get a newline treatment
  } else if (prefix === 'SPACE') {
    this._output.space_before_token = true;
  }
  if (current_token.previous && (current_token.previous.type === TOKEN$2.WORD || current_token.previous.type === TOKEN$2.RESERVED)) {
    this._output.space_before_token = true;
  }
  this.print_token(current_token);
  this._flags.last_word = current_token.text;

  if (current_token.type === TOKEN$2.RESERVED) {
    if (current_token.text === 'do') {
      this._flags.do_block = true;
    } else if (current_token.text === 'if') {
      this._flags.if_block = true;
    } else if (current_token.text === 'import') {
      this._flags.import_block = true;
    } else if (this._flags.import_block && reserved_word(current_token, 'from')) {
      this._flags.import_block = false;
    }
  }
};

Beautifier.prototype.handle_semicolon = function(current_token) {
  if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
    // Semicolon can be the start (and end) of a statement
    this._output.space_before_token = false;
  } else {
    this.handle_whitespace_and_comments(current_token);
  }

  var next_token = this._tokens.peek();
  while (this._flags.mode === MODE.Statement &&
    !(this._flags.if_block && reserved_word(next_token, 'else')) &&
    !this._flags.do_block) {
    this.restore_mode();
  }

  // hacky but effective for the moment
  if (this._flags.import_block) {
    this._flags.import_block = false;
  }
  this.print_token(current_token);
};

Beautifier.prototype.handle_string = function(current_token) {
  if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
    // One difference - strings want at least a space before
    this._output.space_before_token = true;
  } else {
    this.handle_whitespace_and_comments(current_token);
    if (this._flags.last_token.type === TOKEN$2.RESERVED || this._flags.last_token.type === TOKEN$2.WORD || this._flags.inline_frame) {
      this._output.space_before_token = true;
    } else if (this._flags.last_token.type === TOKEN$2.COMMA || this._flags.last_token.type === TOKEN$2.START_EXPR || this._flags.last_token.type === TOKEN$2.EQUALS || this._flags.last_token.type === TOKEN$2.OPERATOR) {
      if (!this.start_of_object_property()) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    } else {
      this.print_newline();
    }
  }
  this.print_token(current_token);
};

Beautifier.prototype.handle_equals = function(current_token) {
  if (this.start_of_statement(current_token)) ; else {
    this.handle_whitespace_and_comments(current_token);
  }

  if (this._flags.declaration_statement) {
    // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
    this._flags.declaration_assignment = true;
  }
  this._output.space_before_token = true;
  this.print_token(current_token);
  this._output.space_before_token = true;
};

Beautifier.prototype.handle_comma = function(current_token) {
  this.handle_whitespace_and_comments(current_token, true);

  this.print_token(current_token);
  this._output.space_before_token = true;
  if (this._flags.declaration_statement) {
    if (is_expression(this._flags.parent.mode)) {
      // do not break on comma, for(var a = 1, b = 2)
      this._flags.declaration_assignment = false;
    }

    if (this._flags.declaration_assignment) {
      this._flags.declaration_assignment = false;
      this.print_newline(false, true);
    } else if (this._options.comma_first) {
      // for comma-first, we want to allow a newline before the comma
      // to turn into a newline after the comma, which we will fixup later
      this.allow_wrap_or_preserved_newline(current_token);
    }
  } else if (this._flags.mode === MODE.ObjectLiteral ||
    (this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral)) {
    if (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }

    if (!this._flags.inline_frame) {
      this.print_newline();
    }
  } else if (this._options.comma_first) {
    // EXPR or DO_BLOCK
    // for comma-first, we want to allow a newline before the comma
    // to turn into a newline after the comma, which we will fixup later
    this.allow_wrap_or_preserved_newline(current_token);
  }
};

Beautifier.prototype.handle_operator = function(current_token) {
  var isGeneratorAsterisk = current_token.text === '*' &&
    (reserved_array(this._flags.last_token, ['function', 'yield']) ||
      (in_array$1(this._flags.last_token.type, [TOKEN$2.START_BLOCK, TOKEN$2.COMMA, TOKEN$2.END_BLOCK, TOKEN$2.SEMICOLON]))
    );
  var isUnary = in_array$1(current_token.text, ['-', '+']) && (
    in_array$1(this._flags.last_token.type, [TOKEN$2.START_BLOCK, TOKEN$2.START_EXPR, TOKEN$2.EQUALS, TOKEN$2.OPERATOR]) ||
    in_array$1(this._flags.last_token.text, line_starters$1) ||
    this._flags.last_token.text === ','
  );

  if (this.start_of_statement(current_token)) ; else {
    var preserve_statement_flags = !isGeneratorAsterisk;
    this.handle_whitespace_and_comments(current_token, preserve_statement_flags);
  }

  if (reserved_array(this._flags.last_token, special_words)) {
    // "return" had a special handling in TK_WORD. Now we need to return the favor
    this._output.space_before_token = true;
    this.print_token(current_token);
    return;
  }

  // hack for actionscript's import .*;
  if (current_token.text === '*' && this._flags.last_token.type === TOKEN$2.DOT) {
    this.print_token(current_token);
    return;
  }

  if (current_token.text === '::') {
    // no spaces around exotic namespacing syntax operator
    this.print_token(current_token);
    return;
  }

  // Allow line wrapping between operators when operator_position is
  //   set to before or preserve
  if (this._flags.last_token.type === TOKEN$2.OPERATOR && in_array$1(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
    this.allow_wrap_or_preserved_newline(current_token);
  }

  if (current_token.text === ':' && this._flags.in_case) {
    this.print_token(current_token);

    this._flags.in_case = false;
    this._flags.case_body = true;
    if (this._tokens.peek().type !== TOKEN$2.START_BLOCK) {
      this.indent();
      this.print_newline();
    } else {
      this._output.space_before_token = true;
    }
    return;
  }

  var space_before = true;
  var space_after = true;
  var in_ternary = false;
  if (current_token.text === ':') {
    if (this._flags.ternary_depth === 0) {
      // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.
      space_before = false;
    } else {
      this._flags.ternary_depth -= 1;
      in_ternary = true;
    }
  } else if (current_token.text === '?') {
    this._flags.ternary_depth += 1;
  }

  // let's handle the operator_position option prior to any conflicting logic
  if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array$1(current_token.text, positionable_operators$1)) {
    var isColon = current_token.text === ':';
    var isTernaryColon = (isColon && in_ternary);
    var isOtherColon = (isColon && !in_ternary);

    switch (this._options.operator_position) {
      case OPERATOR_POSITION.before_newline:
        // if the current token is : and it's not a ternary statement then we set space_before to false
        this._output.space_before_token = !isOtherColon;

        this.print_token(current_token);

        if (!isColon || isTernaryColon) {
          this.allow_wrap_or_preserved_newline(current_token);
        }

        this._output.space_before_token = true;
        return;

      case OPERATOR_POSITION.after_newline:
        // if the current token is anything but colon, or (via deduction) it's a colon and in a ternary statement,
        //   then print a newline.

        this._output.space_before_token = true;

        if (!isColon || isTernaryColon) {
          if (this._tokens.peek().newlines) {
            this.print_newline(false, true);
          } else {
            this.allow_wrap_or_preserved_newline(current_token);
          }
        } else {
          this._output.space_before_token = false;
        }

        this.print_token(current_token);

        this._output.space_before_token = true;
        return;

      case OPERATOR_POSITION.preserve_newline:
        if (!isOtherColon) {
          this.allow_wrap_or_preserved_newline(current_token);
        }

        // if we just added a newline, or the current token is : and it's not a ternary statement,
        //   then we set space_before to false
        space_before = !(this._output.just_added_newline() || isOtherColon);

        this._output.space_before_token = space_before;
        this.print_token(current_token);
        this._output.space_before_token = true;
        return;
    }
  }

  if (isGeneratorAsterisk) {
    this.allow_wrap_or_preserved_newline(current_token);
    space_before = false;
    var next_token = this._tokens.peek();
    space_after = next_token && in_array$1(next_token.type, [TOKEN$2.WORD, TOKEN$2.RESERVED]);
  } else if (current_token.text === '...') {
    this.allow_wrap_or_preserved_newline(current_token);
    space_before = this._flags.last_token.type === TOKEN$2.START_BLOCK;
    space_after = false;
  } else if (in_array$1(current_token.text, ['--', '++', '!', '~']) || isUnary) {
    // unary operators (and binary +/- pretending to be unary) special cases
    if (this._flags.last_token.type === TOKEN$2.COMMA || this._flags.last_token.type === TOKEN$2.START_EXPR) {
      this.allow_wrap_or_preserved_newline(current_token);
    }

    space_before = false;
    space_after = false;

    // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
    // if there is a newline between -- or ++ and anything else we should preserve it.
    if (current_token.newlines && (current_token.text === '--' || current_token.text === '++')) {
      this.print_newline(false, true);
    }

    if (this._flags.last_token.text === ';' && is_expression(this._flags.mode)) {
      // for (;; ++i)
      //        ^^^
      space_before = true;
    }

    if (this._flags.last_token.type === TOKEN$2.RESERVED) {
      space_before = true;
    } else if (this._flags.last_token.type === TOKEN$2.END_EXPR) {
      space_before = !(this._flags.last_token.text === ']' && (current_token.text === '--' || current_token.text === '++'));
    } else if (this._flags.last_token.type === TOKEN$2.OPERATOR) {
      // a++ + ++b;
      // a - -b
      space_before = in_array$1(current_token.text, ['--', '-', '++', '+']) && in_array$1(this._flags.last_token.text, ['--', '-', '++', '+']);
      // + and - are not unary when preceeded by -- or ++ operator
      // a-- + b
      // a * +b
      // a - -b
      if (in_array$1(current_token.text, ['+', '-']) && in_array$1(this._flags.last_token.text, ['--', '++'])) {
        space_after = true;
      }
    }


    if (((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame) || this._flags.mode === MODE.Statement) &&
      (this._flags.last_token.text === '{' || this._flags.last_token.text === ';')) {
      // { foo; --i }
      // foo(); --bar;
      this.print_newline();
    }
  }

  this._output.space_before_token = this._output.space_before_token || space_before;
  this.print_token(current_token);
  this._output.space_before_token = space_after;
};

Beautifier.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {
  if (this._output.raw) {
    this._output.add_raw_token(current_token);
    if (current_token.directives && current_token.directives.preserve === 'end') {
      // If we're testing the raw output behavior, do not allow a directive to turn it off.
      this._output.raw = this._options.test_output_raw;
    }
    return;
  }

  if (current_token.directives) {
    this.print_newline(false, preserve_statement_flags);
    this.print_token(current_token);
    if (current_token.directives.preserve === 'start') {
      this._output.raw = true;
    }
    this.print_newline(false, true);
    return;
  }

  // inline block
  if (!acorn.newline.test(current_token.text) && !current_token.newlines) {
    this._output.space_before_token = true;
    this.print_token(current_token);
    this._output.space_before_token = true;
    return;
  } else {
    this.print_block_commment(current_token, preserve_statement_flags);
  }
};

Beautifier.prototype.print_block_commment = function(current_token, preserve_statement_flags) {
  var lines = split_linebreaks(current_token.text);
  var j; // iterator for this case
  var javadoc = false;
  var starless = false;
  var lastIndent = current_token.whitespace_before;
  var lastIndentLength = lastIndent.length;

  // block comment starts with a new line
  this.print_newline(false, preserve_statement_flags);

  // first line always indented
  this.print_token_line_indentation(current_token);
  this._output.add_token(lines[0]);
  this.print_newline(false, preserve_statement_flags);


  if (lines.length > 1) {
    lines = lines.slice(1);
    javadoc = all_lines_start_with(lines, '*');
    starless = each_line_matches_indent(lines, lastIndent);

    if (javadoc) {
      this._flags.alignment = 1;
    }

    for (j = 0; j < lines.length; j++) {
      if (javadoc) {
        // javadoc: reformat and re-indent
        this.print_token_line_indentation(current_token);
        this._output.add_token(ltrim(lines[j]));
      } else if (starless && lines[j]) {
        // starless: re-indent non-empty content, avoiding trim
        this.print_token_line_indentation(current_token);
        this._output.add_token(lines[j].substring(lastIndentLength));
      } else {
        // normal comments output raw
        this._output.current_line.set_indent(-1);
        this._output.add_token(lines[j]);
      }

      // for comments on their own line or  more than one line, make sure there's a new line after
      this.print_newline(false, preserve_statement_flags);
    }

    this._flags.alignment = 0;
  }
};


Beautifier.prototype.handle_comment = function(current_token, preserve_statement_flags) {
  if (current_token.newlines) {
    this.print_newline(false, preserve_statement_flags);
  } else {
    this._output.trim(true);
  }

  this._output.space_before_token = true;
  this.print_token(current_token);
  this.print_newline(false, preserve_statement_flags);
};

Beautifier.prototype.handle_dot = function(current_token) {
  if (this.start_of_statement(current_token)) ; else {
    this.handle_whitespace_and_comments(current_token, true);
  }

  if (reserved_array(this._flags.last_token, special_words)) {
    this._output.space_before_token = false;
  } else {
    // allow preserved newlines before dots in general
    // force newlines on dots after close paren when break_chained - for bar().baz()
    this.allow_wrap_or_preserved_newline(current_token,
      this._flags.last_token.text === ')' && this._options.break_chained_methods);
  }

  // Only unindent chained method dot if this dot starts a new line.
  // Otherwise the automatic extra indentation removal will handle the over indent
  if (this._options.unindent_chained_methods && this._output.just_added_newline()) {
    this.deindent();
  }

  this.print_token(current_token);
};

Beautifier.prototype.handle_unknown = function(current_token, preserve_statement_flags) {
  this.print_token(current_token);

  if (current_token.text[current_token.text.length - 1] === '\n') {
    this.print_newline(false, preserve_statement_flags);
  }
};

Beautifier.prototype.handle_eof = function(current_token) {
  // Unwind any open statements
  while (this._flags.mode === MODE.Statement) {
    this.restore_mode();
  }
  this.handle_whitespace_and_comments(current_token);
};

var Beautifier_1 = Beautifier;

var beautifier = {
	Beautifier: Beautifier_1
};

var Beautifier$1 = beautifier.Beautifier,
  Options$3 = options$2.Options;

function js_beautify(js_source_text, options) {
  var beautifier = new Beautifier$1(js_source_text, options);
  return beautifier.beautify();
}

var javascript = js_beautify;
var defaultOptions = function() {
  return new Options$3();
};
javascript.defaultOptions = defaultOptions;

var BaseOptions$1 = options$1.Options;

function Options$4(options) {
  BaseOptions$1.call(this, options, 'css');

  this.selector_separator_newline = this._get_boolean('selector_separator_newline', true);
  this.newline_between_rules = this._get_boolean('newline_between_rules', true);
  var space_around_selector_separator = this._get_boolean('space_around_selector_separator');
  this.space_around_combinator = this._get_boolean('space_around_combinator') || space_around_selector_separator;

  var brace_style_split = this._get_selection_list('brace_style', ['collapse', 'expand', 'end-expand', 'none', 'preserve-inline']);
  this.brace_style = 'collapse';
  for (var bs = 0; bs < brace_style_split.length; bs++) {
    if (brace_style_split[bs] !== 'expand') {
      // default to collapse, as only collapse|expand is implemented for now
      this.brace_style = 'collapse';
    } else {
      this.brace_style = brace_style_split[bs];
    }
  }
}
Options$4.prototype = new BaseOptions$1();



var Options_1$2 = Options$4;

var options$3 = {
	Options: Options_1$2
};

var Options$5 = options$3.Options;
var Output$2 = output.Output;
var InputScanner$3 = inputscanner.InputScanner;
var Directives$2 = directives.Directives;

var directives_core$1 = new Directives$2(/\/\*/, /\*\//);

var lineBreak = /\r\n|[\r\n]/;
var allLineBreaks = /\r\n|[\r\n]/g;

// tokenizer
var whitespaceChar = /\s/;
var whitespacePattern = /(?:\s|\n)+/g;
var block_comment_pattern = /\/\*(?:[\s\S]*?)((?:\*\/)|$)/g;
var comment_pattern = /\/\/(?:[^\n\r\u2028\u2029]*)/g;

function Beautifier$2(source_text, options) {
  this._source_text = source_text || '';
  // Allow the setting of language/file-type specific options
  // with inheritance of overall settings
  this._options = new Options$5(options);
  this._ch = null;
  this._input = null;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule
  this.NESTED_AT_RULE = {
    "@page": true,
    "@font-face": true,
    "@keyframes": true,
    // also in CONDITIONAL_GROUP_RULE below
    "@media": true,
    "@supports": true,
    "@document": true
  };
  this.CONDITIONAL_GROUP_RULE = {
    "@media": true,
    "@supports": true,
    "@document": true
  };

}

Beautifier$2.prototype.eatString = function(endChars) {
  var result = '';
  this._ch = this._input.next();
  while (this._ch) {
    result += this._ch;
    if (this._ch === "\\") {
      result += this._input.next();
    } else if (endChars.indexOf(this._ch) !== -1 || this._ch === "\n") {
      break;
    }
    this._ch = this._input.next();
  }
  return result;
};

// Skips any white space in the source text from the current position.
// When allowAtLeastOneNewLine is true, will output new lines for each
// newline character found; if the user has preserve_newlines off, only
// the first newline will be output
Beautifier$2.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {
  var result = whitespaceChar.test(this._input.peek());
  var isFirstNewLine = true;

  while (whitespaceChar.test(this._input.peek())) {
    this._ch = this._input.next();
    if (allowAtLeastOneNewLine && this._ch === '\n') {
      if (this._options.preserve_newlines || isFirstNewLine) {
        isFirstNewLine = false;
        this._output.add_new_line(true);
      }
    }
  }
  return result;
};

// Nested pseudo-class if we are insideRule
// and the next special character found opens
// a new block
Beautifier$2.prototype.foundNestedPseudoClass = function() {
  var openParen = 0;
  var i = 1;
  var ch = this._input.peek(i);
  while (ch) {
    if (ch === "{") {
      return true;
    } else if (ch === '(') {
      // pseudoclasses can contain ()
      openParen += 1;
    } else if (ch === ')') {
      if (openParen === 0) {
        return false;
      }
      openParen -= 1;
    } else if (ch === ";" || ch === "}") {
      return false;
    }
    i++;
    ch = this._input.peek(i);
  }
  return false;
};

Beautifier$2.prototype.print_string = function(output_string) {
  this._output.set_indent(this._indentLevel);
  this._output.non_breaking_space = true;
  this._output.add_token(output_string);
};

Beautifier$2.prototype.preserveSingleSpace = function(isAfterSpace) {
  if (isAfterSpace) {
    this._output.space_before_token = true;
  }
};

Beautifier$2.prototype.indent = function() {
  this._indentLevel++;
};

Beautifier$2.prototype.outdent = function() {
  if (this._indentLevel > 0) {
    this._indentLevel--;
  }
};

/*_____________________--------------------_____________________*/

Beautifier$2.prototype.beautify = function() {
  if (this._options.disabled) {
    return this._source_text;
  }

  var source_text = this._source_text;
  var eol = this._options.eol;
  if (eol === 'auto') {
    eol = '\n';
    if (source_text && lineBreak.test(source_text || '')) {
      eol = source_text.match(lineBreak)[0];
    }
  }


  // HACK: newline parsing inconsistent. This brute force normalizes the this._input.
  source_text = source_text.replace(allLineBreaks, '\n');

  // reset
  var baseIndentString = source_text.match(/^[\t ]*/)[0];

  this._output = new Output$2(this._options, baseIndentString);
  this._input = new InputScanner$3(source_text);
  this._indentLevel = 0;
  this._nestedLevel = 0;

  this._ch = null;
  var parenLevel = 0;

  var insideRule = false;
  // This is the value side of a property value pair (blue in the following ex)
  // label { content: blue }
  var insidePropertyValue = false;
  var enteringConditionalGroup = false;
  var insideAtExtend = false;
  var insideAtImport = false;
  var topCharacter = this._ch;
  var whitespace;
  var isAfterSpace;
  var previous_ch;

  while (true) {
    whitespace = this._input.read(whitespacePattern);
    isAfterSpace = whitespace !== '';
    previous_ch = topCharacter;
    this._ch = this._input.next();
    if (this._ch === '\\' && this._input.hasNext()) {
      this._ch += this._input.next();
    }
    topCharacter = this._ch;

    if (!this._ch) {
      break;
    } else if (this._ch === '/' && this._input.peek() === '*') {
      // /* css comment */
      // Always start block comments on a new line.
      // This handles scenarios where a block comment immediately
      // follows a property definition on the same line or where
      // minified code is being beautified.
      this._output.add_new_line();
      this._input.back();

      var comment = this._input.read(block_comment_pattern);

      // Handle ignore directive
      var directives = directives_core$1.get_directives(comment);
      if (directives && directives.ignore === 'start') {
        comment += directives_core$1.readIgnored(this._input);
      }

      this.print_string(comment);

      // Ensures any new lines following the comment are preserved
      this.eatWhitespace(true);

      // Block comments are followed by a new line so they don't
      // share a line with other properties
      this._output.add_new_line();
    } else if (this._ch === '/' && this._input.peek() === '/') {
      // // single line comment
      // Preserves the space before a comment
      // on the same line as a rule
      this._output.space_before_token = true;
      this._input.back();
      this.print_string(this._input.read(comment_pattern));

      // Ensures any new lines following the comment are preserved
      this.eatWhitespace(true);
    } else if (this._ch === '@') {
      this.preserveSingleSpace(isAfterSpace);

      // deal with less propery mixins @{...}
      if (this._input.peek() === '{') {
        this.print_string(this._ch + this.eatString('}'));
      } else {
        this.print_string(this._ch);

        // strip trailing space, if present, for hash property checks
        var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);

        if (variableOrRule.match(/[ :]$/)) {
          // we have a variable or pseudo-class, add it and insert one space before continuing
          variableOrRule = this.eatString(": ").replace(/\s$/, '');
          this.print_string(variableOrRule);
          this._output.space_before_token = true;
        }

        variableOrRule = variableOrRule.replace(/\s$/, '');

        if (variableOrRule === 'extend') {
          insideAtExtend = true;
        } else if (variableOrRule === 'import') {
          insideAtImport = true;
        }

        // might be a nesting at-rule
        if (variableOrRule in this.NESTED_AT_RULE) {
          this._nestedLevel += 1;
          if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
            enteringConditionalGroup = true;
          }
          // might be less variable
        } else if (!insideRule && parenLevel === 0 && variableOrRule.indexOf(':') !== -1) {
          insidePropertyValue = true;
          this.indent();
        }
      }
    } else if (this._ch === '#' && this._input.peek() === '{') {
      this.preserveSingleSpace(isAfterSpace);
      this.print_string(this._ch + this.eatString('}'));
    } else if (this._ch === '{') {
      if (insidePropertyValue) {
        insidePropertyValue = false;
        this.outdent();
      }

      // when entering conditional groups, only rulesets are allowed
      if (enteringConditionalGroup) {
        enteringConditionalGroup = false;
        insideRule = (this._indentLevel >= this._nestedLevel);
      } else {
        // otherwise, declarations are also allowed
        insideRule = (this._indentLevel >= this._nestedLevel - 1);
      }
      if (this._options.newline_between_rules && insideRule) {
        if (this._output.previous_line && this._output.previous_line.item(-1) !== '{') {
          this._output.ensure_empty_line_above('/', ',');
        }
      }

      this._output.space_before_token = true;

      // The difference in print_string and indent order is necessary to indent the '{' correctly
      if (this._options.brace_style === 'expand') {
        this._output.add_new_line();
        this.print_string(this._ch);
        this.indent();
        this._output.set_indent(this._indentLevel);
      } else {
        this.indent();
        this.print_string(this._ch);
      }

      this.eatWhitespace(true);
      this._output.add_new_line();
    } else if (this._ch === '}') {
      this.outdent();
      this._output.add_new_line();
      if (previous_ch === '{') {
        this._output.trim(true);
      }
      insideAtImport = false;
      insideAtExtend = false;
      if (insidePropertyValue) {
        this.outdent();
        insidePropertyValue = false;
      }
      this.print_string(this._ch);
      insideRule = false;
      if (this._nestedLevel) {
        this._nestedLevel--;
      }

      this.eatWhitespace(true);
      this._output.add_new_line();

      if (this._options.newline_between_rules && !this._output.just_added_blankline()) {
        if (this._input.peek() !== '}') {
          this._output.add_new_line(true);
        }
      }
    } else if (this._ch === ":") {
      if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack("&") || this.foundNestedPseudoClass()) && !this._input.lookBack("(") && !insideAtExtend && parenLevel === 0) {
        // 'property: value' delimiter
        // which could be in a conditional group query
        this.print_string(':');
        if (!insidePropertyValue) {
          insidePropertyValue = true;
          this._output.space_before_token = true;
          this.eatWhitespace(true);
          this.indent();
        }
      } else {
        // sass/less parent reference don't use a space
        // sass nested pseudo-class don't use a space

        // preserve space before pseudoclasses/pseudoelements, as it means "in any child"
        if (this._input.lookBack(" ")) {
          this._output.space_before_token = true;
        }
        if (this._input.peek() === ":") {
          // pseudo-element
          this._ch = this._input.next();
          this.print_string("::");
        } else {
          // pseudo-class
          this.print_string(':');
        }
      }
    } else if (this._ch === '"' || this._ch === '\'') {
      this.preserveSingleSpace(isAfterSpace);
      this.print_string(this._ch + this.eatString(this._ch));
      this.eatWhitespace(true);
    } else if (this._ch === ';') {
      if (parenLevel === 0) {
        if (insidePropertyValue) {
          this.outdent();
          insidePropertyValue = false;
        }
        insideAtExtend = false;
        insideAtImport = false;
        this.print_string(this._ch);
        this.eatWhitespace(true);

        // This maintains single line comments on the same
        // line. Block comments are also affected, but
        // a new line is always output before one inside
        // that section
        if (this._input.peek() !== '/') {
          this._output.add_new_line();
        }
      } else {
        this.print_string(this._ch);
        this.eatWhitespace(true);
        this._output.space_before_token = true;
      }
    } else if (this._ch === '(') { // may be a url
      if (this._input.lookBack("url")) {
        this.print_string(this._ch);
        this.eatWhitespace();
        parenLevel++;
        this.indent();
        this._ch = this._input.next();
        if (this._ch === ')' || this._ch === '"' || this._ch === '\'') {
          this._input.back();
        } else if (this._ch) {
          this.print_string(this._ch + this.eatString(')'));
          if (parenLevel) {
            parenLevel--;
            this.outdent();
          }
        }
      } else {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch);
        this.eatWhitespace();
        parenLevel++;
        this.indent();
      }
    } else if (this._ch === ')') {
      if (parenLevel) {
        parenLevel--;
        this.outdent();
      }
      this.print_string(this._ch);
    } else if (this._ch === ',') {
      this.print_string(this._ch);
      this.eatWhitespace(true);
      if (this._options.selector_separator_newline && !insidePropertyValue && parenLevel === 0 && !insideAtImport) {
        this._output.add_new_line();
      } else {
        this._output.space_before_token = true;
      }
    } else if ((this._ch === '>' || this._ch === '+' || this._ch === '~') && !insidePropertyValue && parenLevel === 0) {
      //handle combinator spacing
      if (this._options.space_around_combinator) {
        this._output.space_before_token = true;
        this.print_string(this._ch);
        this._output.space_before_token = true;
      } else {
        this.print_string(this._ch);
        this.eatWhitespace();
        // squash extra whitespace
        if (this._ch && whitespaceChar.test(this._ch)) {
          this._ch = '';
        }
      }
    } else if (this._ch === ']') {
      this.print_string(this._ch);
    } else if (this._ch === '[') {
      this.preserveSingleSpace(isAfterSpace);
      this.print_string(this._ch);
    } else if (this._ch === '=') { // no whitespace before or after
      this.eatWhitespace();
      this.print_string('=');
      if (whitespaceChar.test(this._ch)) {
        this._ch = '';
      }
    } else if (this._ch === '!' && !this._input.lookBack("\\")) { // !important
      this.print_string(' ');
      this.print_string(this._ch);
    } else {
      this.preserveSingleSpace(isAfterSpace);
      this.print_string(this._ch);
    }
  }

  var sweetCode = this._output.get_code(eol);

  return sweetCode;
};

var Beautifier_1$1 = Beautifier$2;

var beautifier$1 = {
	Beautifier: Beautifier_1$1
};

var Beautifier$3 = beautifier$1.Beautifier,
  Options$6 = options$3.Options;

function css_beautify(source_text, options) {
  var beautifier = new Beautifier$3(source_text, options);
  return beautifier.beautify();
}

var css = css_beautify;
var defaultOptions$1 = function() {
  return new Options$6();
};
css.defaultOptions = defaultOptions$1;

var BaseOptions$2 = options$1.Options;

function Options$7(options) {
  BaseOptions$2.call(this, options, 'html');
  if (this.templating.length === 1 && this.templating[0] === 'auto') {
    this.templating = ['django', 'erb', 'handlebars', 'php'];
  }

  this.indent_inner_html = this._get_boolean('indent_inner_html');
  this.indent_body_inner_html = this._get_boolean('indent_body_inner_html', true);
  this.indent_head_inner_html = this._get_boolean('indent_head_inner_html', true);

  this.indent_handlebars = this._get_boolean('indent_handlebars', true);
  this.wrap_attributes = this._get_selection('wrap_attributes',
    ['auto', 'force', 'force-aligned', 'force-expand-multiline', 'aligned-multiple', 'preserve', 'preserve-aligned']);
  this.wrap_attributes_indent_size = this._get_number('wrap_attributes_indent_size', this.indent_size);
  this.extra_liners = this._get_array('extra_liners', ['head', 'body', '/html']);

  // Block vs inline elements
  // https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements
  // https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements
  // https://www.w3.org/TR/html5/dom.html#phrasing-content
  this.inline = this._get_array('inline', [
    'a', 'abbr', 'area', 'audio', 'b', 'bdi', 'bdo', 'br', 'button', 'canvas', 'cite',
    'code', 'data', 'datalist', 'del', 'dfn', 'em', 'embed', 'i', 'iframe', 'img',
    'input', 'ins', 'kbd', 'keygen', 'label', 'map', 'mark', 'math', 'meter', 'noscript',
    'object', 'output', 'progress', 'q', 'ruby', 's', 'samp', /* 'script', */ 'select', 'small',
    'span', 'strong', 'sub', 'sup', 'svg', 'template', 'textarea', 'time', 'u', 'var',
    'video', 'wbr', 'text',
    // obsolete inline tags
    'acronym', 'big', 'strike', 'tt'
  ]);
  this.void_elements = this._get_array('void_elements', [
    // HTLM void elements - aka self-closing tags - aka singletons
    // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
    'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',
    'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr',
    // NOTE: Optional tags are too complex for a simple list
    // they are hard coded in _do_optional_end_element

    // Doctype and xml elements
    '!doctype', '?xml',

    // obsolete tags
    // basefont: https://www.computerhope.com/jargon/h/html-basefont-tag.htm
    // isndex: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/isindex
    'basefont', 'isindex'
  ]);
  this.unformatted = this._get_array('unformatted', []);
  this.content_unformatted = this._get_array('content_unformatted', [
    'pre', 'textarea'
  ]);
  this.unformatted_content_delimiter = this._get_characters('unformatted_content_delimiter');
  this.indent_scripts = this._get_selection('indent_scripts', ['normal', 'keep', 'separate']);

}
Options$7.prototype = new BaseOptions$2();



var Options_1$3 = Options$7;

var options$4 = {
	Options: Options_1$3
};

var BaseTokenizer$1 = tokenizer.Tokenizer;
var BASETOKEN$1 = tokenizer.TOKEN;
var Directives$3 = directives.Directives;
var TemplatablePattern$2 = templatablepattern.TemplatablePattern;
var Pattern$4 = pattern.Pattern;

var TOKEN$3 = {
  TAG_OPEN: 'TK_TAG_OPEN',
  TAG_CLOSE: 'TK_TAG_CLOSE',
  ATTRIBUTE: 'TK_ATTRIBUTE',
  EQUALS: 'TK_EQUALS',
  VALUE: 'TK_VALUE',
  COMMENT: 'TK_COMMENT',
  TEXT: 'TK_TEXT',
  UNKNOWN: 'TK_UNKNOWN',
  START: BASETOKEN$1.START,
  RAW: BASETOKEN$1.RAW,
  EOF: BASETOKEN$1.EOF
};

var directives_core$2 = new Directives$3(/<\!--/, /-->/);

var Tokenizer$3 = function(input_string, options) {
  BaseTokenizer$1.call(this, input_string, options);
  this._current_tag_name = '';

  // Words end at whitespace or when a tag starts
  // if we are indenting handlebars, they are considered tags
  var templatable_reader = new TemplatablePattern$2(this._input).read_options(this._options);
  var pattern_reader = new Pattern$4(this._input);

  this.__patterns = {
    word: templatable_reader.until(/[\n\r\t <]/),
    single_quote: templatable_reader.until_after(/'/),
    double_quote: templatable_reader.until_after(/"/),
    attribute: templatable_reader.until(/[\n\r\t =>]|\/>/),
    element_name: templatable_reader.until(/[\n\r\t >\/]/),

    handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),
    handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),
    handlebars_open: pattern_reader.until(/[\n\r\t }]/),
    handlebars_raw_close: pattern_reader.until(/}}/),
    comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),
    cdata: pattern_reader.starting_with(/<!\[CDATA\[/).until_after(/]]>/),
    // https://en.wikipedia.org/wiki/Conditional_comment
    conditional_comment: pattern_reader.starting_with(/<!\[/).until_after(/]>/),
    processing: pattern_reader.starting_with(/<\?/).until_after(/\?>/)
  };

  if (this._options.indent_handlebars) {
    this.__patterns.word = this.__patterns.word.exclude('handlebars');
  }

  this._unformatted_content_delimiter = null;

  if (this._options.unformatted_content_delimiter) {
    var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);
    this.__patterns.unformatted_content_delimiter =
      pattern_reader.matching(literal_regexp)
      .until_after(literal_regexp);
  }
};
Tokenizer$3.prototype = new BaseTokenizer$1();

Tokenizer$3.prototype._is_comment = function(current_token) { // jshint unused:false
  return false; //current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.UNKNOWN;
};

Tokenizer$3.prototype._is_opening = function(current_token) {
  return current_token.type === TOKEN$3.TAG_OPEN;
};

Tokenizer$3.prototype._is_closing = function(current_token, open_token) {
  return current_token.type === TOKEN$3.TAG_CLOSE &&
    (open_token && (
      ((current_token.text === '>' || current_token.text === '/>') && open_token.text[0] === '<') ||
      (current_token.text === '}}' && open_token.text[0] === '{' && open_token.text[1] === '{')));
};

Tokenizer$3.prototype._reset = function() {
  this._current_tag_name = '';
};

Tokenizer$3.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
  var token = null;
  this._readWhitespace();
  var c = this._input.peek();

  if (c === null) {
    return this._create_token(TOKEN$3.EOF, '');
  }

  token = token || this._read_open_handlebars(c, open_token);
  token = token || this._read_attribute(c, previous_token, open_token);
  token = token || this._read_close(c, open_token);
  token = token || this._read_raw_content(c, previous_token, open_token);
  token = token || this._read_content_word(c);
  token = token || this._read_comment_or_cdata(c);
  token = token || this._read_processing(c);
  token = token || this._read_open(c, open_token);
  token = token || this._create_token(TOKEN$3.UNKNOWN, this._input.next());

  return token;
};

Tokenizer$3.prototype._read_comment_or_cdata = function(c) { // jshint unused:false
  var token = null;
  var resulting_string = null;
  var directives = null;

  if (c === '<') {
    var peek1 = this._input.peek(1);
    // We treat all comments as literals, even more than preformatted tags
    // we only look for the appropriate closing marker
    if (peek1 === '!') {
      resulting_string = this.__patterns.comment.read();

      // only process directive on html comments
      if (resulting_string) {
        directives = directives_core$2.get_directives(resulting_string);
        if (directives && directives.ignore === 'start') {
          resulting_string += directives_core$2.readIgnored(this._input);
        }
      } else {
        resulting_string = this.__patterns.cdata.read();
      }
    }

    if (resulting_string) {
      token = this._create_token(TOKEN$3.COMMENT, resulting_string);
      token.directives = directives;
    }
  }

  return token;
};

Tokenizer$3.prototype._read_processing = function(c) { // jshint unused:false
  var token = null;
  var resulting_string = null;
  var directives = null;

  if (c === '<') {
    var peek1 = this._input.peek(1);
    if (peek1 === '!' || peek1 === '?') {
      resulting_string = this.__patterns.conditional_comment.read();
      resulting_string = resulting_string || this.__patterns.processing.read();
    }

    if (resulting_string) {
      token = this._create_token(TOKEN$3.COMMENT, resulting_string);
      token.directives = directives;
    }
  }

  return token;
};

Tokenizer$3.prototype._read_open = function(c, open_token) {
  var resulting_string = null;
  var token = null;
  if (!open_token) {
    if (c === '<') {

      resulting_string = this._input.next();
      if (this._input.peek() === '/') {
        resulting_string += this._input.next();
      }
      resulting_string += this.__patterns.element_name.read();
      token = this._create_token(TOKEN$3.TAG_OPEN, resulting_string);
    }
  }
  return token;
};

Tokenizer$3.prototype._read_open_handlebars = function(c, open_token) {
  var resulting_string = null;
  var token = null;
  if (!open_token) {
    if (this._options.indent_handlebars && c === '{' && this._input.peek(1) === '{') {
      if (this._input.peek(2) === '!') {
        resulting_string = this.__patterns.handlebars_comment.read();
        resulting_string = resulting_string || this.__patterns.handlebars.read();
        token = this._create_token(TOKEN$3.COMMENT, resulting_string);
      } else {
        resulting_string = this.__patterns.handlebars_open.read();
        token = this._create_token(TOKEN$3.TAG_OPEN, resulting_string);
      }
    }
  }
  return token;
};


Tokenizer$3.prototype._read_close = function(c, open_token) {
  var resulting_string = null;
  var token = null;
  if (open_token) {
    if (open_token.text[0] === '<' && (c === '>' || (c === '/' && this._input.peek(1) === '>'))) {
      resulting_string = this._input.next();
      if (c === '/') { //  for close tag "/>"
        resulting_string += this._input.next();
      }
      token = this._create_token(TOKEN$3.TAG_CLOSE, resulting_string);
    } else if (open_token.text[0] === '{' && c === '}' && this._input.peek(1) === '}') {
      this._input.next();
      this._input.next();
      token = this._create_token(TOKEN$3.TAG_CLOSE, '}}');
    }
  }

  return token;
};

Tokenizer$3.prototype._read_attribute = function(c, previous_token, open_token) {
  var token = null;
  var resulting_string = '';
  if (open_token && open_token.text[0] === '<') {

    if (c === '=') {
      token = this._create_token(TOKEN$3.EQUALS, this._input.next());
    } else if (c === '"' || c === "'") {
      var content = this._input.next();
      if (c === '"') {
        content += this.__patterns.double_quote.read();
      } else {
        content += this.__patterns.single_quote.read();
      }
      token = this._create_token(TOKEN$3.VALUE, content);
    } else {
      resulting_string = this.__patterns.attribute.read();

      if (resulting_string) {
        if (previous_token.type === TOKEN$3.EQUALS) {
          token = this._create_token(TOKEN$3.VALUE, resulting_string);
        } else {
          token = this._create_token(TOKEN$3.ATTRIBUTE, resulting_string);
        }
      }
    }
  }
  return token;
};

Tokenizer$3.prototype._is_content_unformatted = function(tag_name) {
  // void_elements have no content and so cannot have unformatted content
  // script and style tags should always be read as unformatted content
  // finally content_unformatted and unformatted element contents are unformatted
  return this._options.void_elements.indexOf(tag_name) === -1 &&
    (this._options.content_unformatted.indexOf(tag_name) !== -1 ||
      this._options.unformatted.indexOf(tag_name) !== -1);
};


Tokenizer$3.prototype._read_raw_content = function(c, previous_token, open_token) { // jshint unused:false
  var resulting_string = '';
  if (open_token && open_token.text[0] === '{') {
    resulting_string = this.__patterns.handlebars_raw_close.read();
  } else if (previous_token.type === TOKEN$3.TAG_CLOSE &&
    previous_token.opened.text[0] === '<' && previous_token.text[0] !== '/') {
    // ^^ empty tag has no content 
    var tag_name = previous_token.opened.text.substr(1).toLowerCase();
    if (tag_name === 'script' || tag_name === 'style') {
      // Script and style tags are allowed to have comments wrapping their content
      // or just have regular content.
      var token = this._read_comment_or_cdata(c);
      if (token) {
        token.type = TOKEN$3.TEXT;
        return token;
      }
      resulting_string = this._input.readUntil(new RegExp('</' + tag_name + '[\\n\\r\\t ]*?>', 'ig'));
    } else if (this._is_content_unformatted(tag_name)) {

      resulting_string = this._input.readUntil(new RegExp('</' + tag_name + '[\\n\\r\\t ]*?>', 'ig'));
    }
  }

  if (resulting_string) {
    return this._create_token(TOKEN$3.TEXT, resulting_string);
  }

  return null;
};

Tokenizer$3.prototype._read_content_word = function(c) {
  var resulting_string = '';
  if (this._options.unformatted_content_delimiter) {
    if (c === this._options.unformatted_content_delimiter[0]) {
      resulting_string = this.__patterns.unformatted_content_delimiter.read();
    }
  }

  if (!resulting_string) {
    resulting_string = this.__patterns.word.read();
  }
  if (resulting_string) {
    return this._create_token(TOKEN$3.TEXT, resulting_string);
  }
};

var Tokenizer_1$2 = Tokenizer$3;
var TOKEN_1$2 = TOKEN$3;

var tokenizer$2 = {
	Tokenizer: Tokenizer_1$2,
	TOKEN: TOKEN_1$2
};

var Options$8 = options$4.Options;
var Output$3 = output.Output;
var Tokenizer$4 = tokenizer$2.Tokenizer;
var TOKEN$4 = tokenizer$2.TOKEN;

var lineBreak$1 = /\r\n|[\r\n]/;
var allLineBreaks$1 = /\r\n|[\r\n]/g;

var Printer = function(options, base_indent_string) { //handles input/output and some other printing functions

  this.indent_level = 0;
  this.alignment_size = 0;
  this.max_preserve_newlines = options.max_preserve_newlines;
  this.preserve_newlines = options.preserve_newlines;

  this._output = new Output$3(options, base_indent_string);

};

Printer.prototype.current_line_has_match = function(pattern) {
  return this._output.current_line.has_match(pattern);
};

Printer.prototype.set_space_before_token = function(value, non_breaking) {
  this._output.space_before_token = value;
  this._output.non_breaking_space = non_breaking;
};

Printer.prototype.set_wrap_point = function() {
  this._output.set_indent(this.indent_level, this.alignment_size);
  this._output.set_wrap_point();
};


Printer.prototype.add_raw_token = function(token) {
  this._output.add_raw_token(token);
};

Printer.prototype.print_preserved_newlines = function(raw_token) {
  var newlines = 0;
  if (raw_token.type !== TOKEN$4.TEXT && raw_token.previous.type !== TOKEN$4.TEXT) {
    newlines = raw_token.newlines ? 1 : 0;
  }

  if (this.preserve_newlines) {
    newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;
  }
  for (var n = 0; n < newlines; n++) {
    this.print_newline(n > 0);
  }

  return newlines !== 0;
};

Printer.prototype.traverse_whitespace = function(raw_token) {
  if (raw_token.whitespace_before || raw_token.newlines) {
    if (!this.print_preserved_newlines(raw_token)) {
      this._output.space_before_token = true;
    }
    return true;
  }
  return false;
};

Printer.prototype.previous_token_wrapped = function() {
  return this._output.previous_token_wrapped;
};

Printer.prototype.print_newline = function(force) {
  this._output.add_new_line(force);
};

Printer.prototype.print_token = function(token) {
  if (token.text) {
    this._output.set_indent(this.indent_level, this.alignment_size);
    this._output.add_token(token.text);
  }
};

Printer.prototype.indent = function() {
  this.indent_level++;
};

Printer.prototype.get_full_indent = function(level) {
  level = this.indent_level + (level || 0);
  if (level < 1) {
    return '';
  }

  return this._output.get_indent_string(level);
};

var get_type_attribute = function(start_token) {
  var result = null;
  var raw_token = start_token.next;

  // Search attributes for a type attribute
  while (raw_token.type !== TOKEN$4.EOF && start_token.closed !== raw_token) {
    if (raw_token.type === TOKEN$4.ATTRIBUTE && raw_token.text === 'type') {
      if (raw_token.next && raw_token.next.type === TOKEN$4.EQUALS &&
        raw_token.next.next && raw_token.next.next.type === TOKEN$4.VALUE) {
        result = raw_token.next.next.text;
      }
      break;
    }
    raw_token = raw_token.next;
  }

  return result;
};

var get_custom_beautifier_name = function(tag_check, raw_token) {
  var typeAttribute = null;
  var result = null;

  if (!raw_token.closed) {
    return null;
  }

  if (tag_check === 'script') {
    typeAttribute = 'text/javascript';
  } else if (tag_check === 'style') {
    typeAttribute = 'text/css';
  }

  typeAttribute = get_type_attribute(raw_token) || typeAttribute;

  // For script and style tags that have a type attribute, only enable custom beautifiers for matching values
  // For those without a type attribute use default;
  if (typeAttribute.search('text/css') > -1) {
    result = 'css';
  } else if (typeAttribute.search(/module|((text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect))/) > -1) {
    result = 'javascript';
  } else if (typeAttribute.search(/(text|application|dojo)\/(x-)?(html)/) > -1) {
    result = 'html';
  } else if (typeAttribute.search(/test\/null/) > -1) {
    // Test only mime-type for testing the beautifier when null is passed as beautifing function
    result = 'null';
  }

  return result;
};

function in_array$2(what, arr) {
  return arr.indexOf(what) !== -1;
}

function TagFrame(parent, parser_token, indent_level) {
  this.parent = parent || null;
  this.tag = parser_token ? parser_token.tag_name : '';
  this.indent_level = indent_level || 0;
  this.parser_token = parser_token || null;
}

function TagStack(printer) {
  this._printer = printer;
  this._current_frame = null;
}

TagStack.prototype.get_parser_token = function() {
  return this._current_frame ? this._current_frame.parser_token : null;
};

TagStack.prototype.record_tag = function(parser_token) { //function to record a tag and its parent in this.tags Object
  var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);
  this._current_frame = new_frame;
};

TagStack.prototype._try_pop_frame = function(frame) { //function to retrieve the opening tag to the corresponding closer
  var parser_token = null;

  if (frame) {
    parser_token = frame.parser_token;
    this._printer.indent_level = frame.indent_level;
    this._current_frame = frame.parent;
  }

  return parser_token;
};

TagStack.prototype._get_frame = function(tag_list, stop_list) { //function to retrieve the opening tag to the corresponding closer
  var frame = this._current_frame;

  while (frame) { //till we reach '' (the initial value);
    if (tag_list.indexOf(frame.tag) !== -1) { //if this is it use it
      break;
    } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {
      frame = null;
      break;
    }
    frame = frame.parent;
  }

  return frame;
};

TagStack.prototype.try_pop = function(tag, stop_list) { //function to retrieve the opening tag to the corresponding closer
  var frame = this._get_frame([tag], stop_list);
  return this._try_pop_frame(frame);
};

TagStack.prototype.indent_to_tag = function(tag_list) {
  var frame = this._get_frame(tag_list);
  if (frame) {
    this._printer.indent_level = frame.indent_level;
  }
};

function Beautifier$4(source_text, options, js_beautify, css_beautify) {
  //Wrapper function to invoke all the necessary constructors and deal with the output.
  this._source_text = source_text || '';
  options = options || {};
  this._js_beautify = js_beautify;
  this._css_beautify = css_beautify;
  this._tag_stack = null;

  // Allow the setting of language/file-type specific options
  // with inheritance of overall settings
  var optionHtml = new Options$8(options, 'html');

  this._options = optionHtml;

  this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, 'force'.length) === 'force';
  this._is_wrap_attributes_force_expand_multiline = (this._options.wrap_attributes === 'force-expand-multiline');
  this._is_wrap_attributes_force_aligned = (this._options.wrap_attributes === 'force-aligned');
  this._is_wrap_attributes_aligned_multiple = (this._options.wrap_attributes === 'aligned-multiple');
  this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, 'preserve'.length) === 'preserve';
  this._is_wrap_attributes_preserve_aligned = (this._options.wrap_attributes === 'preserve-aligned');
}

Beautifier$4.prototype.beautify = function() {

  // if disabled, return the input unchanged.
  if (this._options.disabled) {
    return this._source_text;
  }

  var source_text = this._source_text;
  var eol = this._options.eol;
  if (this._options.eol === 'auto') {
    eol = '\n';
    if (source_text && lineBreak$1.test(source_text)) {
      eol = source_text.match(lineBreak$1)[0];
    }
  }

  // HACK: newline parsing inconsistent. This brute force normalizes the input.
  source_text = source_text.replace(allLineBreaks$1, '\n');

  var baseIndentString = source_text.match(/^[\t ]*/)[0];

  var last_token = {
    text: '',
    type: ''
  };

  var last_tag_token = new TagOpenParserToken();

  var printer = new Printer(this._options, baseIndentString);
  var tokens = new Tokenizer$4(source_text, this._options).tokenize();

  this._tag_stack = new TagStack(printer);

  var parser_token = null;
  var raw_token = tokens.next();
  while (raw_token.type !== TOKEN$4.EOF) {

    if (raw_token.type === TOKEN$4.TAG_OPEN || raw_token.type === TOKEN$4.COMMENT) {
      parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token);
      last_tag_token = parser_token;
    } else if ((raw_token.type === TOKEN$4.ATTRIBUTE || raw_token.type === TOKEN$4.EQUALS || raw_token.type === TOKEN$4.VALUE) ||
      (raw_token.type === TOKEN$4.TEXT && !last_tag_token.tag_complete)) {
      parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, tokens);
    } else if (raw_token.type === TOKEN$4.TAG_CLOSE) {
      parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);
    } else if (raw_token.type === TOKEN$4.TEXT) {
      parser_token = this._handle_text(printer, raw_token, last_tag_token);
    } else {
      // This should never happen, but if it does. Print the raw token
      printer.add_raw_token(raw_token);
    }

    last_token = parser_token;

    raw_token = tokens.next();
  }
  var sweet_code = printer._output.get_code(eol);

  return sweet_code;
};

Beautifier$4.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {
  var parser_token = {
    text: raw_token.text,
    type: raw_token.type
  };
  printer.alignment_size = 0;
  last_tag_token.tag_complete = true;

  printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);
  if (last_tag_token.is_unformatted) {
    printer.add_raw_token(raw_token);
  } else {
    if (last_tag_token.tag_start_char === '<') {
      printer.set_space_before_token(raw_token.text[0] === '/', true); // space before />, no space before >
      if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {
        printer.print_newline(false);
      }
    }
    printer.print_token(raw_token);

  }

  if (last_tag_token.indent_content &&
    !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
    printer.indent();

    // only indent once per opened tag
    last_tag_token.indent_content = false;
  }

  if (!last_tag_token.is_inline_element &&
    !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
    printer.set_wrap_point();
  }

  return parser_token;
};

Beautifier$4.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, tokens) {
  var wrapped = last_tag_token.has_wrapped_attrs;
  var parser_token = {
    text: raw_token.text,
    type: raw_token.type
  };

  printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);
  if (last_tag_token.is_unformatted) {
    printer.add_raw_token(raw_token);
  } else if (last_tag_token.tag_start_char === '{' && raw_token.type === TOKEN$4.TEXT) {
    // For the insides of handlebars allow newlines or a single space between open and contents
    if (printer.print_preserved_newlines(raw_token)) {
      raw_token.newlines = 0;
      printer.add_raw_token(raw_token);
    } else {
      printer.print_token(raw_token);
    }
  } else {
    if (raw_token.type === TOKEN$4.ATTRIBUTE) {
      printer.set_space_before_token(true);
      last_tag_token.attr_count += 1;
    } else if (raw_token.type === TOKEN$4.EQUALS) { //no space before =
      printer.set_space_before_token(false);
    } else if (raw_token.type === TOKEN$4.VALUE && raw_token.previous.type === TOKEN$4.EQUALS) { //no space before value
      printer.set_space_before_token(false);
    }

    if (raw_token.type === TOKEN$4.ATTRIBUTE && last_tag_token.tag_start_char === '<') {
      if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {
        printer.traverse_whitespace(raw_token);
        wrapped = wrapped || raw_token.newlines !== 0;
      }


      if (this._is_wrap_attributes_force) {
        var force_attr_wrap = last_tag_token.attr_count > 1;
        if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.attr_count === 1) {
          var is_only_attribute = true;
          var peek_index = 0;
          var peek_token;
          do {
            peek_token = tokens.peek(peek_index);
            if (peek_token.type === TOKEN$4.ATTRIBUTE) {
              is_only_attribute = false;
              break;
            }
            peek_index += 1;
          } while (peek_index < 4 && peek_token.type !== TOKEN$4.EOF && peek_token.type !== TOKEN$4.TAG_CLOSE);

          force_attr_wrap = !is_only_attribute;
        }

        if (force_attr_wrap) {
          printer.print_newline(false);
          wrapped = true;
        }
      }
    }
    printer.print_token(raw_token);
    wrapped = wrapped || printer.previous_token_wrapped();
    last_tag_token.has_wrapped_attrs = wrapped;
  }
  return parser_token;
};

Beautifier$4.prototype._handle_text = function(printer, raw_token, last_tag_token) {
  var parser_token = {
    text: raw_token.text,
    type: 'TK_CONTENT'
  };
  if (last_tag_token.custom_beautifier_name) { //check if we need to format javascript
    this._print_custom_beatifier_text(printer, raw_token, last_tag_token);
  } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {
    printer.add_raw_token(raw_token);
  } else {
    printer.traverse_whitespace(raw_token);
    printer.print_token(raw_token);
  }
  return parser_token;
};

Beautifier$4.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {
  var local = this;
  if (raw_token.text !== '') {

    var text = raw_token.text,
      _beautifier,
      script_indent_level = 1,
      pre = '',
      post = '';
    if (last_tag_token.custom_beautifier_name === 'javascript' && typeof this._js_beautify === 'function') {
      _beautifier = this._js_beautify;
    } else if (last_tag_token.custom_beautifier_name === 'css' && typeof this._css_beautify === 'function') {
      _beautifier = this._css_beautify;
    } else if (last_tag_token.custom_beautifier_name === 'html') {
      _beautifier = function(html_source, options) {
        var beautifier = new Beautifier$4(html_source, options, local._js_beautify, local._css_beautify);
        return beautifier.beautify();
      };
    }

    if (this._options.indent_scripts === "keep") {
      script_indent_level = 0;
    } else if (this._options.indent_scripts === "separate") {
      script_indent_level = -printer.indent_level;
    }

    var indentation = printer.get_full_indent(script_indent_level);

    // if there is at least one empty line at the end of this text, strip it
    // we'll be adding one back after the text but before the containing tag.
    text = text.replace(/\n[ \t]*$/, '');

    // Handle the case where content is wrapped in a comment or cdata.
    if (last_tag_token.custom_beautifier_name !== 'html' &&
      text[0] === '<' && text.match(/^(<!--|<!\[CDATA\[)/)) {
      var matched = /^(<!--[^\n]*|<!\[CDATA\[)(\n?)([ \t\n]*)([\s\S]*)(-->|]]>)$/.exec(text);

      // if we start to wrap but don't finish, print raw
      if (!matched) {
        printer.add_raw_token(raw_token);
        return;
      }

      pre = indentation + matched[1] + '\n';
      text = matched[4];
      if (matched[5]) {
        post = indentation + matched[5];
      }

      // if there is at least one empty line at the end of this text, strip it
      // we'll be adding one back after the text but before the containing tag.
      text = text.replace(/\n[ \t]*$/, '');

      if (matched[2] || matched[3].indexOf('\n') !== -1) {
        // if the first line of the non-comment text has spaces
        // use that as the basis for indenting in null case.
        matched = matched[3].match(/[ \t]+$/);
        if (matched) {
          raw_token.whitespace_before = matched[0];
        }
      }
    }

    if (text) {
      if (_beautifier) {

        // call the Beautifier if avaliable
        var Child_options = function() {
          this.eol = '\n';
        };
        Child_options.prototype = this._options.raw_options;
        var child_options = new Child_options();
        text = _beautifier(indentation + text, child_options);
      } else {
        // simply indent the string otherwise
        var white = raw_token.whitespace_before;
        if (white) {
          text = text.replace(new RegExp('\n(' + white + ')?', 'g'), '\n');
        }

        text = indentation + text.replace(/\n/g, '\n' + indentation);
      }
    }

    if (pre) {
      if (!text) {
        text = pre + post;
      } else {
        text = pre + text + '\n' + post;
      }
    }

    printer.print_newline(false);
    if (text) {
      raw_token.text = text;
      raw_token.whitespace_before = '';
      raw_token.newlines = 0;
      printer.add_raw_token(raw_token);
      printer.print_newline(true);
    }
  }
};

Beautifier$4.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token) {
  var parser_token = this._get_tag_open_token(raw_token);

  if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) &&
    !last_tag_token.is_empty_element &&
    raw_token.type === TOKEN$4.TAG_OPEN && raw_token.text.indexOf('</') === 0) {
    // End element tags for unformatted or content_unformatted elements
    // are printed raw to keep any newlines inside them exactly the same.
    printer.add_raw_token(raw_token);
    parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
  } else {
    printer.traverse_whitespace(raw_token);
    this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);
    if (!parser_token.is_inline_element) {
      printer.set_wrap_point();
    }
    printer.print_token(raw_token);
  }

  //indent attributes an auto, forced, aligned or forced-align line-wrap
  if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {
    parser_token.alignment_size = raw_token.text.length + 1;
  }

  if (!parser_token.tag_complete && !parser_token.is_unformatted) {
    printer.alignment_size = parser_token.alignment_size;
  }

  return parser_token;
};

var TagOpenParserToken = function(parent, raw_token) {
  this.parent = parent || null;
  this.text = '';
  this.type = 'TK_TAG_OPEN';
  this.tag_name = '';
  this.is_inline_element = false;
  this.is_unformatted = false;
  this.is_content_unformatted = false;
  this.is_empty_element = false;
  this.is_start_tag = false;
  this.is_end_tag = false;
  this.indent_content = false;
  this.multiline_content = false;
  this.custom_beautifier_name = null;
  this.start_tag_token = null;
  this.attr_count = 0;
  this.has_wrapped_attrs = false;
  this.alignment_size = 0;
  this.tag_complete = false;
  this.tag_start_char = '';
  this.tag_check = '';

  if (!raw_token) {
    this.tag_complete = true;
  } else {
    var tag_check_match;

    this.tag_start_char = raw_token.text[0];
    this.text = raw_token.text;

    if (this.tag_start_char === '<') {
      tag_check_match = raw_token.text.match(/^<([^\s>]*)/);
      this.tag_check = tag_check_match ? tag_check_match[1] : '';
    } else {
      tag_check_match = raw_token.text.match(/^{{(?:[\^]|#\*?)?([^\s}]+)/);
      this.tag_check = tag_check_match ? tag_check_match[1] : '';

      // handle "{{#> myPartial}}
      if (raw_token.text === '{{#>' && this.tag_check === '>' && raw_token.next !== null) {
        this.tag_check = raw_token.next.text;
      }
    }
    this.tag_check = this.tag_check.toLowerCase();

    if (raw_token.type === TOKEN$4.COMMENT) {
      this.tag_complete = true;
    }

    this.is_start_tag = this.tag_check.charAt(0) !== '/';
    this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;
    this.is_end_tag = !this.is_start_tag ||
      (raw_token.closed && raw_token.closed.text === '/>');

    // handlebars tags that don't start with # or ^ are single_tags, and so also start and end.
    this.is_end_tag = this.is_end_tag ||
      (this.tag_start_char === '{' && (this.text.length < 3 || (/[^#\^]/.test(this.text.charAt(2)))));
  }
};

Beautifier$4.prototype._get_tag_open_token = function(raw_token) { //function to get a full tag and parse its type
  var parser_token = new TagOpenParserToken(this._tag_stack.get_parser_token(), raw_token);

  parser_token.alignment_size = this._options.wrap_attributes_indent_size;

  parser_token.is_end_tag = parser_token.is_end_tag ||
    in_array$2(parser_token.tag_check, this._options.void_elements);

  parser_token.is_empty_element = parser_token.tag_complete ||
    (parser_token.is_start_tag && parser_token.is_end_tag);

  parser_token.is_unformatted = !parser_token.tag_complete && in_array$2(parser_token.tag_check, this._options.unformatted);
  parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array$2(parser_token.tag_check, this._options.content_unformatted);
  parser_token.is_inline_element = in_array$2(parser_token.tag_name, this._options.inline) || parser_token.tag_start_char === '{';

  return parser_token;
};

Beautifier$4.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {

  if (!parser_token.is_empty_element) {
    if (parser_token.is_end_tag) { //this tag is a double tag so check for tag-ending
      parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name); //remove it and all ancestors
    } else { // it's a start-tag
      // check if this tag is starting an element that has optional end element
      // and do an ending needed
      if (this._do_optional_end_element(parser_token)) {
        if (!parser_token.is_inline_element) {
          printer.print_newline(false);
        }
      }

      this._tag_stack.record_tag(parser_token); //push it on the tag stack

      if ((parser_token.tag_name === 'script' || parser_token.tag_name === 'style') &&
        !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {
        parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);
      }
    }
  }

  if (in_array$2(parser_token.tag_check, this._options.extra_liners)) { //check if this double needs an extra line
    printer.print_newline(false);
    if (!printer._output.just_added_blankline()) {
      printer.print_newline(true);
    }
  }

  if (parser_token.is_empty_element) { //if this tag name is a single tag type (either in the list or has a closing /)

    // if you hit an else case, reset the indent level if you are inside an:
    // 'if', 'unless', or 'each' block.
    if (parser_token.tag_start_char === '{' && parser_token.tag_check === 'else') {
      this._tag_stack.indent_to_tag(['if', 'unless', 'each']);
      parser_token.indent_content = true;
      // Don't add a newline if opening {{#if}} tag is on the current line
      var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);
      if (!foundIfOnCurrentLine) {
        printer.print_newline(false);
      }
    }

    // Don't add a newline before elements that should remain where they are.
    if (parser_token.tag_name === '!--' && last_token.type === TOKEN$4.TAG_CLOSE &&
      last_tag_token.is_end_tag && parser_token.text.indexOf('\n') === -1) ; else {
      if (!(parser_token.is_inline_element || parser_token.is_unformatted)) {
        printer.print_newline(false);
      }
      this._calcluate_parent_multiline(printer, parser_token);
    }
  } else if (parser_token.is_end_tag) { //this tag is a double tag so check for tag-ending
    var do_end_expand = false;

    // deciding whether a block is multiline should not be this hard
    do_end_expand = parser_token.start_tag_token && parser_token.start_tag_token.multiline_content;
    do_end_expand = do_end_expand || (!parser_token.is_inline_element &&
      !(last_tag_token.is_inline_element || last_tag_token.is_unformatted) &&
      !(last_token.type === TOKEN$4.TAG_CLOSE && parser_token.start_tag_token === last_tag_token) &&
      last_token.type !== 'TK_CONTENT'
    );

    if (parser_token.is_content_unformatted || parser_token.is_unformatted) {
      do_end_expand = false;
    }

    if (do_end_expand) {
      printer.print_newline(false);
    }
  } else { // it's a start-tag
    parser_token.indent_content = !parser_token.custom_beautifier_name;

    if (parser_token.tag_start_char === '<') {
      if (parser_token.tag_name === 'html') {
        parser_token.indent_content = this._options.indent_inner_html;
      } else if (parser_token.tag_name === 'head') {
        parser_token.indent_content = this._options.indent_head_inner_html;
      } else if (parser_token.tag_name === 'body') {
        parser_token.indent_content = this._options.indent_body_inner_html;
      }
    }

    if (!(parser_token.is_inline_element || parser_token.is_unformatted) &&
      (last_token.type !== 'TK_CONTENT' || parser_token.is_content_unformatted)) {
      printer.print_newline(false);
    }

    this._calcluate_parent_multiline(printer, parser_token);
  }
};

Beautifier$4.prototype._calcluate_parent_multiline = function(printer, parser_token) {
  if (parser_token.parent && printer._output.just_added_newline() &&
    !((parser_token.is_inline_element || parser_token.is_unformatted) && parser_token.parent.is_inline_element)) {
    parser_token.parent.multiline_content = true;
  }
};

//To be used for <p> tag special case:
var p_closers = ['address', 'article', 'aside', 'blockquote', 'details', 'div', 'dl', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hr', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'];
var p_parent_excludes = ['a', 'audio', 'del', 'ins', 'map', 'noscript', 'video'];

Beautifier$4.prototype._do_optional_end_element = function(parser_token) {
  var result = null;
  // NOTE: cases of "if there is no more content in the parent element"
  // are handled automatically by the beautifier.
  // It assumes parent or ancestor close tag closes all children.
  // https://www.w3.org/TR/html5/syntax.html#optional-tags
  if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {
    return;

  }

  if (parser_token.tag_name === 'body') {
    // A head element’s end tag may be omitted if the head element is not immediately followed by a space character or a comment.
    result = result || this._tag_stack.try_pop('head');

    //} else if (parser_token.tag_name === 'body') {
    // DONE: A body element’s end tag may be omitted if the body element is not immediately followed by a comment.

  } else if (parser_token.tag_name === 'li') {
    // An li element’s end tag may be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('li', ['ol', 'ul']);

  } else if (parser_token.tag_name === 'dd' || parser_token.tag_name === 'dt') {
    // A dd element’s end tag may be omitted if the dd element is immediately followed by another dd element or a dt element, or if there is no more content in the parent element.
    // A dt element’s end tag may be omitted if the dt element is immediately followed by another dt element or a dd element.
    result = result || this._tag_stack.try_pop('dt', ['dl']);
    result = result || this._tag_stack.try_pop('dd', ['dl']);


  } else if (parser_token.parent.tag_name === 'p' && p_closers.indexOf(parser_token.tag_name) !== -1) {
    // IMPORTANT: this else-if works because p_closers has no overlap with any other element we look for in this method
    // check for the parent element is an HTML element that is not an <a>, <audio>, <del>, <ins>, <map>, <noscript>, or <video> element,  or an autonomous custom element.
    // To do this right, this needs to be coded as an inclusion of the inverse of the exclusion above.
    // But to start with (if we ignore "autonomous custom elements") the exclusion would be fine.
    var p_parent = parser_token.parent.parent;
    if (!p_parent || p_parent_excludes.indexOf(p_parent.tag_name) === -1) {
      result = result || this._tag_stack.try_pop('p');
    }
  } else if (parser_token.tag_name === 'rp' || parser_token.tag_name === 'rt') {
    // An rt element’s end tag may be omitted if the rt element is immediately followed by an rt or rp element, or if there is no more content in the parent element.
    // An rp element’s end tag may be omitted if the rp element is immediately followed by an rt or rp element, or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('rt', ['ruby', 'rtc']);
    result = result || this._tag_stack.try_pop('rp', ['ruby', 'rtc']);

  } else if (parser_token.tag_name === 'optgroup') {
    // An optgroup element’s end tag may be omitted if the optgroup element is immediately followed by another optgroup element, or if there is no more content in the parent element.
    // An option element’s end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('optgroup', ['select']);
    //result = result || this._tag_stack.try_pop('option', ['select']);

  } else if (parser_token.tag_name === 'option') {
    // An option element’s end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('option', ['select', 'datalist', 'optgroup']);

  } else if (parser_token.tag_name === 'colgroup') {
    // DONE: A colgroup element’s end tag may be omitted if the colgroup element is not immediately followed by a space character or a comment.
    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
    result = result || this._tag_stack.try_pop('caption', ['table']);

  } else if (parser_token.tag_name === 'thead') {
    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
    result = result || this._tag_stack.try_pop('caption', ['table']);
    result = result || this._tag_stack.try_pop('colgroup', ['table']);

    //} else if (parser_token.tag_name === 'caption') {
    // DONE: A caption element’s end tag may be omitted if the caption element is not immediately followed by a space character or a comment.

  } else if (parser_token.tag_name === 'tbody' || parser_token.tag_name === 'tfoot') {
    // A thead element’s end tag may be omitted if the thead element is immediately followed by a tbody or tfoot element.
    // A tbody element’s end tag may be omitted if the tbody element is immediately followed by a tbody or tfoot element, or if there is no more content in the parent element.
    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
    result = result || this._tag_stack.try_pop('caption', ['table']);
    result = result || this._tag_stack.try_pop('colgroup', ['table']);
    result = result || this._tag_stack.try_pop('thead', ['table']);
    result = result || this._tag_stack.try_pop('tbody', ['table']);

    //} else if (parser_token.tag_name === 'tfoot') {
    // DONE: A tfoot element’s end tag may be omitted if there is no more content in the parent element.

  } else if (parser_token.tag_name === 'tr') {
    // A tr element’s end tag may be omitted if the tr element is immediately followed by another tr element, or if there is no more content in the parent element.
    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
    result = result || this._tag_stack.try_pop('caption', ['table']);
    result = result || this._tag_stack.try_pop('colgroup', ['table']);
    result = result || this._tag_stack.try_pop('tr', ['table', 'thead', 'tbody', 'tfoot']);

  } else if (parser_token.tag_name === 'th' || parser_token.tag_name === 'td') {
    // A td element’s end tag may be omitted if the td element is immediately followed by a td or th element, or if there is no more content in the parent element.
    // A th element’s end tag may be omitted if the th element is immediately followed by a td or th element, or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('td', ['table', 'thead', 'tbody', 'tfoot', 'tr']);
    result = result || this._tag_stack.try_pop('th', ['table', 'thead', 'tbody', 'tfoot', 'tr']);
  }

  // Start element omission not handled currently
  // A head element’s start tag may be omitted if the element is empty, or if the first thing inside the head element is an element.
  // A tbody element’s start tag may be omitted if the first thing inside the tbody element is a tr element, and if the element is not immediately preceded by a tbody, thead, or tfoot element whose end tag has been omitted. (It can’t be omitted if the element is empty.)
  // A colgroup element’s start tag may be omitted if the first thing inside the colgroup element is a col element, and if the element is not immediately preceded by another colgroup element whose end tag has been omitted. (It can’t be omitted if the element is empty.)

  // Fix up the parent of the parser token
  parser_token.parent = this._tag_stack.get_parser_token();

  return result;
};

var Beautifier_1$2 = Beautifier$4;

var beautifier$2 = {
	Beautifier: Beautifier_1$2
};

var Beautifier$5 = beautifier$2.Beautifier,
  Options$9 = options$4.Options;

function style_html(html_source, options, js_beautify, css_beautify) {
  var beautifier = new Beautifier$5(html_source, options, js_beautify, css_beautify);
  return beautifier.beautify();
}

var html = style_html;
var defaultOptions$2 = function() {
  return new Options$9();
};
html.defaultOptions = defaultOptions$2;

function style_html$1(html_source, options, js, css$1) {
  js = js || javascript;
  css$1 = css$1 || css;
  return html(html_source, options, js, css$1);
}
style_html$1.defaultOptions = html.defaultOptions;

var js = javascript;
var css$1 = css;
var html$1 = style_html$1;

var src = {
	js: js,
	css: css$1,
	html: html$1
};

var js$1 = createCommonjsModule(function (module) {

/**
The following batches are equivalent:

var beautify_js = require('js-beautify');
var beautify_js = require('js-beautify').js;
var beautify_js = require('js-beautify').js_beautify;

var beautify_css = require('js-beautify').css;
var beautify_css = require('js-beautify').css_beautify;

var beautify_html = require('js-beautify').html;
var beautify_html = require('js-beautify').html_beautify;

All methods returned accept two arguments, the source string and an options object.
**/

function get_beautify(js_beautify, css_beautify, html_beautify) {
  // the default is js
  var beautify = function(src, config) {
    return js_beautify.js_beautify(src, config);
  };

  // short aliases
  beautify.js = js_beautify.js_beautify;
  beautify.css = css_beautify.css_beautify;
  beautify.html = html_beautify.html_beautify;

  // legacy aliases
  beautify.js_beautify = js_beautify.js_beautify;
  beautify.css_beautify = css_beautify.css_beautify;
  beautify.html_beautify = html_beautify.html_beautify;

  return beautify;
}

{
  (function(mod) {
    var beautifier = src;
    beautifier.js_beautify = beautifier.js;
    beautifier.css_beautify = beautifier.css;
    beautifier.html_beautify = beautifier.html;

    mod.exports = get_beautify(beautifier, beautifier, beautifier);

  })(module);
}
});

/**
 * This library modifies the diff-patch-match library by Neil Fraser
 * by removing the patch and match functionality and certain advanced
 * options in the diff function. The original license is as follows:
 *
 * ===
 *
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {Int|Object} [cursor_pos] Edit position in text1 or object with more info
 * @return {Array} Array of diff tuples.
 */
function diff_main(text1, text2, cursor_pos, _fix_unicode) {
  // Check for equality
  if (text1 === text2) {
    if (text1) {
      return [[DIFF_EQUAL, text1]];
    }
    return [];
  }

  if (cursor_pos != null) {
    var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);
    if (editdiff) {
      return editdiff;
    }
  }

  // Trim off common prefix (speedup).
  var commonlength = diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = diff_compute_(text1, text2);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  diff_cleanupMerge(diffs, _fix_unicode);
  return diffs;
}

/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 */
function diff_compute_(text1, text2) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i !== -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [
      [DIFF_INSERT, longtext.substring(0, i)],
      [DIFF_EQUAL, shorttext],
      [DIFF_INSERT, longtext.substring(i + shorttext.length)]
    ];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }

  if (shorttext.length === 1) {
    // Single character string.
    // After the previous speedup, the character can't be an equality.
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }

  // Check to see if the problem can be split in two.
  var hm = diff_halfMatch_(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = diff_main(text1_a, text2_a);
    var diffs_b = diff_main(text1_b, text2_b);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  return diff_bisect_(text1, text2);
}

/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 * @private
 */
function diff_bisect_(text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
  // integers and undefined.
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (delta % 2 !== 0);
  // Offsets for start and end of k loop.
  // Prevents mapping of space beyond the grid.
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    // Walk the front path one step.
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 === -d || (k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (
        x1 < text1_length && y1 < text2_length &&
        text1.charAt(x1) === text2.charAt(y1)
      ) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        // Ran off the right of the graph.
        k1end += 2;
      } else if (y1 > text2_length) {
        // Ran off the bottom of the graph.
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
          // Mirror x2 onto top-left coordinate system.
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            // Overlap detected.
            return diff_bisectSplit_(text1, text2, x1, y1);
          }
        }
      }
    }

    // Walk the reverse path one step.
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 === -d || (k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (
        x2 < text1_length && y2 < text2_length &&
        text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)
      ) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        // Ran off the left of the graph.
        k2end += 2;
      } else if (y2 > text2_length) {
        // Ran off the top of the graph.
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          // Mirror x2 onto top-left coordinate system.
          x2 = text1_length - x2;
          if (x1 >= x2) {
            // Overlap detected.
            return diff_bisectSplit_(text1, text2, x1, y1);
          }
        }
      }
    }
  }
  // Diff took too long and hit the deadline or
  // number of diffs equals number of characters, no commonality at all.
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
}

/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @return {Array} Array of diff tuples.
 */
function diff_bisectSplit_(text1, text2, x, y) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);

  // Compute both diffs serially.
  var diffs = diff_main(text1a, text2a);
  var diffsb = diff_main(text1b, text2b);

  return diffs.concat(diffsb);
}

/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
function diff_commonPrefix(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (
      text1.substring(pointerstart, pointermid) ==
      text2.substring(pointerstart, pointermid)
    ) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }

  if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
    pointermid--;
  }

  return pointermid;
}

/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
function diff_commonSuffix(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (
      text1.substring(text1.length - pointermid, text1.length - pointerend) ==
      text2.substring(text2.length - pointermid, text2.length - pointerend)
    ) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }

  if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
    pointermid--;
  }

  return pointermid;
}

/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 */
function diff_halfMatch_(text1, text2) {
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;  // Pointless.
  }

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI_(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {
      var prefixLength = diff_commonPrefix(
        longtext.substring(i), shorttext.substring(j));
      var suffixLength = diff_commonSuffix(
        longtext.substring(0, i), shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(
          j - suffixLength, j) + shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext.length) {
      return [
        best_longtext_a, best_longtext_b,
        best_shorttext_a, best_shorttext_b, best_common
      ];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
}

/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {Array} diffs Array of diff tuples.
 * @param {boolean} fix_unicode Whether to normalize to a unicode-correct diff
 */
function diff_cleanupMerge(diffs, fix_unicode) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
      diffs.splice(pointer, 1);
      continue;
    }
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:

        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        var previous_equality = pointer - count_insert - count_delete - 1;
        if (fix_unicode) {
          // prevent splitting of unicode surrogate pairs.  when fix_unicode is true,
          // we assume that the old and new text in the diff are complete and correct
          // unicode-encoded JS strings, but the tuple boundaries may fall between
          // surrogate pairs.  we fix this by shaving off stray surrogates from the end
          // of the previous equality and the beginning of this equality.  this may create
          // empty equalities or a common prefix or suffix.  for example, if AB and AC are
          // emojis, `[[0, 'A'], [-1, 'BA'], [0, 'C']]` would turn into deleting 'ABAC' and
          // inserting 'AC', and then the common suffix 'AC' will be eliminated.  in this
          // particular case, both equalities go away, we absorb any previous inequalities,
          // and we keep scanning for the next equality before rewriting the tuples.
          if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {
            var stray = diffs[previous_equality][1].slice(-1);
            diffs[previous_equality][1] = diffs[previous_equality][1].slice(0, -1);
            text_delete = stray + text_delete;
            text_insert = stray + text_insert;
            if (!diffs[previous_equality][1]) {
              // emptied out previous equality, so delete it and include previous delete/insert
              diffs.splice(previous_equality, 1);
              pointer--;
              var k = previous_equality - 1;
              if (diffs[k] && diffs[k][0] === DIFF_INSERT) {
                count_insert++;
                text_insert = diffs[k][1] + text_insert;
                k--;
              }
              if (diffs[k] && diffs[k][0] === DIFF_DELETE) {
                count_delete++;
                text_delete = diffs[k][1] + text_delete;
                k--;
              }
              previous_equality = k;
            }
          }
          if (starts_with_pair_end(diffs[pointer][1])) {
            var stray = diffs[pointer][1].charAt(0);
            diffs[pointer][1] = diffs[pointer][1].slice(1);
            text_delete += stray;
            text_insert += stray;
          }
        }
        if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
          // for empty equality not at end, wait for next equality
          diffs.splice(pointer, 1);
          break;
        }
        if (text_delete.length > 0 || text_insert.length > 0) {
          // note that diff_commonPrefix and diff_commonSuffix are unicode-aware
          if (text_delete.length > 0 && text_insert.length > 0) {
            // Factor out any common prefixes.
            commonlength = diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if (previous_equality >= 0) {
                diffs[previous_equality][1] += text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixes.
            commonlength = diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] =
                text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length - commonlength);
              text_delete = text_delete.substring(0, text_delete.length - commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          var n = count_insert + count_delete;
          if (text_delete.length === 0 && text_insert.length === 0) {
            diffs.splice(pointer - n, n);
            pointer = pointer - n;
          } else if (text_delete.length === 0) {
            diffs.splice(pointer - n, n, [DIFF_INSERT, text_insert]);
            pointer = pointer - n + 1;
          } else if (text_insert.length === 0) {
            diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete]);
            pointer = pointer - n + 1;
          } else {
            diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);
            pointer = pointer - n + 2;
          }
        }
        if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL &&
      diffs[pointer + 1][0] === DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
        diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
          diffs[pointer][1].substring(0, diffs[pointer][1].length -
            diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
        diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
          diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
          diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    diff_cleanupMerge(diffs, fix_unicode);
  }
}
function is_surrogate_pair_start(charCode) {
  return charCode >= 0xD800 && charCode <= 0xDBFF;
}

function is_surrogate_pair_end(charCode) {
  return charCode >= 0xDC00 && charCode <= 0xDFFF;
}

function starts_with_pair_end(str) {
  return is_surrogate_pair_end(str.charCodeAt(0));
}

function ends_with_pair_start(str) {
  return is_surrogate_pair_start(str.charCodeAt(str.length - 1));
}

function remove_empty_tuples(tuples) {
  var ret = [];
  for (var i = 0; i < tuples.length; i++) {
    if (tuples[i][1].length > 0) {
      ret.push(tuples[i]);
    }
  }
  return ret;
}

function make_edit_splice(before, oldMiddle, newMiddle, after) {
  if (ends_with_pair_start(before) || starts_with_pair_end(after)) {
    return null;
  }
  return remove_empty_tuples([
    [DIFF_EQUAL, before],
    [DIFF_DELETE, oldMiddle],
    [DIFF_INSERT, newMiddle],
    [DIFF_EQUAL, after]
  ]);
}

function find_cursor_edit_diff(oldText, newText, cursor_pos) {
  // note: this runs after equality check has ruled out exact equality
  var oldRange = typeof cursor_pos === 'number' ?
    { index: cursor_pos, length: 0 } : cursor_pos.oldRange;
  var newRange = typeof cursor_pos === 'number' ?
    null : cursor_pos.newRange;
  // take into account the old and new selection to generate the best diff
  // possible for a text edit.  for example, a text change from "xxx" to "xx"
  // could be a delete or forwards-delete of any one of the x's, or the
  // result of selecting two of the x's and typing "x".
  var oldLength = oldText.length;
  var newLength = newText.length;
  if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {
    // see if we have an insert or delete before or after cursor
    var oldCursor = oldRange.index;
    var oldBefore = oldText.slice(0, oldCursor);
    var oldAfter = oldText.slice(oldCursor);
    var maybeNewCursor = newRange ? newRange.index : null;
    editBefore: {
      // is this an insert or delete right before oldCursor?
      var newCursor = oldCursor + newLength - oldLength;
      if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {
        break editBefore;
      }
      if (newCursor < 0 || newCursor > newLength) {
        break editBefore;
      }
      var newBefore = newText.slice(0, newCursor);
      var newAfter = newText.slice(newCursor);
      if (newAfter !== oldAfter) {
        break editBefore;
      }
      var prefixLength = Math.min(oldCursor, newCursor);
      var oldPrefix = oldBefore.slice(0, prefixLength);
      var newPrefix = newBefore.slice(0, prefixLength);
      if (oldPrefix !== newPrefix) {
        break editBefore;
      }
      var oldMiddle = oldBefore.slice(prefixLength);
      var newMiddle = newBefore.slice(prefixLength);
      return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);
    }
    editAfter: {
      // is this an insert or delete right after oldCursor?
      if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {
        break editAfter;
      }
      var cursor = oldCursor;
      var newBefore = newText.slice(0, cursor);
      var newAfter = newText.slice(cursor);
      if (newBefore !== oldBefore) {
        break editAfter;
      }
      var suffixLength = Math.min(oldLength - cursor, newLength - cursor);
      var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);
      var newSuffix = newAfter.slice(newAfter.length - suffixLength);
      if (oldSuffix !== newSuffix) {
        break editAfter;
      }
      var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);
      var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);
      return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);
    }
  }
  if (oldRange.length > 0 && newRange && newRange.length === 0) {
    replaceRange: {
      // see if diff could be a splice of the old selection range
      var oldPrefix = oldText.slice(0, oldRange.index);
      var oldSuffix = oldText.slice(oldRange.index + oldRange.length);
      var prefixLength = oldPrefix.length;
      var suffixLength = oldSuffix.length;
      if (newLength < prefixLength + suffixLength) {
        break replaceRange;
      }
      var newPrefix = newText.slice(0, prefixLength);
      var newSuffix = newText.slice(newLength - suffixLength);
      if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {
        break replaceRange;
      }
      var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);
      var newMiddle = newText.slice(prefixLength, newLength - suffixLength);
      return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);
    }
  }

  return null;
}

function diff(text1, text2, cursor_pos) {
  // only pass fix_unicode=true at the top level, not when diff_main is
  // recursively invoked
  return diff_main(text1, text2, cursor_pos, true);
}

diff.INSERT = DIFF_INSERT;
diff.DELETE = DIFF_DELETE;
diff.EQUAL = DIFF_EQUAL;

var diff_1 = diff;

var prettydiff = createCommonjsModule(function (module) {
/*jslint node:true */
/*eslint-env node*/
/*eslint no-console:0*/
(function parse_init() {const parser = function parse_parser() {
        const langstore = [sparser.options.language, sparser.options.lexer];
        parse.count = -1;
        parse.data = {
            begin: [],
            ender: [],
            lexer: [],
            lines: [],
            stack: [],
            token: [],
            types: []
        };
        parse.datanames = [
            "begin",
            "ender",
            "lexer",
            "lines",
            "stack",
            "token",
            "types"
        ];
        parse.linesSpace = 0;
        parse.lineNumber = 1;
        parse.structure = [
            ["global", -1]
        ];
        parse.structure.pop = function parse_structure_pop() {
            const len = parse.structure.length - 1, arr = parse.structure[len];
            if (len > 0) {
                parse
                    .structure
                    .splice(len, 1);
            }
            return arr;
        };
        if (sparser.options.language === "auto" || sparser.options.lexer === "auto") {
            let lang = sparser.libs.language.auto(sparser.options.source, "javascript");
            if (sparser.options.language === "auto") {
                sparser.options.language = lang[0];
            }
            if (sparser.options.lexer === "auto") {
                sparser.options.lexer = lang[1];
            }
        }
        if (typeof sparser.lexers[sparser.options.lexer] === "function") {
            sparser.parseerror = "";
            // reset references data if sparser is used on multiple files
            parse.references = [[]];
            sparser.options.lexer_options = (sparser.options.lexer_options || {});
            Object.keys(sparser.lexers).forEach(function parse_lexers(value) {
                sparser.options.lexer_options[value] = (sparser.options.lexer_options[value] || {});
            });
            // This line parses the code using a lexer file
            sparser.lexers[sparser.options.lexer](`${sparser.options.source} `);
            // restore language and lexer values
        }
        else {
            sparser.parseerror = `Specified lexer, ${sparser.options.lexer}, is not a function.`;
        }
        // validate that all the data arrays are the same length
        (function parser_checkLengths() {
            let a = 0, b = 0;
            const keys = Object.keys(parse.data), c = keys.length;
            do {
                b = a + 1;
                do {
                    if (parse.data[keys[a]].length !== parse.data[keys[b]].length) {
                        sparser.parseerror = `"${keys[a]}" array is of different length than "${keys[b]}"`;
                        break;
                    }
                    b = b + 1;
                } while (b < c);
                a = a + 1;
            } while (a < c - 1);
        }());
        // fix begin values.  They must be reconsidered after reordering from object sort
        if (parse.data.begin.length > 0 && (sparser.options.lexer_options[sparser.options.lexer].object_sort === true || sparser.options.lexer_options.markup.tag_sort === true)) {
            parse.sortCorrection(0, parse.count + 1);
        }
        if (sparser.options.format === "csv") {
            let a = 0;
            const d = parse.data, data = ["index,begin,ender,lexer,lines,stack,token,types"], len = parse.count + 1;
            do {
                data.push([
                    a,
                    d.begin[a],
                    d.ender[a],
                    `"${d.lexer[a].replace(/"/g, "\"\"")}"`,
                    d.lines[a],
                    `"${d.stack[a].replace(/"/g, "\"\"")}"`,
                    `"${d.token[a].replace(/"/g, "\"\"")}"`,
                    `"${d.types[a].replace(/"/g, "\"\"")}"`
                ].join(","));
                a = a + 1;
            } while (a < len);
            return data.join("\r\n");
        }
        if (sparser.options.format === "markdown") {
            let a = 0, b = 0, strlen = 0, row = [], heading = "", line = "", str = "", begin = 0;
            const data = [], names = parse.datanames, longest = [1, 5, 5, 5, 5, 5, 5, 5], len = parse.count + 1;
            // first gather the string length of each data item
            longest[0] = String(parse.count).length;
            if (longest[0] < 5) {
                longest[0] = 5;
            }
            do {
                begin = String(parse.data.begin[a]).length;
                if (begin > longest[1]) {
                    longest[1] = begin;
                }
                begin = String(parse.data.ender[a]).length;
                if (begin > longest[2]) {
                    longest[2] = begin;
                }
                if (parse.data.lexer[a].length > longest[3]) {
                    longest[3] = parse.data.lexer[a].length;
                }
                begin = String(parse.data.lines[a]).length;
                if (begin > longest[4]) {
                    longest[4] = begin;
                }
                if (parse.data.stack[a].length > longest[5]) {
                    longest[5] = parse.data.stack[a].length;
                }
                if (parse.data.token[a].length > longest[6]) {
                    longest[6] = parse.data.token[a].length;
                }
                if (parse.data.types[a].length > longest[7]) {
                    longest[7] = parse.data.types[a].length;
                }
                a = a + 1;
            } while (a < len);
            names.splice(0, 0, "index");
            // second create the heading
            a = 0;
            do {
                row.push(parse.datanames[a]);
                if (longest[a] > 5) {
                    b = 5;
                    do {
                        row.push(" ");
                        b = b + 1;
                    } while (b < longest[a]);
                }
                row.push("|");
                a = a + 1;
            } while (a < 8);
            row.pop();
            heading = row.join("");
            row = [];
            // third create the line of dashes
            a = 0;
            do {
                b = 0;
                do {
                    row.push("-");
                    b = b + 1;
                } while (b < longest[a]);
                row.push("|");
                a = a + 1;
            } while (a < 8);
            row.pop();
            line = row.join("");
            row = [];
            // fourth create each data record
            a = 0;
            do {
                if (a % 100 === 0) {
                    data.push(heading);
                    data.push(line);
                }
                str = String(a);
                row.push(str);
                b = str.length;
                if (b < longest[0]) {
                    do {
                        row.push(" ");
                        b = b + 1;
                    } while (b < longest[0]);
                }
                row.push("|");
                b = 1;
                do {
                    str = String(parse.data[parse.datanames[b]][a]);
                    row.push(str);
                    strlen = str.length;
                    if (strlen < longest[b]) {
                        do {
                            row.push(" ");
                            strlen = strlen + 1;
                        } while (strlen < longest[b]);
                    }
                    row.push("|");
                    b = b + 1;
                } while (b < 8);
                row.pop();
                data.push(row.join(""));
                row = [];
                a = a + 1;
            } while (a < len);
            return data.join("\r\n");
        }
        if (sparser.options.format === "minimal") {
            let a = 0;
            const data = [], len = parse.count + 1;
            do {
                data.push([
                    parse.data.begin[a],
                    parse.data.ender[a],
                    parse.data.lexer[a],
                    parse.data.lines[a],
                    parse.data.stack[a],
                    parse.data.token[a],
                    parse.data.types[a]
                ]);
                a = a + 1;
            } while (a < len);
            return data;
        }
        if (sparser.options.format === "objects") {
            let a = 0;
            const data = [], len = parse.count + 1;
            do {
                data.push({
                    begin: parse.data.begin[a],
                    ender: parse.data.ender[a],
                    lexer: parse.data.lexer[a],
                    lines: parse.data.lines[a],
                    stack: parse.data.stack[a],
                    token: parse.data.token[a],
                    types: parse.data.types[a]
                });
                a = a + 1;
            } while (a < len);
            return data;
        }
        if (sparser.options.format === "testprep") {
            let a = 0;
            const data = [], len = parse.count + 1;
            if (sparser.parseerror !== "") {
                return sparser.parseerror;
            }
            do {
                data.push(JSON.stringify({
                    begin: parse.data.begin[a],
                    ender: parse.data.ender[a],
                    lexer: parse.data.lexer[a],
                    lines: parse.data.lines[a],
                    stack: parse.data.stack[a],
                    token: parse.data.token[a],
                    types: parse.data.types[a]
                }));
                a = a + 1;
            } while (a < len);
            return `[\n${data.join(",\n")}\n]`;
        }
        sparser.options.language = langstore[0];
        sparser.options.lexer = langstore[1];
        return parse.data;
    }, parse = {
        // stores the final index location of the data arrays
        count: -1,
        // stores the various data arrays of the parse table
        data: {
            begin: [],
            ender: [],
            lexer: [],
            lines: [],
            stack: [],
            token: [],
            types: []
        },
        // stores the name of the data arrays.  This is used for internal automation
        datanames: ["begin", "ender", "lexer", "lines", "stack", "token", "types"],
        // stores the current line number from the input string for logging parse errors
        lineNumber: 1,
        // stores the 'lines' value before the next token
        linesSpace: 0,
        // stores the declared variable names for the script lexer.  This must be stored outside the script lexer since some languages recursive use of the script lexer
        references: [[]],
        // stores the stack and begin values by stacking depth
        structure: [["global", -1]],
        // an extension of Array.prototype.concat to work across the data structure.  This is an expensive operation.
        concat: function parse_concat(data, array) {
            parse
                .datanames
                .forEach(function parse_concat_datanames(value) {
                data[value] = data[value].concat(array[value]);
            });
            if (data === parse.data) {
                parse.count = data.token.length - 1;
            }
        },
        // the function that sorts object properties
        object_sort: function parse_objectSort(data) {
            let cc = parse.count, global = (data.lexer[cc] === "style" && parse.structure[parse.structure.length - 1][0] === "global"), dd = parse.structure[parse.structure.length - 1][1], ee = 0, ff = 0, gg = 0, behind = 0, commaTest = true, front = 0, keyend = 0, keylen = 0;
            const keys = [], length = parse.count, begin = dd, stack = (global === true)
                ? "global"
                : parse.structure[parse.structure.length - 1][0], style = (data.lexer[cc] === "style"), delim = (style === true)
                ? [";", "separator"]
                : [",", "separator"], lines = parse.linesSpace, sort = function parse_objectSort_sort(x, y) {
                let xx = x[0], yy = y[0];
                if (data.types[xx] === "comment") {
                    do {
                        xx = xx + 1;
                    } while (xx < length && (data.types[xx] === "comment"));
                    if (data.token[xx] === undefined) {
                        return 1;
                    }
                }
                if (data.types[yy] === "comment") {
                    do {
                        yy = yy + 1;
                    } while (yy < length && (data.types[yy] === "comment"));
                    if (data.token[yy] === undefined) {
                        return 1;
                    }
                }
                if (style === true) {
                    if (data.token[xx].indexOf("@import") === 0 || data.token[yy].indexOf("@import") === 0) {
                        // JavaScript's standard array sort uses implementation specific algorithms.
                        // This simple numeric trick forces conformance.
                        if (xx < yy) {
                            return -1;
                        }
                        return 1;
                    }
                    if (data.types[xx] !== data.types[yy]) {
                        if (data.types[xx] === "function") {
                            return 1;
                        }
                        if (data.types[xx] === "variable") {
                            return -1;
                        }
                        if (data.types[xx] === "selector") {
                            return 1;
                        }
                        if (data.types[xx] === "property" && data.types[yy] !== "variable") {
                            return -1;
                        }
                        if (data.types[xx] === "mixin" && data.types[yy] !== "property" && data.types[yy] !== "variable") {
                            return -1;
                        }
                    }
                }
                if (data.token[xx].toLowerCase() > data.token[yy].toLowerCase()) {
                    return 1;
                }
                return -1;
            }, store = {
                begin: [],
                ender: [],
                lexer: [],
                lines: [],
                stack: [],
                token: [],
                types: []
            };
            behind = cc;
            do {
                if (data.begin[cc] === dd || (global === true && cc < behind && data.token[cc] === "}" && data.begin[data.begin[cc]] === -1)) {
                    if (data.types[cc].indexOf("template") > -1) {
                        return;
                    }
                    if (data.token[cc] === delim[0] || (style === true && data.token[cc] === "}" && data.token[cc + 1] !== ";")) {
                        commaTest = true;
                        front = cc + 1;
                    }
                    else if (style === true && data.token[cc - 1] === "}") {
                        commaTest = true;
                        front = cc;
                    }
                    if (front === 0 && data.types[0] === "comment") {
                        // keep top comments at the top
                        do {
                            front = front + 1;
                        } while (data.types[front] === "comment");
                    }
                    else if (data.types[front] === "comment" && data.lines[front] < 2) {
                        // if a comment follows code on the same line then keep the comment next to the code it follows
                        front = front + 1;
                    }
                    if (commaTest === true && (data.token[cc] === delim[0] || (style === true && data.token[cc - 1] === "}")) && front <= behind) {
                        if (style === true && "};".indexOf(data.token[behind]) < 0) {
                            behind = behind + 1;
                        }
                        else if (style === false && data.token[behind] !== ",") {
                            behind = behind + 1;
                        }
                        keys.push([front, behind]);
                        if (style === true && data.token[front] === "}") {
                            behind = front;
                        }
                        else {
                            behind = front - 1;
                        }
                    }
                }
                cc = cc - 1;
            } while (cc > dd);
            if (keys.length > 0 && keys[keys.length - 1][0] > cc + 1) {
                ee = keys[keys.length - 1][0] - 1;
                if (data.types[ee] === "comment" && data.lines[ee] > 1) {
                    do {
                        ee = ee - 1;
                    } while (ee > 0 && data.types[ee] === "comment");
                    keys[keys.length - 1][0] = ee + 1;
                }
                if (data.types[cc + 1] === "comment" && cc === -1) {
                    do {
                        cc = cc + 1;
                    } while (data.types[cc + 1] === "comment");
                }
                keys.push([
                    cc + 1,
                    ee
                ]);
            }
            if (keys.length > 1) {
                if (style === true || data.token[cc - 1] === "=" || data.token[cc - 1] === ":" || data.token[cc - 1] === "(" || data.token[cc - 1] === "[" || data.token[cc - 1] === "," || data.types[cc - 1] === "word" || cc === 0) {
                    keys.sort(sort);
                    keylen = keys.length;
                    commaTest = false;
                    dd = 0;
                    do {
                        keyend = keys[dd][1];
                        if (style === true) {
                            gg = keyend;
                            if (data.types[gg] === "comment") {
                                gg = gg - 1;
                            }
                            if (data.token[gg] === "}") {
                                keyend = keyend + 1;
                                delim[0] = "}";
                                delim[1] = "end";
                            }
                            else {
                                delim[0] = ";";
                                delim[1] = "separator";
                            }
                        }
                        ee = keys[dd][0];
                        if (style === true && data.types[keyend - 1] !== "end" && data.types[keyend] === "comment" && data.types[keyend + 1] !== "comment" && dd < keylen - 1) {
                            // missing a terminal comment causes many problems
                            keyend = keyend + 1;
                        }
                        if (ee < keyend) {
                            do {
                                if (style === false && dd === keylen - 1 && ee === keyend - 2 && data.token[ee] === "," && data.lexer[ee] === "script" && data.types[ee + 1] === "comment") {
                                    // do not include terminal commas that are followed by a comment
                                    ff = ff + 1;
                                }
                                else {
                                    parse.push(store, {
                                        begin: data.begin[ee],
                                        ender: data.begin[ee],
                                        lexer: data.lexer[ee],
                                        lines: data.lines[ee],
                                        stack: data.stack[ee],
                                        token: data.token[ee],
                                        types: data.types[ee]
                                    }, "");
                                    ff = ff + 1;
                                }
                                //remove extra commas
                                if (data.token[ee] === delim[0] && (style === true || data.begin[ee] === data.begin[keys[dd][0]])) {
                                    commaTest = true;
                                }
                                else if (data.token[ee] !== delim[0] && data.types[ee] !== "comment") {
                                    commaTest = false;
                                }
                                ee = ee + 1;
                            } while (ee < keyend);
                        }
                        // injecting the list delimiter
                        if (commaTest === false && store.token[store.token.length - 1] !== "x;" && (style === true || dd < keylen - 1)) {
                            ee = store.types.length - 1;
                            if (store.types[ee] === "comment") {
                                do {
                                    ee = ee - 1;
                                } while (ee > 0 && (store.types[ee] === "comment"));
                            }
                            ee = ee + 1;
                            parse.splice({
                                data: store,
                                howmany: 0,
                                index: ee,
                                record: {
                                    begin: begin,
                                    ender: parse.count,
                                    lexer: store.lexer[ee - 1],
                                    lines: 0,
                                    stack: stack,
                                    token: delim[0],
                                    types: delim[1]
                                }
                            });
                            ff = ff + 1;
                        }
                        dd = dd + 1;
                    } while (dd < keylen);
                    parse.splice({
                        data: data,
                        howmany: ff,
                        index: cc + 1
                    });
                    parse.linesSpace = lines;
                    parse.concat(data, store);
                    return;
                }
            }
            return;
        },
        // an extension of Array.prototype.pop to work across the data structure
        pop: function parse_pop(data) {
            const output = {
                begin: data.begin.pop(),
                ender: data.ender.pop(),
                lexer: data.lexer.pop(),
                lines: data.lines.pop(),
                stack: data.stack.pop(),
                token: data.token.pop(),
                types: data.types.pop()
            };
            if (data === parse.data) {
                parse.count = parse.count - 1;
            }
            return output;
        },
        // an extension of Array.prototype.push to work across the data structure
        push: function parse_push(data, record, structure) {
            const ender = function parse_push_ender() {
                let a = parse.count;
                const begin = data.begin[a];
                if ((data.lexer[a] === "markup" && sparser.options.lexer_options.markup.tag_sort === true) ||
                    ((data.lexer[a] === "script" || data.lexer[a] === "style") && sparser.options.lexer_options[data.lexer[a]].object_sort === true)) {
                    // sorting can result in a token whose begin value is greater than either
                    // its current index or the index of the end token, which results in an endless loop
                    //
                    // these end values are addressed at the end of the "parser" function with parse.sortCorrection
                    return;
                }
                do {
                    if (data.begin[a] === begin || (data.begin[data.begin[a]] === begin && data.types[a].indexOf("attribute") > -1 && data.types[a].indexOf("attribute_end") < 0)) {
                        data.ender[a] = parse.count;
                    }
                    else {
                        a = data.begin[a];
                    }
                    a = a - 1;
                } while (a > begin);
                if (a > -1) {
                    data.ender[a] = parse.count;
                }
            };
            parse
                .datanames
                .forEach(function parse_push_datanames(value) {
                data[value].push(record[value]);
            });
            if (data === parse.data) {
                parse.count = parse.count + 1;
                parse.linesSpace = 0;
                if (record.lexer !== "style") {
                    if (structure.replace(/(\{|\}|@|<|>|%|#|)/g, "") === "") {
                        if (record.types === "else") {
                            structure = "else";
                        }
                        else {
                            structure = record.token;
                        }
                    }
                    else if ((/^<\?(=|(php))/).test(structure) === false) {
                        structure = structure.replace(/(\{|\}|@|<|>|%|#|)\s*/g, "");
                    }
                }
                if (record.types === "start" || record.types.indexOf("_start") > 0) {
                    parse.structure.push([structure, parse.count]);
                }
                else if (record.types === "end" || record.types.indexOf("_end") > 0) {
                    // this big condition fixes language specific else blocks that are children of start/end blocks not associated with the if/else chain
                    let case_ender = 0;
                    if (parse.structure.length > 2 &&
                        (data.types[parse.structure[parse.structure.length - 1][1]] === "else" || data.types[parse.structure[parse.structure.length - 1][1]].indexOf("_else") > 0) &&
                        (data.types[parse.structure[parse.structure.length - 2][1]] === "start" || data.types[parse.structure[parse.structure.length - 2][1]].indexOf("_start") > 0) &&
                        (data.types[parse.structure[parse.structure.length - 2][1] + 1] === "else" || data.types[parse.structure[parse.structure.length - 2][1] + 1].indexOf("_else") > 0)) {
                        parse.structure.pop();
                        data.begin[parse.count] = parse.structure[parse.structure.length - 1][1];
                        data.stack[parse.count] = parse.structure[parse.structure.length - 1][0];
                        data.ender[parse.count - 1] = parse.count;
                        case_ender = data.ender[data.begin[parse.count] + 1];
                    }
                    ender();
                    if (case_ender > 0) {
                        data.ender[data.begin[parse.count] + 1] = case_ender;
                    }
                    parse.structure.pop();
                }
                else if (record.types === "else" || record.types.indexOf("_else") > 0) {
                    if (structure === "") {
                        structure = "else";
                    }
                    if (parse.count > 0 && (data.types[parse.count - 1] === "start" || data.types[parse.count - 1].indexOf("_start") > 0)) {
                        parse.structure.push([structure, parse.count]);
                    }
                    else {
                        ender();
                        if (structure === "") {
                            parse.structure[parse.structure.length - 1] = ["else", parse.count];
                        }
                        else {
                            parse.structure[parse.structure.length - 1] = [structure, parse.count];
                        }
                    }
                }
            }
        },
        // a custom sort tool that is a bit more intelligent and multidimensional than Array.prototype.sort
        safeSort: function parse_safeSort(array, operation, recursive) {
            let extref = function parse_safeSort_extref(item) {
                //worthless function for backwards compatibility with older versions of V8 node.
                return item;
            };
            const arTest = function parse_safeSort_arTest(item) {
                if (Array.isArray(item) === true) {
                    return true;
                }
                return false;
            }, normal = function parse_safeSort_normal(item) {
                let storeb = item;
                const done = [item[0]], child = function safeSort_normal_child() {
                    let a = 0;
                    const len = storeb.length;
                    if (a < len) {
                        do {
                            if (arTest(storeb[a]) === true) {
                                storeb[a] = parse_safeSort_normal(storeb[a]);
                            }
                            a = a + 1;
                        } while (a < len);
                    }
                }, recurse = function parse_safeSort_normal_recurse(x) {
                    let a = 0;
                    const storea = [], len = storeb.length;
                    if (a < len) {
                        do {
                            if (storeb[a] !== x) {
                                storea.push(storeb[a]);
                            }
                            a = a + 1;
                        } while (a < len);
                    }
                    storeb = storea;
                    if (storea.length > 0) {
                        done.push(storea[0]);
                        extref(storea[0]);
                    }
                    else {
                        if (recursive === true) {
                            child();
                        }
                        item = storeb;
                    }
                };
                extref = recurse;
                recurse(array[0]);
                return item;
            }, descend = function parse_safeSort_descend(item) {
                let c = 0;
                const len = item.length, storeb = item, child = function parse_safeSort_descend_child() {
                    let a = 0;
                    const lenc = storeb.length;
                    if (a < lenc) {
                        do {
                            if (arTest(storeb[a]) === true) {
                                storeb[a] = parse_safeSort_descend(storeb[a]);
                            }
                            a = a + 1;
                        } while (a < lenc);
                    }
                }, recurse = function parse_safeSort_descend_recurse(value) {
                    let a = c, b = 0, d = 0, e = 0, ind = [], key = storeb[c], tstore = "";
                    const tkey = typeof key;
                    if (a < len) {
                        do {
                            tstore = typeof storeb[a];
                            if (storeb[a] > key || (tstore > tkey)) {
                                key = storeb[a];
                                ind = [a];
                            }
                            else if (storeb[a] === key) {
                                ind.push(a);
                            }
                            a = a + 1;
                        } while (a < len);
                    }
                    d = ind.length;
                    a = c;
                    b = d + c;
                    if (a < b) {
                        do {
                            storeb[ind[e]] = storeb[a];
                            storeb[a] = key;
                            e = e + 1;
                            a = a + 1;
                        } while (a < b);
                    }
                    c = c + d;
                    if (c < len) {
                        extref("");
                    }
                    else {
                        if (recursive === true) {
                            child();
                        }
                        item = storeb;
                    }
                    return value;
                };
                extref = recurse;
                recurse("");
                return item;
            }, ascend = function parse_safeSort_ascend(item) {
                let c = 0;
                const len = item.length, storeb = item, child = function parse_safeSort_ascend_child() {
                    let a = 0;
                    const lenc = storeb.length;
                    if (a < lenc) {
                        do {
                            if (arTest(storeb[a]) === true) {
                                storeb[a] = parse_safeSort_ascend(storeb[a]);
                            }
                            a = a + 1;
                        } while (a < lenc);
                    }
                }, recurse = function parse_safeSort_ascend_recurse(value) {
                    let a = c, b = 0, d = 0, e = 0, ind = [], key = storeb[c], tstore = "";
                    const tkey = typeof key;
                    if (a < len) {
                        do {
                            tstore = typeof storeb[a];
                            if (storeb[a] < key || tstore < tkey) {
                                key = storeb[a];
                                ind = [a];
                            }
                            else if (storeb[a] === key) {
                                ind.push(a);
                            }
                            a = a + 1;
                        } while (a < len);
                    }
                    d = ind.length;
                    a = c;
                    b = d + c;
                    if (a < b) {
                        do {
                            storeb[ind[e]] = storeb[a];
                            storeb[a] = key;
                            e = e + 1;
                            a = a + 1;
                        } while (a < b);
                    }
                    c = c + d;
                    if (c < len) {
                        extref("");
                    }
                    else {
                        if (recursive === true) {
                            child();
                        }
                        item = storeb;
                    }
                    return value;
                };
                extref = recurse;
                recurse("");
                return item;
            };
            if (arTest(array) === false) {
                return array;
            }
            if (operation === "normal") {
                return normal(array);
            }
            if (operation === "descend") {
                return descend(array);
            }
            return ascend(array);
        },
        // this functionality provides corrections to the "begin" and "ender" values after use of object_sort
        sortCorrection: function parse_sortCorrection(start, end) {
            let a = start, endslen = -1;
            const data = parse.data, ends = [], structure = (parse.structure.length < 2)
                ? [-1]
                : [parse.structure[parse.structure.length - 2][1]];
            // this first loop solves for the begin values
            do {
                if (a > 0 &&
                    data.types[a].indexOf("attribute") > -1 &&
                    data.types[a].indexOf("end") < 0 &&
                    data.types[a - 1].indexOf("start") < 0 &&
                    data.types[a - 1].indexOf("attribute") < 0 &&
                    data.lexer[a] === "markup") {
                    structure.push(a - 1);
                }
                if (a > 0 &&
                    data.types[a - 1].indexOf("attribute") > -1 &&
                    data.types[a].indexOf("attribute") < 0 &&
                    data.lexer[structure[structure.length - 1]] === "markup" &&
                    data.types[structure[structure.length - 1]].indexOf("start") < 0) {
                    structure.pop();
                }
                if (data.begin[a] !== structure[structure.length - 1]) {
                    if (structure.length > 0) {
                        data.begin[a] = structure[structure.length - 1];
                    }
                    else {
                        data.begin[a] = -1;
                    }
                }
                if (data.types[a].indexOf("else") > -1) {
                    if (structure.length > 0) {
                        structure[structure.length - 1] = a;
                    }
                    else {
                        structure.push(a);
                    }
                }
                if (data.types[a].indexOf("end") > -1) {
                    structure.pop();
                }
                if (data.types[a].indexOf("start") > -1) {
                    structure.push(a);
                }
                a = a + 1;
            } while (a < end);
            // and now for the ender values
            a = end;
            do {
                a = a - 1;
                if (data.types[a].indexOf("end") > -1) {
                    ends.push(a);
                    endslen = endslen + 1;
                }
                if (endslen > -1) {
                    data.ender[a] = ends[endslen];
                }
                else {
                    data.ender[a] = -1;
                }
                if (data.types[a].indexOf("start") > -1) {
                    ends.pop();
                    endslen = endslen - 1;
                }
            } while (a > start);
        },
        // a simple tool to take note of whitespace between tokens
        spacer: function parse_spacer(args) {
            // * array - the characters to scan
            // * index - the index to start scanning from
            // * end   - the length of the array, to break the loop
            parse.linesSpace = 1;
            do {
                if (args.array[args.index] === "\n") {
                    parse.linesSpace = parse.linesSpace + 1;
                    parse.lineNumber = parse.lineNumber + 1;
                }
                if ((/\s/).test(args.array[args.index + 1]) === false) {
                    break;
                }
                args.index = args.index + 1;
            } while (args.index < args.end);
            return args.index;
        },
        // an extension of Array.prototype.splice to work across the data structure
        splice: function parse_splice(spliceData) {
            const finalItem = [parse.data.begin[parse.count], parse.data.token[parse.count]];
            // * data    - The data object to alter
            // * howmany - How many indexes to remove
            // * index   - The index where to start
            // * record  - A new record to insert
            if (spliceData.record !== undefined && spliceData.record.token !== "") {
                parse
                    .datanames
                    .forEach(function parse_splice_datanames(value) {
                    spliceData
                        .data[value]
                        .splice(spliceData.index, spliceData.howmany, spliceData.record[value]);
                });
                if (spliceData.data === parse.data) {
                    parse.count = (parse.count - spliceData.howmany) + 1;
                    if (finalItem[0] !== parse.data.begin[parse.count] || finalItem[1] !== parse.data.token[parse.count]) {
                        parse.linesSpace = 0;
                    }
                }
                return;
            }
            parse
                .datanames
                .forEach(function parse_splice_datanames(value) {
                spliceData
                    .data[value]
                    .splice(spliceData.index, spliceData.howmany);
            });
            if (spliceData.data === parse.data) {
                parse.count = parse.count - spliceData.howmany;
                parse.linesSpace = 0;
            }
        },
        // parsing block comments and simultaneously applying word wrap
        wrapCommentBlock: function parse_wrapCommentBlock(config) {
            let a = config.start, b = 0, c = 0, d = 0, len = 0, lines = [], space = "", bline = "", spaceLine, emptyLine = false, bulletLine = false, numberLine = false, bigLine = false, output = "", terml = config.terminator.length - 1, term = config.terminator.charAt(terml), twrap = 0;
            const build = [], second = [], lf = (sparser.options.crlf === true)
                ? "\r\n"
                : "\n", sanitize = function parse_wrapCommentBlock_sanitize(input) {
                return `\\${input}`;
            }, regEsc = (/(\/|\\|\||\*|\[|\]|\{|\})/g), regEnd = new RegExp(`\\s*${config.terminator.replace(regEsc, sanitize)}$`), regIgnore = new RegExp(`^(${config.opening.replace(regEsc, sanitize)}\\s*parse-ignore-start)`), regStart = new RegExp(`(${config.opening.replace(regEsc, sanitize)}\\s*)`), wrap = sparser.options.wrap, emptyLines = function parse_wrapCommentBlock_emptyLines() {
                if ((/^\s+$/).test(lines[b + 1]) === true || lines[b + 1] === "") {
                    do {
                        b = b + 1;
                    } while (b < len && ((/^\s+$/).test(lines[b + 1]) === true || lines[b + 1] === ""));
                }
                if (b < len - 1) {
                    second.push("");
                }
            };
            do {
                build.push(config.chars[a]);
                if (config.chars[a] === "\n") {
                    parse.lineNumber = parse.lineNumber + 1;
                }
                if (config.chars[a] === term && config.chars.slice(a - terml, a + 1).join("") === config.terminator) {
                    break;
                }
                a = a + 1;
            } while (a < config.end);
            output = build.join("");
            if (regIgnore.test(output) === true) {
                let termination = "\n";
                a = a + 1;
                do {
                    build.push(config.chars[a]);
                    a = a + 1;
                } while (a < config.end && (config.chars[a - 1] !== "d" || (config.chars[a - 1] === "d" && build.slice(build.length - 16).join("") !== "parse-ignore-end")));
                b = a;
                terml = config.opening.length - 1;
                term = config.opening.charAt(terml);
                do {
                    if (config.opening === "/*" && config.chars[b - 1] === "/" && (config.chars[b] === "*" || config.chars[b] === "/")) {
                        break; // for script
                    }
                    if (config.opening !== "/*" && config.chars[b] === term && config.chars.slice(b - terml, b + 1).join("") === config.opening) {
                        break; // for markup
                    }
                    b = b - 1;
                } while (b > config.start);
                if (config.opening === "/*" && config.chars[b] === "*") {
                    termination = "\u002a/";
                }
                else if (config.opening !== "/*") {
                    termination = config.terminator;
                }
                terml = termination.length - 1;
                term = termination.charAt(terml);
                if (termination !== "\n" || config.chars[a] !== "\n") {
                    do {
                        build.push(config.chars[a]);
                        if (termination === "\n" && config.chars[a + 1] === "\n") {
                            break;
                        }
                        if (config.chars[a] === term && config.chars.slice(a - terml, a + 1).join("") === termination) {
                            break;
                        }
                        a = a + 1;
                    } while (a < config.end);
                }
                if (config.chars[a] === "\n") {
                    a = a - 1;
                }
                output = build.join("").replace(/\s+$/, "");
                return [output, a];
            }
            if (a === config.end || wrap < 1 || (output.length <= wrap && output.indexOf("\n") < 0) || sparser.options.preserve_comment === true || (config.opening === "/*" && output.indexOf("\n") > 0 && output.replace("\n", "").indexOf("\n") > 0 && (/\n(?!(\s*\*))/).test(output) === false)) {
                return [output, a];
            }
            b = config.start;
            if (b > 0 && config.chars[b - 1] !== "\n" && (/\s/).test(config.chars[b - 1]) === true) {
                do {
                    b = b - 1;
                } while (b > 0 && config.chars[b - 1] !== "\n" && (/\s/).test(config.chars[b - 1]) === true);
            }
            space = config.chars.slice(b, config.start).join("");
            spaceLine = new RegExp(`\n${space}`, "g");
            lines = output.replace(/\r\n/g, "\n").replace(spaceLine, "\n").split("\n");
            len = lines.length;
            lines[0] = lines[0].replace(regStart, "");
            lines[len - 1] = lines[len - 1].replace(regEnd, "");
            if (len < 2) {
                lines = lines[0].split(" ");
            }
            if (lines[0] === "") {
                lines[0] = config.opening;
            }
            else {
                lines.splice(0, 0, config.opening);
            }
            len = lines.length;
            b = 0;
            do {
                bline = (b < len - 1)
                    ? lines[b + 1].replace(/^\s+/, "")
                    : "";
                if ((/^\s+$/).test(lines[b]) === true || lines[b] === "") {
                    emptyLines();
                }
                else if (lines[b].slice(0, 4) === "    ") {
                    second.push(lines[b]);
                }
                else if (lines[b].replace(/^\s+/, "").length > wrap && lines[b].replace(/^\s+/, "").indexOf(" ") > wrap) {
                    lines[b] = lines[b].replace(/^\s+/, "");
                    c = lines[b].indexOf(" ");
                    second.push(lines[b].slice(0, c));
                    lines[b] = lines[b].slice(c + 1);
                    b = b - 1;
                }
                else {
                    if (config.opening === "/*" && lines[b].indexOf("/*") !== 0) {
                        lines[b] = `   ${lines[b].replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ")}`;
                    }
                    else {
                        lines[b] = `${lines[b].replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ")}`;
                    }
                    twrap = (b < 1)
                        ? wrap - (config.opening.length + 1)
                        : wrap;
                    c = lines[b].length;
                    d = lines[b].replace(/^\s+/, "").indexOf(" ");
                    if (c > twrap && d > 0 && d < twrap) {
                        c = twrap;
                        do {
                            c = c - 1;
                            if ((/\s/).test(lines[b].charAt(c)) === true && c <= wrap) {
                                break;
                            }
                        } while (c > 0);
                        if (lines[b].slice(0, 4) !== "    " && (/^\s*(\*|-)\s/).test(lines[b]) === true && (/^\s*(\*|-)\s/).test(lines[b + 1]) === false) {
                            lines.splice(b + 1, 0, "* ");
                        }
                        if (lines[b].slice(0, 4) !== "    " && (/^\s*\d+\.\s/).test(lines[b]) === true && (/^\s*\d+\.\s/).test(lines[b + 1]) === false) {
                            lines.splice(b + 1, 0, "1. ");
                        }
                        if (c < 4) {
                            second.push(lines[b]);
                            bigLine = true;
                        }
                        else if (b === len - 1) {
                            second.push(lines[b].slice(0, c));
                            lines[b] = lines[b].slice(c + 1);
                            bigLine = true;
                            b = b - 1;
                        }
                        else if ((/^\s+$/).test(lines[b + 1]) === true || lines[b + 1] === "") {
                            second.push(lines[b].slice(0, c));
                            lines[b] = lines[b].slice(c + 1);
                            emptyLine = true;
                            b = b - 1;
                        }
                        else if (lines[b + 1].slice(0, 4) !== "    " && (/^\s*(\*|-)\s/).test(lines[b + 1]) === true) {
                            second.push(lines[b].slice(0, c));
                            lines[b] = lines[b].slice(c + 1);
                            bulletLine = true;
                            b = b - 1;
                        }
                        else if (lines[b + 1].slice(0, 4) !== "    " && (/^\s*\d+\.\s/).test(lines[b + 1]) === true) {
                            second.push(lines[b].slice(0, c));
                            lines[b] = lines[b].slice(c + 1);
                            numberLine = true;
                            b = b - 1;
                        }
                        else if (lines[b + 1].slice(0, 4) === "    ") {
                            second.push(lines[b].slice(0, c));
                            lines[b] = lines[b].slice(c + 1);
                            bigLine = true;
                            b = b - 1;
                        }
                        else if (c + bline.length > wrap && bline.indexOf(" ") < 0) {
                            second.push(lines[b].slice(0, c));
                            lines[b] = lines[b].slice(c + 1);
                            bigLine = true;
                            b = b - 1;
                        }
                        else if (lines[b].replace(/^\s+/, "").indexOf(" ") < wrap) {
                            if (lines[b].length > wrap) {
                                lines[b + 1] = lines[b].slice(c + 1) + lf + lines[b + 1];
                            }
                            else {
                                lines[b + 1] = `${lines[b].slice(c + 1)} ${lines[b + 1]}`;
                            }
                        }
                        if (emptyLine === false && bulletLine === false && numberLine === false && bigLine === false) {
                            lines[b] = lines[b].slice(0, c);
                        }
                    }
                    else if (lines[b + 1] !== undefined && ((lines[b].length + bline.indexOf(" ") > wrap && bline.indexOf(" ") > 0) || (lines[b].length + bline.length > wrap && bline.indexOf(" ") < 0))) {
                        second.push(lines[b]);
                        b = b + 1;
                    }
                    else if (lines[b + 1] !== undefined && (/^\s+$/).test(lines[b + 1]) === false && lines[b + 1] !== "" && lines[b + 1].slice(0, 4) !== "    " && (/^\s*(\*|-|(\d+\.))\s/).test(lines[b + 1]) === false) {
                        lines[b + 1] = `${lines[b]} ${lines[b + 1]}`;
                        emptyLine = true;
                    }
                    if (bigLine === false && bulletLine === false && numberLine === false) {
                        if (emptyLine === true) {
                            emptyLine = false;
                        }
                        else if ((/^\s*(\*|-|(\d+\.))\s*$/).test(lines[b]) === false) {
                            if (b < len - 1 && lines[b + 1] !== "" && (/^\s+$/).test(lines[b]) === false && lines[b + 1].slice(0, 4) !== "    " && (/^\s*(\*|-|(\d+\.))\s/).test(lines[b + 1]) === false) {
                                lines[b] = `${lines[b]} ${lines[b + 1]}`;
                                lines.splice(b + 1, 1);
                                len = len - 1;
                                b = b - 1;
                            }
                            else {
                                if (config.opening === "/*" && lines[b].indexOf("/*") !== 0) {
                                    second.push(`   ${lines[b].replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ")}`);
                                }
                                else {
                                    second.push(`${lines[b].replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ")}`);
                                }
                            }
                        }
                    }
                    bigLine = false;
                    bulletLine = false;
                    numberLine = false;
                }
                b = b + 1;
            } while (b < len);
            if (second.length > 0) {
                if (second[second.length - 1].length > wrap - (config.terminator.length + 1)) {
                    second.push(config.terminator);
                }
                else {
                    second[second.length - 1] = `${second[second.length - 1]} ${config.terminator}`;
                }
                output = second.join(lf);
            }
            else {
                lines[lines.length - 1] = lines[lines.length - 1] + config.terminator;
                output = lines.join(lf);
            }
            return [output, a];
        },
        // parsing line comments and simultaneously applying word wrap
        wrapCommentLine: function parse_wrapCommentLine(config) {
            let a = config.start, b = 0, output = "", build = [];
            const wrap = sparser.options.wrap, recurse = function parse_wrapCommentLine_recurse() {
                let line = "";
                do {
                    b = b + 1;
                    if (config.chars[b + 1] === "\n") {
                        return;
                    }
                } while (b < config.end && (/\s/).test(config.chars[b]) === true);
                if (config.chars[b] + config.chars[b + 1] === "//") {
                    build = [];
                    do {
                        build.push(config.chars[b]);
                        b = b + 1;
                    } while (b < config.end && config.chars[b] !== "\n");
                    line = build.join("");
                    if ((/^\/\/ (\*|-|(\d+\.))/).test(line) === false && line.slice(0, 6) !== "//    " && (/^\/\/\s*$/).test(line) === false) {
                        output = `${output} ${line.replace(/(^\/\/\s*)/, "").replace(/\s+$/, "")}`;
                        a = b - 1;
                        parse_wrapCommentLine_recurse();
                    }
                }
            }, wordWrap = function parse_wrapCommentLine_wordWrap() {
                let c = 0, d = 0;
                const lines = [], record = (parse.count > -1)
                    ? {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: config.lexer,
                        lines: parse.linesSpace,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: parse.data.token[parse.count],
                        types: "comment"
                    }
                    : {
                        begin: -1,
                        ender: -1,
                        lexer: config.lexer,
                        lines: parse.linesSpace,
                        stack: "global",
                        token: "",
                        types: "comment"
                    };
                output = output.replace(/\s+/g, " ").replace(/\s+$/, "");
                d = output.length;
                if (wrap > d) {
                    return;
                }
                do {
                    c = wrap;
                    if (output.charAt(c) !== " ") {
                        do {
                            c = c - 1;
                        } while (c > 0 && output.charAt(c) !== " ");
                        if (c < 3) {
                            c = wrap;
                            do {
                                c = c + 1;
                            } while (c < d - 1 && output.charAt(c) !== " ");
                        }
                    }
                    lines.push(output.slice(0, c));
                    output = `// ${output.slice(c).replace(/^\s+/, "")}`;
                    d = output.length;
                } while (wrap < d);
                c = 0;
                d = lines.length;
                do {
                    record.token = lines[c];
                    parse.push(parse.data, record, "");
                    record.lines = 2;
                    parse.linesSpace = 2;
                    c = c + 1;
                } while (c < d);
            };
            do {
                build.push(config.chars[a]);
                a = a + 1;
            } while (a < config.end && config.chars[a] !== "\n");
            if (a === config.end) {
                // necessary because the wrapping logic expects line termination
                config.chars.push("\n");
            }
            else {
                a = a - 1;
            }
            output = build.join("").replace(/\s+$/, "");
            if ((/^(\/\/\s*parse-ignore\u002dstart)/).test(output) === true) {
                let termination = "\n";
                a = a + 1;
                do {
                    build.push(config.chars[a]);
                    a = a + 1;
                } while (a < config.end && (config.chars[a - 1] !== "d" || (config.chars[a - 1] === "d" && build.slice(build.length - 16).join("") !== "parse-ignore-end")));
                b = a;
                do {
                } while (b > config.start && config.chars[b - 1] === "/" && (config.chars[b] === "*" || config.chars[b] === "/"));
                if (config.chars[b] === "*") {
                    termination = "\u002a/";
                }
                if (termination !== "\n" || config.chars[a] !== "\n") {
                    do {
                        build.push(config.chars[a]);
                        if (termination === "\n" && config.chars[a + 1] === "\n") {
                            break;
                        }
                        a = a + 1;
                    } while (a < config.end && (termination === "\n" || (termination === "\u002a/" && (config.chars[a - 1] !== "*" || config.chars[a] !== "/"))));
                }
                if (config.chars[a] === "\n") {
                    a = a - 1;
                }
                output = build.join("").replace(/\s+$/, "");
                return [output, a];
            }
            if (output === "//" || output.slice(0, 6) === "//    " || sparser.options.preserve_comment === true) {
                return [output, a];
            }
            output = output.replace(/(\/\/\s*)/, "// ");
            if (wrap < 1 || (a === config.end - 1 && parse.data.begin[parse.count] < 1)) {
                return [output, a];
            }
            b = a + 1;
            recurse();
            wordWrap();
            return [output, a];
        }
    }, sparser = {
        lexers: {},
        libs: {},
        options:{"lexer_options":{"markup":{"attribute_sort":false,"attribute_sort_list":"","parse_space":false,"preserve_text":false,"quote_convert":"none","tag_merge":false,"tag_sort":false,"unformatted":false},"script":{"end_comma":"none","object_sort":false,"quote_convert":"none","variable_list":"none"},"style":{"no_lead_zero":false,"object_sort":false,"quote_convert":"none"}},"correct":false,"crlf":false,"format":"arrays","language":"auto","lexer":"auto","preserve_comment":false,"source":"","wrap":0},
        parse: parse,
        parser: parser,
        parseerror: "",
        version:{date:"18 Aug 2019",number:"1.4.12"}
    },prettydiff=function mode(diffmeta) {
    const pdcomment = function mode_pdcomment() {
        const ops = prettydiff.sparser.options;
        let sindex = options.source.search(/((\/(\*|\/))|<!--*)\s*prettydiff\.com/), dindex = options.diff.search(/((\/(\*|\/))|<!--*)\s*prettydiff\.com/), a = 0, b = 0, keys, def, len;
        // parses the prettydiff settings comment
        //
        // - Source Priorities:
        // * the prettydiff comment is only accepted if it occurs before non-comments (near the top)
        // * options.source is the priority material for reading the comment
        // * the prettydiff comment will be processed from options.diff only if it present there, missing from options.source, and options.mode is diff
        //
        // - Examples:
        //    /*prettydiff.com width:80 preserve:4*/
        //    /* prettydiff.com width:80 preserve:4 */
        //    /*prettydiff.com width=80 preserve=4 */
        //    // prettydiff.com width=80 preserve:4
        //    <!-- prettydiff.com width:80 preserve=4 -->
        //    <!--prettydiff.com width:40 preserve:2-->
        //
        // - Parsing Considerations:
        // * there may be any amount of space at the start or end of the comment
        // * "prettydiff.com" must exist at the start of the comment
        // * comment must exist prior to non-comment tokens (near top of code)
        // * parameters are name value pairs separated by white space
        // * the delimiter separating name and value is either ":" or "=" characters
        if ((sindex > -1 && (sindex === 0 || "\"':".indexOf(options.source.charAt(sindex - 1)) < 0)) || (options.mode === "diff" && dindex > -1 && (dindex === 0 || "\"':".indexOf(options.diff.charAt(dindex - 1)) < 0))) {
            let pdcom = sindex, a = (pdcom > -1)
                ? pdcom
                : dindex, b = 0, quote = "", item = "", lang = "", lex = "", valkey = [], op = [];
            const ops = [], source = (pdcom > -1)
                ? options.source
                : options.diff, len = source.length, comment = (source.charAt(a) === "<")
                ? "<!--"
                : (source.charAt(a + 1) === "/")
                    ? "//"
                    : "/\u002a", esc = function mode_pdcomment_esc() {
                if (source.charAt(a - 1) !== "\\") {
                    return false;
                }
                let x = a;
                do {
                    x = x - 1;
                } while (x > 0 && source.charAt(x) === "\\");
                if ((a - x) % 2 === 0) {
                    return true;
                }
                return false;
            };
            do {
                if (source.slice(a - 3, a) === "com") {
                    break;
                }
                a = a + 1;
            } while (a < len);
            do {
                if (esc() === false) {
                    if (quote === "") {
                        if (source.charAt(a) === "\"") {
                            quote = "\"";
                            if (ops.length > 0 && (ops[ops.length - 1].charAt(ops[ops.length - 1].length - 1) === ":" || ops[ops.length - 1].charAt(ops[ops.length - 1].length - 1) === "=")) {
                                b = a;
                            }
                        }
                        else if (source.charAt(a) === "'") {
                            quote = "'";
                            if (ops.length > 0 && (ops[ops.length - 1].charAt(ops[ops.length - 1].length - 1) === ":" || ops[ops.length - 1].charAt(ops[ops.length - 1].length - 1) === "=")) {
                                b = a;
                            }
                        }
                        else if (source.charAt(a) === "`") {
                            quote = "`";
                            if (ops.length > 0 && (ops[ops.length - 1].charAt(ops[ops.length - 1].length - 1) === ":" || ops[ops.length - 1].charAt(ops[ops.length - 1].length - 1) === "=")) {
                                b = a;
                            }
                        }
                        else if ((/\s/).test(source.charAt(a)) === false && b === 0) {
                            b = a;
                        }
                        else if (source.charAt(a) === "," || ((/\s/).test(source.charAt(a)) === true && b > 0)) {
                            item = source.slice(b, a);
                            if (ops.length > 0) {
                                if (ops.length > 0 && (item === ":" || item === "=") && ops[ops.length - 1].indexOf("=") < 0 && ops[ops.length - 1].indexOf(":") < 0) {
                                    // for cases where white space is between option name and assignment operator
                                    ops[ops.length - 1] = ops[ops.length - 1] + item;
                                    b = a;
                                }
                                else if (ops.length > 0 && (ops[ops.length - 1].charAt(ops[ops.length - 1].length - 1) === ":" || ops[ops.length - 1].charAt(ops[ops.length - 1].length - 1) === "=")) {
                                    // for cases where white space is between assignment operator and value
                                    ops[ops.length - 1] = ops[ops.length - 1] + item;
                                    b = 0;
                                }
                                else {
                                    ops.push(item);
                                    b = 0;
                                }
                            }
                            else {
                                ops.push(item);
                                b = 0;
                            }
                        }
                        if (comment === "<!--" && source.slice(a - 2, a + 1) === "-->") {
                            break;
                        }
                        if (comment === "//" && source.charAt(a) === "\n") {
                            break;
                        }
                        if (comment === "/\u002a" && source.slice(a - 1, a + 1) === "\u002a/") {
                            break;
                        }
                    }
                    else if (source.charAt(a) === quote && quote !== "${") {
                        quote = "";
                    }
                    else if (quote === "`" && source.slice(a, a + 2) === "${") {
                        quote = "${";
                    }
                    else if (quote === "${" && source.charAt(a) === "}") {
                        quote = "`";
                    }
                }
                a = a + 1;
            } while (a < len);
            if (b > 0) {
                quote = source.slice(b, a + 1);
                if (comment === "<!--") {
                    quote = quote.replace(/\s*-+>$/, "");
                }
                else if (comment === "//") {
                    quote = quote.replace(/\s+$/, "");
                }
                else {
                    quote = quote.replace(/\s*\u002a\/$/, "");
                }
                ops.push(quote);
            }
            a = ops.length;
            if (a > 0) {
                do {
                    a = a - 1;
                    if (ops[a].indexOf("=") > 0 && ops[a].indexOf(":") > 0) {
                        if (ops[a].indexOf("=") < ops[a].indexOf(":")) {
                            op = [ops[a].slice(0, ops[a].indexOf("=")), ops[a].slice(ops[a].indexOf("=") + 1)];
                        }
                    }
                    else if (ops[a].indexOf("=") > 0) {
                        op = [ops[a].slice(0, ops[a].indexOf("=")), ops[a].slice(ops[a].indexOf("=") + 1)];
                    }
                    else if (ops[a].indexOf(":") > 0) {
                        op = [ops[a].slice(0, ops[a].indexOf(":")), ops[a].slice(ops[a].indexOf(":") + 1)];
                    }
                    else if (prettydiff.api.optionDef[ops[a]] !== undefined && prettydiff.api.optionDef[ops[a]].type === "boolean") {
                        options[ops[a]] = true;
                    }
                    if (op.length === 2 && prettydiff.api.optionDef[op[0]] !== undefined) {
                        if ((op[1].charAt(0) === "\"" || op[1].charAt(0) === "'" || op[1].charAt(0) === "`") && op[1].charAt(op[1].length - 1) === op[1].charAt(0)) {
                            op[1] = op[1].slice(1, op[1].length - 1);
                        }
                        if (prettydiff.api.optionDef[op[0]].type === "number" && isNaN(Number(op[1])) === false) {
                            options[op[0]] = Number(op[1]);
                        }
                        else if (prettydiff.api.optionDef[op[0]].type === "boolean") {
                            if (op[1] === "true") {
                                options[op[0]] = true;
                            }
                            else if (op[1] === "false") {
                                options[op[0]] = false;
                            }
                        }
                        else {
                            if (prettydiff.api.optionDef[op[0]].values !== undefined) {
                                valkey = Object.keys(prettydiff.api.optionDef[op[0]].values);
                                b = valkey.length;
                                do {
                                    b = b - 1;
                                    if (valkey[b] === op[1]) {
                                        options[op[0]] = op[1];
                                        break;
                                    }
                                } while (b > 0);
                            }
                            else {
                                if (op[0] === "language") {
                                    lang = op[1];
                                }
                                else if (op[0] === "lexer") {
                                    lex = op[1];
                                }
                                options[op[0]] = op[1];
                            }
                        }
                    }
                } while (a > 0);
                if (lex === "" && lang !== "") {
                    lex = prettydiff.api.language.setlexer(lang);
                }
            }
        }
        if (options.mode === "diff") {
            modeValue = "beautify";
        }
        if (options.mode === "minify" && options.minify_wrap === false) {
            options.wrap = -1;
        }
        if (options.lexer === "script") {
            let styleguide = {
                airbnb: function mode_pdcomment_styleairbnb() {
                    options.brace_padding = true;
                    options.correct = true;
                    options.lexerOptions.script.end_comma = "always";
                    options.indent_char = " ";
                    options.indent_size = 2;
                    options.preserve = 1;
                    options.quote_convert = "single";
                    options.variable_list = "each";
                    options.wrap = 80;
                },
                crockford: function mode_pdcomment_stylecrockford() {
                    options.brace_padding = false;
                    options.correct = true;
                    options.else_line = false;
                    options.lexerOptions.script.end_comma = "never";
                    options.indent_char = " ";
                    options.indent_size = 4;
                    options.no_case_indent = true;
                    options.space = true;
                    options.variable_list = "each";
                    options.vertical = false;
                },
                google: function mode_pdcomment_stylegoogle() {
                    options.correct = true;
                    options.indent_char = " ";
                    options.indent_size = 4;
                    options.preserve = 1;
                    options.quote_convert = "single";
                    options.vertical = false;
                    options.wrap = -1;
                },
                jquery: function mode_pdcomment_stylejquery() {
                    options.brace_padding = true;
                    options.correct = true;
                    options.indent_char = "\u0009";
                    options.indent_size = 1;
                    options.quote_convert = "double";
                    options.variable_list = "each";
                    options.wrap = 80;
                },
                jslint: function mode_pdcomment_stylejslint() {
                    options.brace_padding = false;
                    options.correct = true;
                    options.else_line = false;
                    options.lexerOptions.script.end_comma = "never";
                    options.indent_char = " ";
                    options.indent_size = 4;
                    options.no_case_indent = true;
                    options.space = true;
                    options.variable_list = "each";
                    options.vertical = false;
                },
                mrdoobs: function mode_pdcomment_stylemrdoobs() {
                    options.brace_line = true;
                    options.brace_padding = true;
                    options.correct = true;
                    options.indent_char = "\u0009";
                    options.indent_size = 1;
                    options.vertical = false;
                },
                mediawiki: function mode_pdcomment_stylemediawiki() {
                    options.brace_padding = true;
                    options.correct = true;
                    options.indent_char = "\u0009";
                    options.indent_size = 1;
                    options.preserve = 1;
                    options.quote_convert = "single";
                    options.space = false;
                    options.wrap = 80;
                },
                meteor: function mode_pdcomment_stylemeteor() {
                    options.correct = true;
                    options.indent_char = " ";
                    options.indent_size = 2;
                    options.wrap = 80;
                },
                semistandard: function mode_pdcomment_stylessemistandard() {
                    options.brace_line = false;
                    options.brace_padding = false;
                    options.braces = false;
                    options.correct = true;
                    options.end_comma = "never";
                    options.indent_char = " ";
                    options.indent_size = 2;
                    options.new_line = false;
                    options.no_semicolon = false;
                    options.preserve = 1;
                    options.quote_convert = "single";
                    options.space = true;
                    options.ternary_line = false;
                    options.variable_list = "each";
                    options.vertical = false;
                    options.wrap = 0;
                },
                standard: function mode_pdcomment_stylestandard() {
                    options.brace_line = false;
                    options.brace_padding = false;
                    options.braces = false;
                    options.correct = true;
                    options.end_comma = "never";
                    options.indent_char = " ";
                    options.indent_size = 2;
                    options.new_line = false;
                    options.no_semicolon = true;
                    options.preserve = 1;
                    options.quote_convert = "single";
                    options.space = true;
                    options.ternary_line = false;
                    options.variable_list = "each";
                    options.vertical = false;
                    options.wrap = 0;
                },
                yandex: function mode_pdcomment_styleyandex() {
                    options.brace_padding = false;
                    options.correct = true;
                    options.quote_convert = "single";
                    options.variable_list = "each";
                    options.vertical = false;
                }
            }, brace_style = {
                collapse: function mode_pdcomment_collapse() {
                    options.brace_line = false;
                    options.brace_padding = false;
                    options.braces = false;
                    options.format_object = "indent";
                    options.never_flatten = true;
                },
                "collapse-preserve-inline": function mode_pdcomment_collapseInline() {
                    options.brace_line = false;
                    options.brace_padding = true;
                    options.braces = false;
                    options.format_object = "inline";
                    options.never_flatten = false;
                },
                expand: function mode_pdcomment_expand() {
                    options.brace_line = false;
                    options.brace_padding = false;
                    options.braces = true;
                    options.format_object = "indent";
                    options.never_flatten = true;
                }
            };
            if (styleguide[options.styleguide] !== undefined) {
                styleguide[options.styleguide]();
            }
            if (brace_style[options.brace_style] !== undefined) {
                brace_style[options.brace_style]();
            }
            if (options.language === "json") {
                options.wrap = 0;
            }
            else if (options.language === "titanium") {
                options.correct = false;
            }
            if (options.language !== "javascript" && options.language !== "typescript" && options.language !== "jsx") {
                options.jsscope = "none";
            }
        }
        if (options.lexer !== "markup" || options.language === "text") {
            options.diff_rendered_html = false;
        }
        else if (options.api === "node" && options.read_method !== "file") {
            options.diff_rendered_html = false;
        }
        def = prettydiff.sparser.libs.optionDef;
        keys = Object.keys(def);
        len = keys.length;
        do {
            if (options[keys[a]] !== undefined) {
                if (def[keys[a]].lexer[0] === "all") {
                    ops[keys[a]] = options[keys[a]];
                }
                else {
                    b = def[keys[a]].lexer.length;
                    do {
                        b = b - 1;
                        if (keys[a] !== "parse_space" || (options.mode === "parse" && keys[a] === "parse_space" && options[keys[a]] === true)) {
                            ops.lexer_options[def[keys[a]].lexer[b]][keys[a]] = options[keys[a]];
                        }
                    } while (b > 0);
                }
            }
            a = a + 1;
        } while (a < len);
    }, options = prettydiff.options, lf = (options.crlf === true)
        ? "\r\n"
        : "\n";
    let modeValue = options.mode, result = "";
    if (options.api === "node" && (options.read_method === "directory" || options.read_method === "subdirectory")) {
        if (options.mode === "parse" && options.parse_format === "table") {
            return "Error: option parse_format with value 'table' is not available with read_method directory or subdirectory.";
        }
    }
    if (options.language === "text" && options.mode !== "diff") {
        options.language = "auto";
    }
    if (options.lexer === "text" && options.mode !== "diff") {
        options.lexer = "auto";
    }
    if (options.language === "text" || options.lexer === "text") {
        options.language = "text";
        options.language_name = "Plain Text";
        options.lexer = "text";
    }
    else if (options.language === "auto" || options.lexer === "auto") {
        const def = (options.language_default === "" || options.language_default === null || options.language_default === undefined)
            ? "javascript"
            : options.language_default;
        let lang = prettydiff.api.language.auto(options.source, def);
        if (lang[0] === "text") {
            if (options.mode === "diff") {
                lang[2] = "Plain Text";
            }
            else {
                lang = ["javascript", "script", "JavaScript"];
            }
        }
        else if (lang[0] === "csv") {
            lang[2] = "CSV";
        }
        if (options.language === "auto") {
            options.language = lang[0];
            options.language_name = lang[2];
        }
        if (options.lexer === "auto") {
            options.lexer = lang[1];
        }
    }
    pdcomment();
    if (options.mode === "parse") {
        const parse_format = (options.parse_format === "htmltable")
            ? "table"
            : options.parse_format, api = (options.parse_format === "htmltable")
            ? "dom"
            : options.api;
        options.parsed = prettydiff.sparser.parser();
        if (parse_format === "table") {
            if (api === "dom") {
                const parsLen = options.parsed.token.length, keys = Object.keys(options.parsed), keylen = keys.length, headingString = (function mode_parseHeading() {
                    const hout = ["<tr><th>index</th>"];
                    let b = 0;
                    do {
                        if (keys[b] !== "token") {
                            hout.push(`<th>${keys[b]}</th>`);
                        }
                        b = b + 1;
                    } while (b < keylen);
                    hout.push("<th>token</th></tr>");
                    return hout.join("");
                }()), row = function mode_parseRow() {
                    const hout = ["<tr>"];
                    let b = 0;
                    hout.push(`<td>${a}</td>`);
                    do {
                        if (keys[b] !== "token") {
                            hout.push(`<td>${options.parsed[keys[b]][a].toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")}</td>`);
                        }
                        b = b + 1;
                    } while (b < keylen);
                    hout.push(`<td>${options.parsed.token[a].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")}</td></tr>`);
                    return hout.join("");
                }, parsOut = [];
                parsOut.push(`<p><strong>${parsLen}</strong> total parsed tokens</p>`);
                parsOut.push("<table><thead>");
                parsOut.push(headingString);
                parsOut.push("</thead><tbody>");
                let a = 0;
                do {
                    if (a % 100 === 0 && a > 0) {
                        parsOut.push(headingString);
                    }
                    parsOut.push(row());
                    a = a + 1;
                } while (a < parsLen);
                parsOut.push("</tbody></table>");
                result = parsOut.join("");
            }
            else {
                let a = 0, str = [];
                const outputArrays = options.parsed, nodeText = {
                    angry: "\u001b[1m\u001b[31m",
                    blue: "\u001b[34m",
                    bold: "\u001b[1m",
                    cyan: "\u001b[36m",
                    green: "\u001b[32m",
                    nocolor: "\u001b[39m",
                    none: "\u001b[0m",
                    purple: "\u001b[35m",
                    red: "\u001b[31m",
                    underline: "\u001b[4m",
                    yellow: "\u001b[33m"
                }, output = [], b = outputArrays.token.length, pad = function mode_parsePad(x, y) {
                    const cc = x
                        .toString()
                        .replace(/\s/g, " ");
                    let dd = y - cc.length;
                    str.push(cc);
                    if (dd > 0) {
                        do {
                            str.push(" ");
                            dd = dd - 1;
                        } while (dd > 0);
                    }
                    str.push(" | ");
                }, heading = "index | begin | ender | lexer  | lines | stack       | types       | token", bar = "------|-------|-------|--------|-------|-------------|-------------|------";
                output.push("");
                output.push(heading);
                output.push(bar);
                do {
                    if (a % 100 === 0 && a > 0) {
                        output.push("");
                        output.push(heading);
                        output.push(bar);
                    }
                    str = [];
                    if (outputArrays.lexer[a] === "markup") {
                        str.push(nodeText.red);
                    }
                    else if (outputArrays.lexer[a] === "script") {
                        str.push(nodeText.green);
                    }
                    else if (outputArrays.lexer[a] === "style") {
                        str.push(nodeText.yellow);
                    }
                    pad(a.toString(), 5);
                    pad(outputArrays.begin[a].toString(), 5);
                    pad(outputArrays.ender[a].toString(), 5);
                    pad(outputArrays.lexer[a].toString(), 5);
                    pad(outputArrays.lines[a].toString(), 5);
                    pad(outputArrays.stack[a].toString(), 11);
                    pad(outputArrays.types[a].toString(), 11);
                    str.push(outputArrays.token[a].replace(/\s/g, " "));
                    str.push(nodeText.none);
                    output.push(str.join(""));
                    a = a + 1;
                } while (a < b);
                result = output.join(lf);
            }
        }
        else {
            result = JSON.stringify(options.parsed);
        }
    }
    else {
        if (prettydiff[modeValue][options.lexer] === undefined && ((options.mode !== "diff" && options.language === "text") || options.language !== "text")) {
            result = `Error: Library prettydiff.${modeValue}.${options.lexer} does not exist.`;
        }
        else if (options.mode === "diff") {
            let diffoutput;
            if (options.diff_format === "json") {
                options.complete_document = false;
            }
            if (options.language === "text") {
                diffoutput = prettydiff.api.diffview(options);
                result = diffoutput[0];
            }
            else {
                const ind = options.indent;
                if (options.diff_rendered_html === true) {
                    const lexers = {
                        del: 0,
                        insert: 0,
                        replace: 0
                    }, typeIgnore = [
                        "attribute",
                        "cdata",
                        "comment",
                        "conditional",
                        "ignore",
                        "jsx_attribute_end",
                        "jsx_attribute_start",
                        "script",
                        "sgml",
                        "style",
                        "xml"
                    ], tab = function mode_diffhtmlTab(indentation) {
                        const tabout = (options.crlf === true)
                            ? ["\r\n"]
                            : ["\n"];
                        let a = 0, b = options.indent_size * indentation;
                        if (b > 1) {
                            do {
                                tabout.push(options.indent_char);
                                a = a + 1;
                            } while (a < b);
                        }
                        else {
                            tabout.push(options.indent_char);
                            tabout.push(options.indent_char);
                        }
                        return tabout.join("");
                    }, css = [
                        `${tab(2)}<style type="text/css">`,
                        "#prettydiff_summary{background:#eef8ff;border:2px solid #069}",
                        ".prettydiff_rendered{border-style:solid;border-width:2px;display:inline-block}",
                        ".prettydiff_delete{background:#ffd8d8;border-color:#c44}",
                        ".prettydiff_insert{background:#d8ffd8;border-color:#090}",
                        ".prettydiff_replace{background:#fec;border-color:#a86}"
                    ], insert = function mode_insert() {
                        const inject = [`<span class="prettydiff_rendered prettydiff_insert">`];
                        if (json[a + 1][0] === "+") {
                            do {
                                inject.push(json[a][1]);
                                count[1] = count[1] + 1;
                                a = a + 1;
                            } while (json[a + 1][0] === "+");
                        }
                        inject.push(json[a][1]);
                        inject.push("</span>");
                        options.parsed.token[count[0]] = `${inject.join("")} ${options.parsed.token[count[0]]}`;
                        lexers.insert = lexers.insert + 1;
                    }, del = function mode_del() {
                        const symb = json[a][0], change = (symb === "-")
                            ? "delete"
                            : "replace";
                        options.parsed.token[count[0]] = `<span class="prettydiff_rendered prettydiff_${change}">${options.parsed.token[count[0]]}`;
                        if (json[a + 1][0] === symb) {
                            do {
                                count[0] = count[0] + 1;
                                if (change === "replace") {
                                    count[1] = count[1] + 1;
                                }
                                a = a + 1;
                            } while (json[a + 1][0] === symb);
                        }
                        options.parsed.token[count[0]] = `${options.parsed.token[count[0]]}</span>`;
                        if (change === "delete") {
                            lexers.del = lexers.del + 1;
                        }
                        else {
                            lexers.replace = lexers.replace + 1;
                        }
                    }, summary = function mode_summary() {
                        const keys = Object.keys(lexers), len = keys.length, output = [], lex = [];
                        let a = 0, lextest = false;
                        output.push(`<div id="prettydiff_summary"><h1>Pretty Diff - Summary</h1>`);
                        output.push("<p>This is the count of identified differences starting with visual differences colored in the document first.</p><ul>");
                        output.push(`<li>Deletions - <strong>${lexers.del}</strong></li>`);
                        output.push(`<li>Insertions - <strong>${lexers.insert}</strong></li>`);
                        output.push(`<li>Replacements - <strong>${lexers.replace}</strong></li>`);
                        output.push("</ul>");
                        if (len > 3) {
                            lexers.del = 0;
                            lexers.insert = 0;
                            lexers.replace = 0;
                            lex.push("<hr/><p>This list of differences is not visible in the rendered HTML.</p><ul>");
                            do {
                                if (lexers[keys[a]] > 0) {
                                    lextest = true;
                                    lex.push(`<li>${keys[a]} - ${lexers[keys[a]]}</li>`);
                                }
                                a = a + 1;
                            } while (a < len);
                            lex.push("</ul>");
                        }
                        if (lextest === true) {
                            output.push(lex.join(""));
                        }
                        output.push("</div>");
                        options.parsed.token[body] = `${options.parsed.token[body]} ${output.join("")}`;
                    };
                    let diff_parsed, json, a = 0, count = [0, 0], len = 0, body = 0, head = false;
                    options.diff_format = "json";
                    options.parsed = prettydiff.sparser.parser();
                    options.source = options.parsed.token;
                    prettydiff.start = 0;
                    prettydiff.end = 0;
                    options.indent_level = ind;
                    prettydiff.sparser.options.source = options.diff;
                    diff_parsed = prettydiff.sparser.parser();
                    options.diff = diff_parsed.token;
                    diffoutput = prettydiff.api.diffview(options);
                    json = JSON.parse(diffoutput[0]).diff;
                    len = json.length;
                    do {
                        if (head === false && options.parsed.types[count[0]] === "start" && options.parsed.lexer[count[0]] === "markup" && json[a][1].toLowerCase().indexOf("<head") === 0) {
                            options.parsed.token[count[0]] = `${options.parsed.token[count[0]] + css.join(tab(3)) + tab(2)}</style>${tab(0)}`;
                            head = true;
                        }
                        else if (body < 1 && options.parsed.types[count[0]] === "start" && options.parsed.lexer[count[0]] === "markup" && options.parsed.token[count[0]].toLowerCase().indexOf("<body") === 0) {
                            body = count[0];
                        }
                        if (json[a][0] === "=") {
                            count[0] = count[0] + 1;
                            count[1] = count[1] + 1;
                        }
                        else if (body > 1 &&
                            options.parsed.lexer[count[0]] === "markup" &&
                            options.parsed.token[count[0]].indexOf(`<span class="prettydiff_`) !== 0 &&
                            ((json[a][0] === "+" && typeIgnore.indexOf(diff_parsed.types[count[1]]) < 0) || (json[a][0] !== "+" && typeIgnore.indexOf(options.parsed.types[count[0]]) < 0))) {
                            if (json[a][0] === "+") {
                                insert();
                            }
                            else {
                                del();
                            }
                        }
                        else {
                            if (json[a][0] === "-") {
                                count[0] = count[0] + 1;
                            }
                            else if (json[a][0] === "+") {
                                count[1] = count[1] + 1;
                            }
                            else {
                                count[0] = count[0] + 1;
                                count[1] = count[1] + 1;
                            }
                            if (lexers[options.parsed.lexer[count[0]]] === undefined) {
                                lexers[options.parsed.lexer[count[0]]] = 1;
                            }
                            else {
                                lexers[options.parsed.lexer[count[0]]] = lexers[options.parsed.lexer[count[0]]] + 1;
                            }
                        }
                        a = a + 1;
                    } while (a < len);
                    summary();
                    result = prettydiff.beautify.markup(options);
                }
                else {
                    options.parsed = prettydiff.sparser.parser();
                    options.source = prettydiff.beautify[options.lexer](options);
                    prettydiff.start = 0;
                    prettydiff.end = 0;
                    options.indent_level = ind;
                    // diff text formatting
                    prettydiff.sparser.options.source = options.diff;
                    options.parsed = prettydiff.sparser.parser();
                    options.diff = prettydiff.beautify[options.lexer](options);
                    // comparison
                    diffoutput = prettydiff.api.diffview(options);
                    result = diffoutput[0];
                }
            }
            if (diffmeta !== undefined) {
                diffmeta.differences = diffoutput[1];
                diffmeta.lines = diffoutput[2];
            }
        }
        else {
            options.parsed = prettydiff.sparser.parser();
            result = prettydiff[modeValue][options.lexer](options);
        }
    }
    if (options.new_line === true) {
        result = result.replace(/\s*$/, lf);
    }
    else {
        result = result.replace(/\s+$/, "");
    }
    if (options.complete_document === true && options.jsscope !== "report") {
        let finalFile = prettydiff.api.finalFile;
        finalFile.order[7] = options.color;
        finalFile.order[10] = result;
        if (options.crlf === true) {
            finalFile.order[12] = "\r\n";
            finalFile.order[15] = "\r\n";
        }
        if (options.mode === "diff") {
            finalFile.order[13] = finalFile.script.diff;
        }
        else if (options.mode === "beautify" && options.language === "javascript" && options.jsscope !== "none") {
            finalFile.order[13] = finalFile.script.beautify;
        }
        else {
            finalFile.order[13] = finalFile.script.minimal;
        }
        // escape changes characters that result in xml wellformedness errors
        prettydiff.end = 0;
        prettydiff.start = 0;
        return finalFile.order.join("");
    }
    prettydiff.end = 0;
    prettydiff.start = 0;
    return result;
};prettydiff.api={};prettydiff.beautify={};prettydiff.end=0;prettydiff.iterator=0;prettydiff.meta={error:"",lang:["","",""],time:"",insize:0,outsize:0,difftotal:0,difflines:0};prettydiff.minify={};prettydiff.options={"attribute_sort":false,"attribute_sort_list":"","brace_line":false,"brace_padding":false,"brace_style":"none","braces":false,"case_space":false,"color":"white","comment_line":false,"comments":false,"complete_document":false,"compressed_css":false,"conditional":false,"config":"","content":false,"correct":false,"crlf":false,"css_insert_lines":false,"diff":"","diff_comments":false,"diff_context":-1,"diff_format":"text","diff_label":"New Sample","diff_rendered_html":false,"diff_space_ignore":false,"diff_view":"sidebyside","else_line":false,"end_comma":"never","end_quietly":"default","force_attribute":false,"force_indent":false,"format_array":"default","format_object":"default","function_name":false,"help":80,"indent_char":" ","indent_level":0,"indent_size":4,"jsscope":"none","language":"auto","language_default":"text","language_name":"JavaScript","lexer":"auto","list_options":false,"method_chain":3,"minify_keep_comments":false,"minify_wrap":false,"mode":"diff","never_flatten":false,"new_line":false,"no_case_indent":false,"no_lead_zero":false,"no_semicolon":false,"node_error":false,"object_sort":false,"output":"","parse_format":"parallel","parse_space":false,"preserve":0,"preserve_comment":false,"preserve_text":false,"quote":false,"quote_convert":"none","read_method":"auto","selector_list":false,"semicolon":false,"source":"","source_label":"Source Sample","space":true,"space_close":false,"styleguide":"none","summary_only":false,"tag_merge":false,"tag_sort":false,"ternary_line":false,"top_comments":false,"unformatted":false,"variable_list":"none","version":false,"vertical":false,"wrap":0,"lexerOptions":{}};prettydiff.scopes=[];prettydiff.start=0;
    (function options_init() {
    
    const optionDef = {
        attribute_sort: {
            default: false,
            definition: "Alphanumerically sort markup attributes. Sorting is ignored if a given tag contains an attribute with instructions for a different language such as a template scheme, child markup tag, or start of a code structure.",
            label: "Sort Attributes",
            lexer: ["markup"],
            type: "boolean"
        },
        attribute_sort_list: {
            default: "",
            definition: "A comma separated list of attribute names. Attributes will be sorted according to this list and then alphanumerically. This option requires 'attribute_sort' have a value of true.",
            label: "Sort Attribute List",
            lexer: ["markup"],
            type: "string"
        },
        correct: {
            default: false,
            definition: "Automatically correct sloppiness in code. If false missing syntax will be included starting with 'x', such as 'x;' for missing simicolons.",
            label: "Correct",
            lexer: ["all"],
            type: "boolean"
        },
        crlf: {
            default: false,
            definition: "If line termination should be crlf (Windows) otherwise line termination is lf (Unix).",
            label: "CRLF",
            lexer: ["all"],
            type: "boolean"
        },
        end_comma: {
            default: "none",
            definition: "Whether terminal commas in objects and arrays should be added or eliminated.",
            label: "End Comma",
            lexer: ["script"],
            type: "string",
            values: {
                "always": "Adds terminal commas if they are missing.",
                "never": "Removes terminal commas if they are present.",
                "none": "Ignores this option."
            }
        },
        format: {
            default: "arrays",
            definition: "Defines the output format of the parser.",
            label: "Output Format",
            lexer: ["all"],
            type: "string",
            values: {
                "arrays": "The output format is an object of arrays such that the same index of all the arrays represents one data record, for example: {begin:[],ender:[],lexer:[],lines[],stack:[],token:[],types:[]}.",
                "csv": "The output format is comma separated value format.",
                "markdown": "Generates the output in a markdown table.",
                "minimal": "The output format is an array of arrays which is structurally similar to the objects format but without key names, for example: [[-1,-1,\"script\",0,\"global\",\"const\",\"word\"]].",
                "objects": "The output format is an array of objects such that each array index is one data record, for example: [{begin:-1,ender:-1,lexer:\"script\",lines:0,stack:\"global\",token:\"const\",types:\"word\"}]."
            }
        },
        language: {
            default: "auto",
            definition: "The language to parse.  The value auto will result in language auto detection.",
            label: "Language",
            lexer: ["all"],
            type: "string"
        },
        lexer: {
            default: "auto",
            definition: "The lexer used to perform the parsing.  The value auto will result in language auto detection.",
            label: "Lexer",
            lexer: ["all"],
            type: "string"
        },
        no_lead_zero: {
            default: false,
            definition: "Whether the zero to the left of the decimal point should be removed from numbers between 0 and 1.",
            label: "No Lead Zero",
            lexer: ["style"],
            type: "boolean"
        },
        object_sort: {
            default: false,
            definition: "Where style properties should be sorted by type and then alphabetically and whether script object properties should be sorted alphabetically.",
            label: "Object Sort",
            lexer: ["script", "style"],
            type: "boolean"
        },
        parse_space: {
            default: false,
            definition: "Whether white space should be parsed as content tokens.",
            label: "Parse Markup White Space",
            lexer: ["markup"],
            type: "boolean"
        },
        preserve_comment: {
            default: false,
            definition: "Whether comments should be ignored from manipulation, such as word wrap.",
            label: "Preserve Comment",
            lexer: ["all"],
            type: "boolean"
        },
        preserve_text: {
            default: false,
            definition: "Whether text content should be preserved from manipulation, such as word wrap.",
            label: "Preserve Text",
            lexer: ["markup"],
            type: "boolean"
        },
        quote_convert: {
            default: "none",
            definition: "If quote characters should be converted from single quotes to double quotes or the opposite. This option does take into account escaped quote characters.",
            label: "Quote Convert",
            lexer: ["markup", "script", "style"],
            type: "string",
            values: {
                "double": "Converts single quote characters to double quote characters.",
                "none": "Ignores this option.",
                "single": "Converts double quote characters to single quote characters."
            }
        },
        source: {
            default: "",
            definition: "The source code to parse.",
            label: "Source",
            lexer: ["all"],
            type: "string"
        },
        tag_merge: {
            default: false,
            definition: "If adjacent start and end tags in markup should be merged into one singleton tag.",
            label: "Tag Merge",
            lexer: ["markup"],
            type: "boolean"
        },
        tag_sort: {
            default: false,
            definition: "Whether markup tags should be alphabetically sorted amonst their siblings.",
            label: "Tag Sort",
            lexer: ["markup"],
            type: "boolean"
        },
        unformatted: {
            default: false,
            definition: "If tags in markup code should be preserved from any manner of alteration.",
            label: "Tag Unformatted",
            lexer: ["markup"],
            type: "boolean"
        },
        variable_list: {
            default: "none",
            definition: "Whether consecutive variable declarations should be separate statements or a comma separated list. Use of this option respects the different types of declarations: var, const, let.",
            label: "Variable List",
            lexer: ["script"],
            type: "string",
            values: {
                "each": "Separates variable declarations into separate statements.",
                "list": "Combines consecutive variable declaration statements into a single comma separated list.",
                "none": "Ignores this option."
            }
        },
        wrap: {
            default: 0,
            definition: "The character distance in which to apply word wrap. A value of less than 1 eliminates word wrap.",
            label: "Wrap",
            lexer: ["all"],
            type: "number"
        }
    };
    sparser.libs.optionDef = optionDef;
}());
(function language_init() {
    
    const language = {
        setlexer: function language_setlexer(input) {
            const langmap = {
                c_cpp: "script",
                coldfusion: "markup",
                csharp: "script",
                css: "style",
                csv: "csv",
                dustjs: "markup",
                ejs: "markup",
                go: "markup",
                handlebars: "markup",
                html: "markup",
                html_ruby: "markup",
                java: "script",
                javascript: "script",
                json: "script",
                jsp: "markup",
                jsx: "script",
                less: "style",
                markdown: "markdown",
                markup: "markup",
                php: "script",
                phphtml: "markup",
                qml: "style",
                scss: "style",
                silverstripe: "markup",
                "styled-jsx": "script",
                "styled-components": "script",
                swig: "markup",
                text: "text",
                titanium: "script",
                tss: "script",
                twig: "markup",
                typescript: "script",
                vapor: "markup",
                velocity: "markup",
                xhtml: "markup",
                xml: "markup"
            };
            if (typeof input !== "string") {
                return "script";
            }
            if (input.indexOf("html") > -1) {
                return "markup";
            }
            if (langmap[input] === undefined) {
                return "script";
            }
            return langmap[input];
        },
        nameproper: function language_nameproper(input) {
            const langmap = {
                c_cpp: "C++ (Not yet supported)",
                coldfusion: "ColdFusion",
                csharp: "C#",
                dustjs: "Dust.js",
                ejs: "EJS Template",
                elm: "Elm Template",
                go: "Go Lang Template",
                handlebars: "Handlebars Template",
                html_ruby: "ERB (Ruby) Template",
                java: "Java",
                javascript: "JavaScript",
                jsp: "JSTL (JSP)",
                jsx: "React JSX",
                liquid: "Liquid Template",
                markdown: "markdown",
                markup: "markup",
                phphtml: "HTML/PHP",
                scss: "SCSS",
                silverstripe: "SilverStripe",
                text: "Plain Text",
                titanium: "Titanium Stylesheets",
                tss: "Titanium Stylesheets",
                twig: "HTML TWIG Template",
                typescript: "TypeScript",
                vapor: "Vapor Leaf",
                velocity: "Apache Velocity",
                volt: "Volt Template"
            };
            if (typeof input !== "string" || langmap[input] === undefined) {
                return input.toUpperCase();
            }
            return langmap[input];
        },
        // * [0] = language value
        // * [1] = lexer value
        // * [2] = pretty formatting for text output to user
        auto: function language_auto(sample, defaultLang) {
            let b = [], c = 0;
            const vartest = ((/(((var)|(let)|(const)|(function)|(import))\s+(\w|\$)+[a-zA-Z0-9]*)/).test(sample) === true && (/@import/).test(sample) === false), finalstatic = (/((((final)|(public)|(private))\s+static)|(static\s+void))/).test(sample), output = function language_auto_output(langname) {
                if (langname === "unknown") {
                    return [defaultLang, language.setlexer(defaultLang), "unknown"];
                }
                if (langname === "xhtml" || langname === "markup") {
                    return ["xml", language.setlexer("xml"), "XHTML"];
                }
                if (langname === "tss") {
                    return ["tss", language.setlexer("tss"), "Titanium Stylesheets"];
                }
                if (langname === "phphtml") {
                    return ["php", language.setlexer(langname), language.nameproper(langname)];
                }
                return [langname, language.setlexer(langname), language.nameproper(langname)];
            }, cssA = function language_auto_cssA() {
                if ((/\n\s*#+\s+/).test(sample) === true || (/^#+\s+/).test(sample) === true) {
                    return output("markdown");
                }
                if ((/\$[a-zA-Z]/).test(sample) === true || (/\{\s*(\w|\.|\$|#)+\s*\{/).test(sample) === true) {
                    return output("scss");
                }
                if ((/@[a-zA-Z]/).test(sample) === true || (/\{\s*(\w|\.|@|#)+\s*\{/).test(sample) === true) {
                    return output("less");
                }
                return output("css");
            }, notmarkup = function language_auto_notmarkup() {
                let d = 1, join = "", flaga = false, flagb = false;
                const publicprivate = (/((public)|(private))\s+(static\s+)?(((v|V)oid)|(class)|(final))/).test(sample), javascriptA = function language_auto_notmarkup_javascriptA() {
                    if (sample.indexOf("(") > -1 || sample.indexOf("=") > -1 || (sample.indexOf(";") > -1 && sample.indexOf("{") > -1)) {
                        if (vartest === false && ((/\n\s+#region\s/).test(sample) === true || (/\[\w+:/).test(sample) === true)) {
                            return output("csharp");
                        }
                        if (finalstatic === true || (/\w<\w+(,\s+\w+)*>/).test(sample) === true) {
                            if ((/:\s*((number)|(string))/).test(sample) === false && (finalstatic === true || publicprivate === true)) {
                                return output("java");
                            }
                            return output("typescript");
                        }
                        if ((/final\s+static/).test(sample) === true) {
                            return output("java");
                        }
                        if ((/<\/\w+>/).test(sample) === true && (/<\w+((\s+\w)|>)/).test(sample) === true) {
                            return output("jsx");
                        }
                        if ((/((var)|(let)|(const))\s+\w+\s*:/).test(sample) === true || (/=\s*<\w+/).test(sample) === true) {
                            return output("typescript");
                        }
                        return output("javascript");
                    }
                    return output("unknown");
                }, cssOrJavaScript = function language_auto_notmarkup_cssOrJavaScript() {
                    if ((/:\s*((number)|(string))/).test(sample) === true && (/((public)|(private))\s+/).test(sample) === true) {
                        return output("typescript");
                    }
                    if ((/import\s+java(\.|(fx))/).test(sample) === true || (/((public)|(private))\s+static\s+/).test(sample) === true) {
                        return output("java");
                    }
                    if ((/\sclass\s+\w/).test(sample) === false && (/<[a-zA-Z]/).test(sample) === true && (/<\/[a-zA-Z]/).test(sample) === true && ((/\s?\{%/).test(sample) === true || (/\{(\{|#)(?!(\{|#|=))/).test(sample) === true)) {
                        return output("twig");
                    }
                    if ((/^(\s*(\$|@))/).test(sample) === false && (/(\};?\s*)$/).test(sample) === true) {
                        if ((/export\s+default\s+\{/).test(sample) === true || (/(\?|:)\s*(\{|\[)/).test(sample) === true || (/(\{|\s|;)render\s*\(\)\s*\{/).test(sample) === true || (/^(\s*return;?\s*\{)/).test(sample) === true) {
                            return output("javascript");
                        }
                    }
                    if ((/\{\{#/).test(sample) === true && (/\{\{\//).test(sample) === true && (/<\w/).test(sample) === true) {
                        return output("handlebars");
                    }
                    if ((/\{\s*(\w|\.|@|#)+\s*\{/).test(sample) === true) {
                        return output("less");
                    }
                    if ((/\$(\w|-)/).test(sample) === true) {
                        return output("scss");
                    }
                    if ((/(;|\{|:)\s*@\w/).test(sample) === true) {
                        return output("less");
                    }
                    if ((/class\s+\w+\s+\{/).test(sample) === true) {
                        return output("java");
                    }
                    return output("css");
                };
                if (d < c) {
                    do {
                        if (flaga === false) {
                            if (b[d] === "*" && b[d - 1] === "/") {
                                b[d - 1] = "";
                                flaga = true;
                            }
                            else if (flagb === false && b[d] === "f" && d < c - 6 && b[d + 1] === "i" && b[d + 2] === "l" && b[d + 3] === "t" && b[d + 4] === "e" && b[d + 5] === "r" && b[d + 6] === ":") {
                                flagb = true;
                            }
                        }
                        else if (flaga === true && b[d] === "*" && d !== c - 1 && b[d + 1] === "/") {
                            flaga = false;
                            b[d] = "";
                            b[d + 1] = "";
                        }
                        else if (flagb === true && b[d] === ";") {
                            flagb = false;
                            b[d] = "";
                        }
                        if (flaga === true || flagb === true) {
                            b[d] = "";
                        }
                        d = d + 1;
                    } while (d < c);
                }
                join = b.join("");
                if ((/\s\/\//).test(sample) === false && (/\/\/\s/).test(sample) === false && (/^(\s*(\{|\[)(?!%))/).test(sample) === true && (/((\]|\})\s*)$/).test(sample) && sample.indexOf(",") !== -1) {
                    return output("json");
                }
                if ((/((\}?(\(\))?\)*;?\s*)|([a-z0-9]("|')?\)*);?(\s*\})*)$/i).test(sample) === true && (vartest === true || publicprivate === true || (/console\.log\(/).test(sample) === true || (/export\s+default\s+class\s+/).test(sample) === true || (/document\.get/).test(sample) === true || (/((=|(\$\())\s*function)|(\s*function\s+(\w*\s+)?\()/).test(sample) === true || sample.indexOf("{") === -1 || (/^(\s*if\s+\()/).test(sample) === true)) {
                    return javascriptA();
                }
                // * u007b === {
                // * u0024 === $
                // * u002e === .
                if (sample.indexOf("{") > -1 && ((/^(\s*[\u007b\u0024\u002e#@a-z0-9])/i).test(sample) === true || (/^(\s*\/(\*|\/))/).test(sample) === true || (/^(\s*\*\s*\{)/).test(sample) === true) && (/^(\s*if\s*\()/).test(sample) === false && (/=\s*(\{|\[|\()/).test(join) === false && (((/(\+|-|=|\?)=/).test(join) === false || (/\/\/\s*=+/).test(join) === true) || ((/=+('|")?\)/).test(sample) === true && (/;\s*base64/).test(sample) === true)) && (/function(\s+\w+)*\s*\(/).test(join) === false) {
                    if ((/\s*#((include)|(define)|(endif))\s+/).test(sample)) {
                        return output("c_cpp");
                    }
                    return cssOrJavaScript();
                }
                if ((/"\s*:\s*\{/).test(sample) === true) {
                    return output("tss");
                }
                if (sample.indexOf("{%") > -1) {
                    return output("twig");
                }
                return output("unknown");
            }, markup = function language_auto_markup() {
                const html = function language_auto_markup_html() {
                    if ((/<%\s*\}/).test(sample) === true) {
                        return output("ejs");
                    }
                    if ((/<%\s+end_((if)|(with)|(loop)|(control)|(cached)|(uncached))/).test(sample) === true) {
                        return output("silverstripe");
                    }
                    if ((/<%\s*end/).test(sample) === true) {
                        return output("html_ruby");
                    }
                    if ((/\{\{(#|\/|\{)/).test(sample) === true) {
                        return output("handlebars");
                    }
                    if ((/\{\{end\}\}/).test(sample) === true) {
                        //place holder for Go lang templates
                        return output("html");
                    }
                    if ((/\s?\{%/).test(sample) === true && (/\{(\{|#)(?!(\{|#|=))/).test(sample) === true) {
                        return output("twig");
                    }
                    if ((/<\?/).test(sample) === true) {
                        if ((/^\s*<\?/).test(sample) === true && (/\?>\s*$/).test(sample) === true) {
                            return output("php");
                        }
                        return output("phphtml");
                    }
                    if ((/<jsp:include\s/).test(sample) === true || (/<c:((set)|(if))\s/).test(sample) === true) {
                        return output("jsp");
                    }
                    if ((/\{(#|\?|\^|@|<|\+|~)/).test(sample) === true && (/\{\//).test(sample) === true && sample.indexOf("<![CDATA[") < 0) {
                        return output("dustjs");
                    }
                    if ((/#((if)|(for)|(set))?\(/).test(sample) === true) {
                        return output("vapor");
                    }
                    return output("html");
                };
                if ((/<cfset\s/i).test(sample) === true || (/<cfif\s/i).test(sample) === true) {
                    return output("coldfusion");
                }
                if ((/^(\s*<!doctype\s+html>)/i).test(sample) === true ||
                    (/^(\s*<html)/i).test(sample) === true ||
                    ((/<form\s/i).test(sample) === true &&
                        (/<label\s/i).test(sample) === true &&
                        (/<input\s/i).test(sample) === true) ||
                    (/<((img)|(IMG))(\s+\w+=("|')?\S+("|')?)*\s+src\s*=/).test(sample) === true ||
                    ((/^(\s*<!DOCTYPE\s+((html)|(HTML))\s+PUBLIC\s+)/).test(sample) === true &&
                        (/XHTML\s+1\.1/).test(sample) === false &&
                        (/XHTML\s+1\.0\s+(S|s)((trict)|(TRICT))/).test(sample) === false)) {
                    return html();
                }
                if ((/<jsp:include\s/).test(sample) === true || (/<c:((set)|(if))\s/).test(sample) === true) {
                    return output("jsp");
                }
                if ((/<%\s*\}/).test(sample) === true) {
                    return output("ejs");
                }
                if ((/<%\s+end_((if)|(with)|(loop)|(control)|(cached)|(uncached))/).test(sample) === true) {
                    return output("silverstripe");
                }
                if ((/<%\s*end/).test(sample) === true) {
                    return output("html_ruby");
                }
                if ((/\{\{(#|\/|\{)/).test(sample) === true) {
                    return output("handlebars");
                }
                if ((/\{\{end\}\}/).test(sample) === true) {
                    //place holder for Go lang templates
                    return output("xml");
                }
                if ((/\s?\{%/).test(sample) === true && (/\{\{(?!(\{|#|=))/).test(sample) === true) {
                    return output("twig");
                }
                if ((/<\?(?!(xml))/).test(sample) === true) {
                    if ((/^\s*<\?/).test(sample) === true && (/\?>\s*$/).test(sample) === true) {
                        return output("php");
                    }
                    return output("phphtml");
                }
                if ((/\{(#|\?|\^|@|<|\+|~)/).test(sample) === true && (/\{\//).test(sample) === true) {
                    return output("dustjs");
                }
                if ((/<jsp:include\s/).test(sample) === true || (/<c:((set)|(if))\s/).test(sample) === true) {
                    return output("jsp");
                }
                if ((/#((if)|(for)|(set))?\(/).test(sample) === true) {
                    return output("vapor");
                }
                return output("xml");
            };
            if (sample === null || sample.replace(/\s+/g, "") === "") {
                return output("unknown");
            }
            if (((/\n\s*#{1,6}\s+/).test(sample) === true || ((/\n\s*(\*|-|(\d+\.))\s/).test(sample) === true) && (/\/\*/).test(sample) === false) &&
                ((/\[( |x|X)\]/).test(sample) === true || (/\s\*\*?\S\D/).test(sample) === true || (/\n\s*```/).test(sample) === true || ((/-+\|(-+\|)+/).test(sample) === true && (/<!--/).test(sample) === false))) {
                return output("markdown");
            }
            if ((/^(\s*<!DOCTYPE\s+html>)/i).test(sample) === true) {
                return markup();
            }
            if ((/^\s*@((charset)|(import)|(include)|(keyframes)|(media)|(namespace)|(page))/).test(sample) === true) {
                return cssA();
            }
            if (finalstatic === false &&
                (/=(>|=|-|\+|\*)/).test(sample) === false &&
                (/^(\s*((if)|(for)|(function))\s*\()/).test(sample) === false &&
                (/(\s|;|\})((if)|(for)|(function\s*\w*))\s*\(/).test(sample) === false &&
                vartest === false && (/return\s*\w*\s*(;|\})/).test(sample) === false &&
                (sample === undefined ||
                    (/^(\s*#(?!(!\/)))/).test(sample) === true ||
                    ((/\n\s*(\.|@)\w+(\(|(\s*:))/).test(sample) === true && (/>\s*<\w/).test(sample) === false))) {
                return cssA();
            }
            b = sample
                .replace(/\[[a-zA-Z][\w-]*=("|')?[a-zA-Z][\w-]*("|')?\]/g, "")
                .split("");
            c = b.length;
            if ((/^(\s*(\{|<)(%|#|\{))/).test(sample) === true) {
                return markup();
            }
            if (((/^([\s\w-]*<)/).test(sample) === false && (/(>[\s\w-]*)$/).test(sample) === false) || finalstatic === true) {
                return notmarkup();
            }
            if ((((/(>[\w\s:]*)?<(\/|!|#)?[\w\s:\-[]+/).test(sample) === true || ((/^\s*</).test(sample) === true && (/<\/\w+(\w|\d)+>\s*$/).test(sample) === true) || (/^(\s*<\?xml)/).test(sample) === true) && ((/^([\s\w]*<)/).test(sample) === true || (/(>[\s\w]*)$/).test(sample) === true)) || ((/^(\s*<s((cript)|(tyle)))/i).test(sample) === true && (/(<\/s((cript)|(tyle))>\s*)$/i).test(sample) === true)) {
                if ((/^([\s\w]*<)/).test(sample) === false || (/(>[\s\w]*)$/).test(sample) === false) {
                    return notmarkup();
                }
                return markup();
            }
            return output("unknown");
        }
    };sparser.libs.language=language;prettydiff.api.language=language;
}());
(function style_init() {
    
    const style = function lexer_style(source) {
        let a = 0, ltype = "", ltoke = "";
        const parse = sparser.parse, data = parse.data, options = sparser.options, b = source.split(""), len = source.length, mapper = [], nosort = [], recordPush = function lexer_style_recordPush(structure) {
            const record = {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "style",
                lines: parse.linesSpace,
                stack: parse.structure[parse.structure.length - 1][0],
                token: ltoke,
                types: ltype
            };
            parse.push(data, record, structure);
        }, esctest = function lexer_style_esctest(index) {
            const slashy = index;
            do {
                index = index - 1;
            } while (b[index] === "\\" && index > 0);
            if ((slashy - index) % 2 === 1) {
                return true;
            }
            return false;
        }, 
        // Since I am already identifying value types this is a good place to do some
        // quick analysis and clean up on certain value conditions. These things are
        // being corrected:
        // * fractional values missing a leading 0 are    provided a leading 0
        // * 0 values with a dimension indicator    (px, em) have the dimension
        // indicator    removed
        // * eliminate unnecessary leading 0s
        // * url values that are not quoted are wrapped    in double quote characters
        // * color values are set to lowercase and    reduced from 6 to 3 digits if
        // appropriate
        value = function lexer_style_value(val) {
            const x = val.replace(/\s*!important/, " !important").split(""), values = [], transition = (/-?transition$/).test(data.token[parse.count - 2]), colorPush = function lexer_style_value_colorPush(value) {
                const vl = value.toLowerCase();
                if ((/^(#[0-9a-f]{3,6})$/).test(vl) === true) ;
                else if ((/^(rgba?\()/).test(vl) === true) ;
                else ;
                return value;
            }, valueSpace = function lexer_style_value_valueSpace(find) {
                find = find.replace(/\s*/g, "");
                if ((/\/\d/).test(find) === true && val.indexOf("url(") === 0) {
                    return find;
                }
                return ` ${find.charAt(0)} ${find.charAt(1)}`;
            }, zerofix = function lexer_style_value_zerofix(find) {
                if (options.lexer_options.style.no_lead_zero === true) {
                    const scrub = function lexer_style_value_zerofix_scrub(search) {
                        return search.replace(/0+/, "");
                    };
                    return find.replace(/^-?\D0+(\.|\d)/, scrub);
                }
                if ((/0*\./).test(find) === true) {
                    return find.replace(/0*\./, "0.");
                }
                if ((/0+/).test((/\d+/).exec(find)[0]) === true) {
                    if ((/^\D*0+\D*$/).test(find) === true) {
                        return find.replace(/0+/, "0");
                    }
                    return find.replace((/\d+/).exec(find)[0], (/\d+/).exec(find)[0].replace(/^0+/, ""));
                }
                return find;
            }, commaspace = function lexer_style_value_commaspace(find) {
                return find.replace(",", ", ");
            }, diFix = function lexer_style_value_diFix(di) {
                return `${di} `;
            }, slash = function lexer_style_value_slash() {
                const start = cc - 1;
                let xx = start;
                if (start < 1) {
                    return true;
                }
                do {
                    xx = xx - 1;
                } while (xx > 0 && x[xx] === "\\");
                // report true for odd numbers (escaped)
                if ((start - xx) % 2 === 1) {
                    return true;
                }
                return false;
            }, zerodotstart = (/^-?0+\.\d+[a-z]/), dotstart = (/^-?\.\d+[a-z]/), zerodot = (/(\s|\(|,)-?0+\.?\d+([a-z]|\)|,|\s)/g), dot = (/(\s|\(|,)-?\.?\d+([a-z]|\)|,|\s)/g), dimensions = "%|cap|ch|cm|deg|dpcm|dpi|dppx|em|ex|fr|grad|Hz|ic|in|kHz|lh|mm|ms|mS|pc|pt|px|Q|rad|rem|rlh|s|turn|vb|vh|vi|vmax|vmin|vw";
            let cc = 0, dd = 0, block = "", leng = x.length, items = [];
            // this loop identifies containment so that tokens/sub-tokens are correctly
            // taken
            if (cc < leng) {
                do {
                    items.push(x[cc]);
                    if (x[cc - 1] !== "\\" || slash() === false) {
                        if (block === "") {
                            if (x[cc] === "\"") {
                                block = "\"";
                                dd = dd + 1;
                            }
                            else if (x[cc] === "'") {
                                block = "'";
                                dd = dd + 1;
                            }
                            else if (x[cc] === "(") {
                                block = ")";
                                dd = dd + 1;
                            }
                            else if (x[cc] === "[") {
                                block = "]";
                                dd = dd + 1;
                            }
                        }
                        else if ((x[cc] === "(" && block === ")") || (x[cc] === "[" && block === "]")) {
                            dd = dd + 1;
                        }
                        else if (x[cc] === block) {
                            dd = dd - 1;
                            if (dd === 0) {
                                block = "";
                            }
                        }
                    }
                    if (block === "" && x[cc] === " ") {
                        items.pop();
                        values.push(colorPush(items.join("")));
                        items = [];
                    }
                    cc = cc + 1;
                } while (cc < leng);
            }
            values.push(colorPush(items.join("")));
            leng = values.length;
            //This is where the rules mentioned above are applied
            cc = 0;
            if (cc < leng) {
                do {
                    if (options.lexer_options.style.no_lead_zero === true && zerodotstart.test(values[cc]) === true) {
                        values[cc] = values[cc].replace(/0+\./, ".");
                    }
                    else if ((options.lexer_options.style.no_lead_zero === false || options.lexer_options.style.no_lead_zero === undefined) && dotstart.test(values[cc]) === true) {
                        values[cc] = values[cc].replace(".", "0.");
                    }
                    else if (zerodot.test(values[cc]) === true || dot.test(values[cc]) === true) {
                        values[cc] = values[cc].replace(zerodot, zerofix).replace(dot, zerofix);
                    }
                    else if ((/^(0+([a-z]{2,3}|%))$/).test(values[cc]) === true && transition === false) {
                        values[cc] = "0";
                    }
                    else if ((/^(0+)/).test(values[cc]) === true) {
                        values[cc] = values[cc].replace(/0+/, "0");
                        if ((/\d/).test(values[cc].charAt(1)) === true) {
                            values[cc] = values[cc].substr(1);
                        }
                    }
                    else if ((/^url\((?!('|"))/).test(values[cc]) === true && values[cc].charAt(values[cc].length - 1) === ")") {
                        block = values[cc].charAt(values[cc].indexOf("url(") + 4);
                        if (block !== "@" && block !== "{" && block !== "<") {
                            if (options.lexer_options.style.quote_convert === "double") {
                                values[cc] = values[cc]
                                    .replace(/url\(/, "url(\"")
                                    .replace(/\)$/, "\")");
                            }
                            else {
                                values[cc] = values[cc]
                                    .replace(/url\(/, "url('")
                                    .replace(/\)$/, "')");
                            }
                        }
                    }
                    if ((/^(\+|-)?\d+(\.\d+)?(e-?\d+)?\D+$/).test(values[cc]) === true) {
                        if (dimensions.indexOf(values[cc].replace(/(\+|-)?\d+(\.\d+)?(e-?\d+)?/, "")) < 0) {
                            values[cc] = values[cc].replace(/(\+|-)?\d+(\.\d+)?(e-?\d+)?/, diFix);
                        }
                    }
                    if ((/^\w+\(/).test(values[cc]) === true &&
                        values[cc].charAt(values[cc].length - 1) === ")" &&
                        (values[cc].indexOf("url(") !== 0 || (values[cc].indexOf("url(") === 0 && values[cc].indexOf(" ") > 0))) {
                        values[cc] = values[cc].replace(/,\S/g, commaspace);
                    }
                    cc = cc + 1;
                } while (cc < leng);
            }
            block = values.join(" ");
            return block.charAt(0) + block.slice(1)
                .replace(/\s*(\/|\+|\*)\s*(\d|\$)/, valueSpace);
        }, 
        //the generic token builder
        buildtoken = function lexer_style_build() {
            let aa = a, bb = 0, out = [], outy = "", funk = null;
            const block = [], qc = (options.lexer_options.style.quote_convert === undefined)
                ? "none"
                : options.lexer_options.style.quote_convert, spacestart = function lexer_style_build_spacestart() {
                out.push(b[aa]);
                if ((/\s/).test(b[aa + 1]) === true) {
                    do {
                        aa = aa + 1;
                    } while (aa < len && (/\s/).test(b[aa + 1]) === true);
                }
            };
            if (aa < len) {
                //this loop accounts for grouping mechanisms
                do {
                    if (b[aa] === "\"" || b[aa] === "'") {
                        if (funk === null) {
                            funk = false;
                        }
                        if (block[block.length - 1] === b[aa] && (b[aa - 1] !== "\\" || esctest(aa - 1) === false)) {
                            block.pop();
                            if (qc === "double") {
                                b[aa] = "\"";
                            }
                            else if (qc === "single") {
                                b[aa] = "'";
                            }
                        }
                        else if (block[block.length - 1] !== "\"" && block[block.length - 1] !== "'" && (b[aa - 1] !== "\\" || esctest(aa - 1) === false)) {
                            block.push(b[aa]);
                            if (qc === "double") {
                                b[aa] = "\"";
                            }
                            else if (qc === "single") {
                                b[aa] = "'";
                            }
                        }
                        else if (b[aa - 1] === "\\" && qc !== "none") {
                            if (esctest(aa - 1) === true) {
                                if (qc === "double" && b[aa] === "'") {
                                    out.pop();
                                }
                                else if (qc === "single" && b[aa] === "\"") {
                                    out.pop();
                                }
                            }
                        }
                        else if (qc === "double" && b[aa] === "\"") {
                            b[aa] = "\\\"";
                        }
                        else if (qc === "single" && b[aa] === "'") {
                            b[aa] = "\\'";
                        }
                        out.push(b[aa]);
                    }
                    else if (b[aa - 1] !== "\\" || esctest(aa - 1) === false) {
                        if (b[aa] === "(") {
                            if (funk === null) {
                                funk = true;
                            }
                            block.push(")");
                            spacestart();
                        }
                        else if (b[aa] === "[") {
                            funk = false;
                            block.push("]");
                            spacestart();
                        }
                        else if ((b[aa] === "#" || b[aa] === "@") && b[aa + 1] === "{") {
                            funk = false;
                            out.push(b[aa]);
                            aa = aa + 1;
                            block.push("}");
                            spacestart();
                        }
                        else if (b[aa] === block[block.length - 1]) {
                            out.push(b[aa]);
                            block.pop();
                        }
                        else {
                            out.push(b[aa]);
                        }
                    }
                    else {
                        out.push(b[aa]);
                    }
                    if (parse.structure[parse.structure.length - 1][0] === "map" && block.length === 0 && (b[aa + 1] === "," || b[aa + 1] === ")")) {
                        if (b[aa + 1] === ")" && data.token[parse.count] === "(") {
                            parse.pop(data);
                            parse.structure.pop();
                            out.splice(0, 0, "(");
                        }
                        else {
                            break;
                        }
                    }
                    if (b[aa + 1] === ":") {
                        bb = aa;
                        if ((/\s/).test(b[bb]) === true) {
                            do {
                                bb = bb - 1;
                            } while ((/\s/).test(b[bb]) === true);
                        }
                        outy = b
                            .slice(bb - 6, bb + 1)
                            .join("");
                        if (outy.indexOf("filter") === outy.length - 6 || outy.indexOf("progid") === outy.length - 6) {
                            outy = "filter";
                        }
                    }
                    if (block.length === 0) {
                        if ((b[aa + 1] === ";" && esctest(aa + 1) === true) ||
                            (b[aa + 1] === ":" &&
                                b[aa] !== ":" &&
                                b[aa + 2] !== ":" &&
                                outy !== "filter" &&
                                outy !== "progid") ||
                            b[aa + 1] === "}" ||
                            b[aa + 1] === "{" ||
                            (b[aa + 1] === "/" && (b[aa + 2] === "*" || b[aa + 2] === "/"))) {
                            bb = out.length - 1;
                            if ((/\s/).test(out[bb]) === true) {
                                do {
                                    bb = bb - 1;
                                    aa = aa - 1;
                                    out.pop();
                                } while ((/\s/).test(out[bb]) === true);
                            }
                            break;
                        }
                        if (b[aa + 1] === ",") {
                            break;
                        }
                    }
                    aa = aa + 1;
                } while (aa < len);
            }
            a = aa;
            if (parse.structure[parse.structure.length - 1][0] === "map" && out[0] === "(") {
                mapper[mapper.length - 1] = mapper[mapper.length - 1] - 1;
            }
            ltoke = out
                .join("")
                .replace(/\s+/g, " ")
                .replace(/^\s/, "")
                .replace(/\s$/, "");
            if (funk === true) {
                ltoke = ltoke.replace(/\s+\(/g, "(").replace(/\s+\)/g, ")").replace(/,\(/g, ", (");
            }
            if (parse.count > -1 && data.token[parse.count].indexOf("extend(") === 0) {
                ltype = "pseudo";
            }
            else if (funk === true &&
                (/\d/).test(ltoke.charAt(0)) === false &&
                (/^rgba?\(/).test(ltoke) === false &&
                ltoke.indexOf("url(") !== 0 &&
                (ltoke.indexOf(" ") < 0 || ltoke.indexOf(" ") > ltoke.indexOf("(")) &&
                ltoke.charAt(ltoke.length - 1) === ")") {
                if (data.token[parse.count] === ":") {
                    ltype = "value";
                }
                else {
                    ltoke = ltoke.replace(/,\u0020?/g, ", ");
                    ltype = "function";
                }
                ltoke = value(ltoke);
            }
            else if (parse.count > -1 && "\"'".indexOf(data.token[parse.count].charAt(0)) > -1 && data.types[parse.count] === "variable") {
                ltype = "item";
            }
            else if (out[0] === "@" || out[0] === "$") {
                if (data.types[parse.count] === "colon" && options.language === "css" && (data.types[parse.count - 1] === "property" || data.types[parse.count - 1] === "variable")) {
                    ltype = "value";
                }
                else if (parse.count > -1) {
                    ltype = "item";
                    outy = data.token[parse.count];
                    aa = outy.indexOf("(");
                    if (outy.charAt(outy.length - 1) === ")" && aa > 0) {
                        outy = outy.slice(aa + 1, outy.length - 1);
                        data.token[parse.count] = data
                            .token[parse.count]
                            .slice(0, aa + 1) + value(outy) + ")";
                    }
                }
                ltoke = value(ltoke);
            }
            else {
                ltype = "item";
            }
            recordPush("");
        }, 
        // Some tokens receive a generic type named 'item' because their type is unknown
        // until we know the following syntax.  This function replaces the type 'item'
        // with something more specific.
        item = function lexer_style_item(type) {
            let aa = parse.count, bb = 0, first = "";
            const comsa = [], priors = function lexer_style_item_priors() {
                //backtrack through immediately prior comments to find the correct token
                if (data.types[aa] === "comment" || data.types[aa] === "ignore") {
                    do {
                        aa = aa - 1;
                        comsa.push(data.token[aa]);
                    } while (aa > 0 && data.lexer[aa] === "style" && (data.types[aa] === "comment" || data.types[aa] === "ignore"));
                }
                bb = aa - 1;
                if (data.types[bb] === "comment" || data.types[bb] === "ignore") {
                    do {
                        bb = bb - 1;
                    } while (bb > 0 && data.lexer[aa] === "style" && (data.types[bb] === "comment" || data.types[bb] === "ignore"));
                }
                first = data.token[aa].charAt(0);
            }, selectorPretty = function lexer_style_item_selectorPretty(index) {
                let cc = index, dd = data.begin[cc];
                data.token[index] = data.token[index]
                    .replace(/\s*&/, " &")
                    .replace(/(\s*>\s*)/g, " > ")
                    .replace(/:\s+/g, ": ")
                    .replace(/^(\s+)/, "")
                    .replace(/(\s+)$/, "")
                    .replace(/\s+::\s+/, "::");
                if (data.token[cc - 1] === "," || data.token[cc - 1] === ":" || data.types[cc - 1] === "comment") {
                    do {
                        cc = cc - 1;
                        if (data.begin[cc] === dd) {
                            if (data.token[cc] === ";") {
                                break;
                            }
                            if (data.token[cc] !== "," && data.types[cc] !== "comment") {
                                data.types[cc] = "selector";
                            }
                            if (data.token[cc] === ":") {
                                data.token[cc - 1] = `${data.token[cc - 1]}:${data.token[cc + 1]}`;
                                parse.splice({
                                    data: data,
                                    howmany: 2,
                                    index: cc
                                });
                            }
                        }
                        else {
                            break;
                        }
                    } while (cc > 0);
                }
                // sorts comma separated lists of selectors
                cc = parse.count;
                if (options.lexer_options.style.object_sort === true && data.token[cc - 1] === ",") {
                    const store = [data.token[cc]];
                    do {
                        cc = cc - 1;
                        if (data.types[cc] === "comment" || data.types[cc] === "ignore") {
                            do {
                                cc = cc - 1;
                            } while (cc > 0 && (data.types[cc] === "comment" || data.types[cc] === "ignore"));
                        }
                        if (data.token[cc] === ",") {
                            cc = cc - 1;
                        }
                        store.push(data.token[cc]);
                    } while (cc > 0 && (data.token[cc - 1] === "," || data.types[cc - 1] === "selector" || data.types[cc - 1] === "comment" || data.types[cc - 1] === "ignore"));
                    store.sort();
                    cc = parse.count;
                    data.token[cc] = store.pop();
                    do {
                        cc = cc - 1;
                        if (data.types[cc] === "comment" || data.types[cc] === "ignore") {
                            do {
                                cc = cc - 1;
                            } while (cc > 0 && (data.types[cc] === "comment" || data.types[cc] === "ignore"));
                        }
                        if (data.token[cc] === ",") {
                            cc = cc - 1;
                        }
                        data.token[cc] = store.pop();
                    } while (cc > 0 && (data.token[cc - 1] === "," || data.token[cc - 1] === "selector" || data.types[cc - 1] === "comment" || data.types[cc - 1] === "ignore"));
                }
                aa = parse.count;
                priors();
            };
            priors();
            //if the last non-comment type is 'item' then id it
            if (type === "start" && (data.types[aa] === "value" || data.types[aa] === "variable")) {
                data.types[aa] = "item";
            }
            if (data.lexer[parse.count - 1] !== "style" || bb < 0) {
                if (type === "colon") {
                    if (first === "$" || first === "@") {
                        data.types[aa] = "variable";
                    }
                    else {
                        data.types[aa] = "property";
                    }
                }
                else if (data.lexer[aa] === "style") {
                    data.types[aa] = "selector";
                    selectorPretty(aa);
                }
            }
            else if (type === "start" && data.types[aa] === "function" && data.lexer[aa] === "style") {
                data.types[aa] = "selector";
                selectorPretty(aa);
            }
            else if (data.types[aa] === "item" && data.lexer[aa] === "style") {
                if (type === "start") {
                    selectorPretty(aa);
                    data.types[aa] = "selector";
                    if (data.token[aa] === ":") {
                        data.types[bb] = "selector";
                    }
                    if (data.token[aa].indexOf("=\u201c") > 0) {
                        sparser.parseerror = `Quote looking character (\u201c, \\201c) used instead of actual quotes on line number ${parse.lineNumber}`;
                    }
                    else if (data.token[aa].indexOf("=\u201d") > 0) {
                        sparser.parseerror = `Quote looking character (\u201d, \\201d) used instead of actual quotes on line number ${parse.lineNumber}`;
                    }
                }
                else if (type === "end") {
                    if (first === "$" || first === "@") {
                        data.types[aa] = "variable";
                    }
                    else {
                        data.types[aa] = "value";
                    }
                    data.token[aa] = value(data.token[aa]);
                }
                else if (type === "separator") {
                    if (data.types[bb] === "colon" || data.token[bb] === "," || data.token[bb] === "{") {
                        if (b[a] !== ";" && (data.types[bb] === "selector" || data.token[bb] === "{")) {
                            data.types[aa] = "selector";
                            selectorPretty(aa);
                        }
                        else if (data.token[aa].charAt(0) === "$" || data.token[aa].charAt(0) === "@") {
                            data.types[aa] = "variable";
                        }
                        else {
                            data.types[aa] = "value";
                        }
                        data.token[aa] = value(data.token[aa]);
                        if (data.token[aa].charAt(0) === "\u201c") {
                            sparser.parseerror = `Quote looking character (\u201c, \\201c) used instead of actual quotes on line number ${parse.lineNumber}`;
                        }
                        else if (data.token[aa].charAt(0) === "\u201d") {
                            sparser.parseerror = `Quote looking character (\u201d, \\201d) used instead of actual quotes on line number ${parse.lineNumber}`;
                        }
                    }
                    else {
                        if (first === "$" || first === "@") {
                            data.types[aa] = "variable";
                        }
                        else if (data.types[bb] === "value" || data.types[bb] === "variable") {
                            data.token[bb] = data.token[bb] + data.token[aa];
                            parse.pop(data);
                        }
                        else {
                            data.types[aa] = "value";
                        }
                    }
                }
                else if (type === "colon") {
                    if (first === "$" || first === "@") {
                        data.types[aa] = "variable";
                    }
                    else {
                        data.types[aa] = "property";
                    }
                }
                else if (data.token[bb].charAt(0) === "@" && ((data.types[bb - 2] !== "variable" && data.types[bb - 2] !== "property") || data.types[bb - 1] === "separator")) {
                    data.types[bb] = "variable";
                    ltype = "variable";
                    data.token[bb] = value(data.token[bb]);
                }
            }
        }, semiComment = function lexer_style_separatorComment() {
            let x = parse.count;
            do {
                x = x - 1;
            } while (x > 0 && (data.types[x] === "comment"));
            if (data.token[x] === ";") {
                return;
            }
            parse.splice({
                data: data,
                howmany: 0,
                index: x + 1,
                record: {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "style",
                    lines: parse.linesSpace,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: ";",
                    types: "separator"
                }
            });
        }, template = function lexer_style_template(open, end) {
            let quote = "", name = "", start = open.length, endlen = 0;
            const store = [], exit = function lexer_style_template_exit(typename) {
                const endtype = data.types[parse.count - 1];
                if (ltype === "item") {
                    if (endtype === "colon") {
                        data.types[parse.count] = "value";
                    }
                    else {
                        item(endtype);
                    }
                }
                ltype = typename;
                if (ltype.indexOf("start") > -1 || ltype.indexOf("else") > -1) {
                    recordPush(ltoke);
                }
                else {
                    recordPush("");
                }
            };
            nosort[nosort.length - 1] = true;
            if (a < len) {
                do {
                    store.push(b[a]);
                    if (quote === "") {
                        if (b[a] === "\"") {
                            quote = "\"";
                        }
                        else if (b[a] === "'") {
                            quote = "'";
                        }
                        else if (b[a] === "/") {
                            if (b[a + 1] === "/") {
                                quote = "/";
                            }
                            else if (b[a + 1] === "*") {
                                quote = "*";
                            }
                        }
                        else if (b[a + 1] === end.charAt(0)) {
                            do {
                                endlen = endlen + 1;
                                a = a + 1;
                                store.push(b[a]);
                            } while (a < len && endlen < end.length && b[a + 1] === end.charAt(endlen));
                            if (endlen === end.length) {
                                quote = store.join("");
                                if ((/\s/).test(quote.charAt(start)) === true) {
                                    do {
                                        start = start + 1;
                                    } while ((/\s/).test(quote.charAt(start)) === true);
                                }
                                endlen = start;
                                do {
                                    endlen = endlen + 1;
                                } while (endlen < end.length && (/\s/).test(quote.charAt(endlen)) === false);
                                if (endlen === quote.length) {
                                    endlen = endlen - end.length;
                                }
                                if (open === "{%") {
                                    if (quote.indexOf("{%-") === 0) {
                                        quote = quote
                                            .replace(/^(\{%-\s*)/, "{%- ")
                                            .replace(/(\s*-%\})$/, " -%}");
                                        name = quote.slice(4);
                                    }
                                    else {
                                        quote = quote
                                            .replace(/^(\{%\s*)/, "{% ")
                                            .replace(/(\s*%\})$/, " %}");
                                        name = quote.slice(3);
                                    }
                                }
                                if (open === "{{") {
                                    quote = quote
                                        .replace(/^(\{\{\s+)/, "{{")
                                        .replace(/(\s+\}\})$/, "}}");
                                }
                                if (ltype === "item" && data.types[parse.count - 1] === "colon" && (data.types[parse.count - 2] === "property" || data.types[parse.count - 2] === "variable")) {
                                    ltype = "value";
                                    data.types[parse.count] = "value";
                                    if (Number.isNaN(Number(data.token[parse.count])) === true && data.token[parse.count].charAt(data.token[parse.count].length - 1) !== ")") {
                                        data.token[parse.count] = data.token[parse.count] + quote;
                                    }
                                    else {
                                        data.token[parse.count] = data.token[parse.count] + " " + quote;
                                    }
                                    return;
                                }
                                ltoke = quote;
                                if (open === "{%") {
                                    const templateNames = [
                                        "autoescape",
                                        "block",
                                        "capture",
                                        "case",
                                        "comment",
                                        "embed",
                                        "filter",
                                        "for",
                                        "form",
                                        "if",
                                        "macro",
                                        "paginate",
                                        "raw",
                                        "sandbox",
                                        "spaceless",
                                        "tablerow",
                                        "unless",
                                        "verbatim"
                                    ];
                                    let namesLen = templateNames.length - 1;
                                    name = name.slice(0, name.indexOf(" "));
                                    if (name.indexOf("(") > 0) {
                                        name = name.slice(0, name.indexOf("("));
                                    }
                                    if (name === "else" || name === "elseif" || name === "when" || name === "elif") {
                                        exit("template_else");
                                        return;
                                    }
                                    namesLen = templateNames.length - 1;
                                    if (namesLen > -1) {
                                        do {
                                            if (name === templateNames[namesLen]) {
                                                exit("template_start");
                                                return;
                                            }
                                            if (name === "end" + templateNames[namesLen]) {
                                                exit("template_end");
                                                return;
                                            }
                                            namesLen = namesLen - 1;
                                        } while (namesLen > -1);
                                    }
                                }
                                else if (open === "{{") {
                                    let group = quote.slice(2), ending = group.length, begin = 0;
                                    do {
                                        begin = begin + 1;
                                    } while (begin < ending && (/\s/).test(group.charAt(begin)) === false && group.charAt(start) !== "(");
                                    group = group.slice(0, begin);
                                    if (group.charAt(group.length - 2) === "}") {
                                        group = group.slice(0, group.length - 2);
                                    }
                                    if (group === "end") {
                                        exit("template_end");
                                        return;
                                    }
                                    if (group === "block" || group === "define" || group === "form" || group === "if" || group === "range" || group === "with") {
                                        exit("template_start");
                                        return;
                                    }
                                }
                                if ((/\{\s*\?>$/).test(ltoke) === true) {
                                    if ((/^<\?(=|(php))\s*\}\s*else/).test(ltoke) === true) {
                                        exit("template_else");
                                        return;
                                    }
                                    exit("template_start");
                                    return;
                                }
                                if ((/^<\?(=|(php))\s*\}/).test(ltoke) === true) {
                                    if ((/^<\?(=|(php))\s*\}\s*else/).test(ltoke) === true) {
                                        exit("template_else");
                                        return;
                                    }
                                    exit("template_end");
                                    return;
                                }
                                exit("template");
                                return;
                            }
                            endlen = 0;
                        }
                    }
                    else if (quote === b[a]) {
                        if (quote === "\"" || quote === "'") {
                            quote = "";
                        }
                        else if (quote === "/" && (b[a] === "\r" || b[a] === "\n")) {
                            quote = "";
                        }
                        else if (quote === "*" && b[a + 1] === "/") {
                            quote = "";
                        }
                    }
                    a = a + 1;
                } while (a < len);
            }
        }, 
        //finds comments including those JS looking '//' comments
        comment = function lexer_style_comment(line) {
            let comm = (line === true)
                ? parse.wrapCommentLine({
                    chars: b,
                    end: len,
                    lexer: "style",
                    opening: "//",
                    start: a,
                    terminator: "\n"
                })
                : parse.wrapCommentBlock({
                    chars: b,
                    end: len,
                    lexer: "style",
                    opening: "/*",
                    start: a,
                    terminator: "\u002a/"
                });
            ltoke = comm[0];
            ltype = ((/^(\/\*\s*parse-ignore-start)/).test(ltoke) === true)
                ? "ignore"
                : "comment";
            recordPush("");
            a = comm[1];
        }, 
        //consolidate margin and padding values
        margin_padding = function lexer_style_marginPadding() {
            const lines = parse.linesSpace, props = {
                data: {
                    margin: ["", "", "", "", false],
                    padding: ["", "", "", "", false]
                },
                last: {
                    margin: 0,
                    padding: 0
                },
                removes: []
            }, begin = parse.structure[parse.structure.length - 1][1], populate = function lexer_style_marginPadding_populate(prop) {
                if (data.token[aa - 2] === prop) {
                    const values = data.token[aa].replace(/\s*!important\s*/g, "").split(" "), vlen = values.length;
                    if (data.token[aa].indexOf("!important") > -1) {
                        props.data[prop[4]] = true;
                    }
                    if (vlen > 3) {
                        if (props.data[prop][0] === "") {
                            props.data[prop][0] = values[0];
                        }
                        if (props.data[prop][1] === "") {
                            props.data[prop][1] = values[1];
                        }
                        if (props.data[prop][2] === "") {
                            props.data[prop][2] = values[2];
                        }
                        if (props.data[prop][3] === "") {
                            props.data[prop][3] = values[3];
                        }
                    }
                    else if (vlen > 2) {
                        if (props.data[prop][0] === "") {
                            props.data[prop][0] = values[0];
                        }
                        if (props.data[prop][1] === "") {
                            props.data[prop][1] = values[1];
                        }
                        if (props.data[prop][2] === "") {
                            props.data[prop][2] = values[2];
                        }
                        if (props.data[prop][3] === "") {
                            props.data[prop][3] = values[1];
                        }
                    }
                    else if (vlen > 1) {
                        if (props.data[prop][0] === "") {
                            props.data[prop][0] = values[0];
                        }
                        if (props.data[prop][1] === "") {
                            props.data[prop][1] = values[1];
                        }
                        if (props.data[prop][2] === "") {
                            props.data[prop][2] = values[0];
                        }
                        if (props.data[prop][3] === "") {
                            props.data[prop][3] = values[1];
                        }
                    }
                    else {
                        if (props.data[prop][0] === "") {
                            props.data[prop][0] = values[0];
                        }
                        if (props.data[prop][1] === "") {
                            props.data[prop][1] = values[0];
                        }
                        if (props.data[prop][2] === "") {
                            props.data[prop][2] = values[0];
                        }
                        if (props.data[prop][3] === "") {
                            props.data[prop][3] = values[0];
                        }
                    }
                }
                else if (data.token[aa - 2] === `${prop}-bottom`) {
                    if (props.data[prop][2] === "") {
                        props.data[prop][2] = data.token[aa];
                    }
                }
                else if (data.token[aa - 2] === `${prop}-left`) {
                    if (props.data[prop][3] === "") {
                        props.data[prop][3] = data.token[aa];
                    }
                }
                else if (data.token[aa - 2] === `${prop}-right`) {
                    if (props.data[prop][1] === "") {
                        props.data[prop][1] = data.token[aa];
                    }
                }
                else if (data.token[aa - 2] === `${prop}-top`) {
                    if (props.data[prop][0] === "") {
                        props.data[prop][0] = data.token[aa];
                    }
                }
                else {
                    return;
                }
                props.removes.push([aa, prop]);
                props.last[prop] = aa;
            }, removes = function lexer_style_marginPadding_removes() {
                let cc = 0, values = "";
                const zero = (/^(0+([a-z]+|%))/), bb = props.removes.length, tmargin = (props.data.margin[0] !== "" && props.data.margin[1] !== "" && props.data.margin[2] !== "" && props.data.margin[3] !== ""), tpadding = (props.data.padding[0] !== "" && props.data.padding[1] !== "" && props.data.padding[2] !== "" && props.data.padding[3] !== ""), applyValues = function lexer_style_marginPadding_removes_applyValues(prop) {
                    if (zero.test(props.data[prop][0]) === true) {
                        props.data[prop][0] = "0";
                    }
                    if (zero.test(props.data[prop][1]) === true) {
                        props.data[prop][1] = "0";
                    }
                    if (zero.test(props.data[prop][2]) === true) {
                        props.data[prop][2] = "0";
                    }
                    if (zero.test(props.data[prop][3]) === true) {
                        props.data[prop][3] = "0";
                    }
                    if (props.data[prop][0] === props.data[prop][1] && props.data[prop][0] === props.data[prop][2] && props.data[prop][0] === props.data[prop][3]) {
                        values = props.data[prop][0];
                    }
                    else if (props.data[prop][0] === props.data[prop][2] && props.data[prop][1] === props.data[prop][3] && props.data[prop][0] !== props.data[prop][1]) {
                        values = `${props.data[prop][0]} ${props.data[prop][1]}`;
                    }
                    else if (props.data[prop][1] === props.data[prop][3] && props.data[prop][0] !== props.data[prop][2]) {
                        values = `${props.data[prop][0]} ${props.data[prop][1]} ${props.data[prop][2]}`;
                    }
                    else {
                        values = `${props.data[prop][0]} ${props.data[prop][1]} ${props.data[prop][2]} ${props.data[prop][3]}`;
                    }
                    if (props.data[prop[4]] === true) {
                        values = `${values.replace(" !important", "")} !important`;
                    }
                    if (props.last[prop] > parse.count) {
                        cc = (begin < 1)
                            ? 1
                            : begin + 1;
                        do {
                            if (data.begin[cc] === begin && data.types[cc] === "value" && data.token[cc - 2].indexOf(prop) === 0) {
                                props.last[prop] = cc;
                                break;
                            }
                            cc = cc + 1;
                        } while (cc < parse.count);
                    }
                    data.token[props.last[prop]] = values;
                    data.token[props.last[prop] - 2] = prop;
                };
                if (bb > 1 && (tmargin === true || tpadding === true)) {
                    do {
                        if (props.removes[cc][0] !== props.last.margin && props.removes[cc][0] !== props.last.padding && ((tmargin === true && props.removes[cc][1] === "margin") || (tpadding === true && props.removes[cc][1] === "padding"))) {
                            parse.splice({
                                data: data,
                                howmany: (data.types[props.removes[cc][0] + 1] === "separator")
                                    ? 4
                                    : 3,
                                index: props.removes[cc][0] - 2
                            });
                        }
                        cc = cc + 1;
                    } while (cc < bb - 1);
                }
                if (tmargin === true) {
                    applyValues("margin");
                }
                if (tpadding === true) {
                    applyValues("padding");
                }
                // this is necessary to fix the "begin" values of descendent blocks
                if (endtest === true) {
                    if (begin < 0) {
                        sparser.parseerror = "Brace mismatch.  There appears to be more closing braces than starting braces.";
                    }
                    else {
                        parse.sortCorrection(begin, parse.count + 1);
                    }
                }
            };
            let aa = parse.count, endtest = false;
            do {
                aa = aa - 1;
                if (data.begin[aa] === begin) {
                    if (data.types[aa] === "value" && data.types[aa - 2] === "property") {
                        if (data.token[aa - 2].indexOf("margin") === 0) {
                            populate("margin");
                        }
                        else if (data.token[aa - 2].indexOf("padding") === 0) {
                            populate("padding");
                        }
                    }
                }
                else {
                    endtest = true;
                    aa = data.begin[aa];
                }
            } while (aa > begin);
            removes();
            parse.linesSpace = lines;
        };
        //token building loop
        do {
            if ((/\s/).test(b[a]) === true) {
                a = parse.spacer({ array: b, end: len, index: a });
            }
            else if (b[a] === "/" && b[a + 1] === "*") {
                comment(false);
            }
            else if (b[a] === "/" && b[a + 1] === "/") {
                comment(true);
            }
            else if (b[a] === "<" && b[a + 1] === "?" && b[a + 2] === "p" && b[a + 3] === "h" && b[a + 4] === "p") {
                //php
                template("<?php", "?>");
            }
            else if (b[a] === "<" && b[a + 1] === "?" && b[a + 2] === "=") {
                //php
                template("<?=", "?>");
            }
            else if (b[a] === "<" && b[a + 1] === "%") {
                //asp
                template("<%", "%>");
            }
            else if (b[a] === "{" && b[a + 1] === "%") {
                //asp
                template("{%", "%}");
            }
            else if (b[a] === "{" && b[a + 1] === "{" && b[a + 2] === "{") {
                //mustache
                template("{{{", "}}}");
            }
            else if (b[a] === "{" && b[a + 1] === "{") {
                //handlebars
                template("{{", "}}");
            }
            else if (b[a] === "<" && b[a + 1] === "!" && b[a + 2] === "-" && b[a + 3] === "-" && b[a + 4] === "#") {
                //ssi
                template("<!--#", "-->");
            }
            else if (b[a] === "@" && b[a + 1] === "e" && b[a + 2] === "l" && b[a + 3] === "s" && b[a + 4] === "e" && (b[a + 5] === "{" || (/\s/).test(b[a + 5]) === true)) {
                ltoke = "@else";
                ltype = "template_else";
                recordPush("");
                a = a + 4;
            }
            else if (b[a] === "{" || (b[a] === "(" && data.token[parse.count] === ":" && data.types[parse.count - 1] === "variable")) {
                item("start");
                ltype = "start";
                ltoke = b[a];
                if (b[a] === "(") {
                    recordPush("map");
                    mapper.push(0);
                }
                else if (data.types[parse.count] === "selector" || data.types[parse.count] === "variable") {
                    recordPush(data.token[parse.count]);
                }
                else if (data.types[parse.count] === "colon") {
                    recordPush(data.token[parse.count - 1]);
                }
                else {
                    recordPush("block");
                }
                nosort.push(false);
            }
            else if (b[a] === "}" || (b[a] === ")" && parse.structure[parse.structure.length - 1][0] === "map" && mapper[mapper.length - 1] === 0)) {
                if (b[a] === "}" && data.types[parse.count] === "item" && data.token[parse.count - 1] === "{" && data.token[parse.count - 2] !== undefined && data.token[parse.count - 2].charAt(data.token[parse.count - 2].length - 1) === "@") {
                    data.token[parse.count - 2] = data.token[parse.count - 2] + "{" + data.token[parse.count] +
                        "}";
                    parse.pop(data);
                    parse.pop(data);
                    parse.structure.pop();
                }
                else {
                    if (b[a] === ")") {
                        mapper.pop();
                    }
                    item("end");
                    if (b[a] === "}" && data.token[parse.count] !== ";") {
                        if (data.types[parse.count] === "value" || data.types[parse.count] === "function" || (data.types[parse.count] === "variable" && (data.token[parse.count - 1] === ":" || data.token[parse.count - 1] === ";"))) {
                            if (options.correct === true) {
                                ltoke = ";";
                            }
                            else {
                                ltoke = "x;";
                            }
                            ltype = "separator";
                            recordPush("");
                        }
                        else if (data.types[parse.count] === "comment") {
                            semiComment();
                        }
                    }
                    ltype = "end";
                    nosort.pop();
                    ltoke = b[a];
                    ltype = "end";
                    if (b[a] === "}") {
                        margin_padding();
                    }
                    if (options.lexer_options.style.object_sort === true && b[a] === "}") {
                        parse.object_sort(data);
                    }
                    recordPush("");
                }
            }
            else if (b[a] === ";" || b[a] === ",") {
                if (data.types[parse.count - 1] === "selector" || (data.token[parse.count - 1] === "}" && data.types[parse.count] !== "function")) {
                    item("start");
                }
                else {
                    item("separator");
                }
                if (data.types[parse.count] !== "separator" && esctest(a) === true) {
                    ltoke = b[a];
                    ltype = "separator";
                    recordPush("");
                }
            }
            else if (b[a] === ":" && data.types[parse.count] !== "end") {
                item("colon");
                ltoke = ":";
                ltype = "colon";
                recordPush("");
            }
            else {
                if (parse.structure[parse.structure.length - 1][0] === "map" && b[a] === "(") {
                    mapper[mapper.length - 1] = mapper[mapper.length - 1] + 1;
                }
                buildtoken();
            }
            a = a + 1;
        } while (a < len);
        if (options.lexer_options.style.object_sort === true) {
            parse.object_sort(data);
        }
        return data;
    };
    sparser.lexers.style = style;
}());
(function markdown_init() {
    
    const markdown = function lexer_markdown(source) {
        let a = 0, b = 0, bc1 = 0, bc2 = 0, quote = "", stack = [];
        const parse = sparser.parse, data = parse.data, options = sparser.options, lines = (options.crlf === true)
            // eslint-disable-next-line
            ? source.replace(/\u0000/g, "\ufffd").split("\r\n")
            // eslint-disable-next-line
            : source.replace(/\u0000/g, "\ufffd").split("\n"), frontspace = function lexer_markdown_frontspace(index) {
            const space = (/^\s+/).exec(lines[index]);
            if (space === null) {
                return "";
            }
            return space[0];
        }, hr = function lexer_markdown_hr() {
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "<hr/>",
                types: "singleton"
            }, "");
        }, text = function lexer_markdown_text(item, tag, listrecurse) {
            const headerId = function lexer_markdown_text_headerId(tag) {
                if ((/<\/h\d>/).test(tag) === false) {
                    return tag;
                }
                const store = [], parent = parse.structure[parse.structure.length - 1];
                let aa = parent[1] + 1, id = "";
                do {
                    if (data.types[aa] === "content") {
                        store.push(data.token[aa]);
                    }
                    aa = aa + 1;
                } while (aa < parse.count);
                if (store.length > 0) {
                    id = `id="${store.join(" ").replace(/\s+/g, "-").replace(/\.|\(|\)|:|\?|#|=|\{|\}|\[|\]/g, "").replace(/-+/g, "-").replace(/^-/, "").replace(/-$/, "").toLowerCase()}"`;
                    parse.splice({
                        data: data,
                        howmany: 0,
                        index: parent[1] + 1,
                        record: {
                            begin: parent[1],
                            ender: -1,
                            lexer: "markdown",
                            lines: 0,
                            stack: parent[0],
                            token: id,
                            types: "attribute"
                        }
                    });
                }
                return tag;
            };
            let tagend = tag.replace("<", "</"), struct = tag.replace("<", "").replace(/(\/?>)$/, "");
            // line containing strong, em, or inline code
            if (item.indexOf("*") > -1 || item.indexOf("_") > -1 || item.indexOf("`") > -1 || (item.indexOf("[") > -1 && item.indexOf("](") > -1)) {
                const esctest = function lexer_markdown_text_esctest() {
                    let bb = aa - 1;
                    if (str[bb] === "\\") {
                        do {
                            bb = bb - 1;
                        } while (str[bb] === "\\");
                        if ((aa - bb) % 2 === 1) {
                            return true;
                        }
                        return false;
                    }
                    return false;
                }, underscore = function lexer_markdown_text_underscore() {
                    const numb = (str[aa + 1] === "_")
                        ? 2
                        : 1;
                    if ((/\s/).test(str[aa - 1]) === true || aa === 0 || aa === bb - numb || (/\s/).test(str[aa + numb]) === true) {
                        return true;
                    }
                    return false;
                }, gencontent = function lexer_markdown_text_gencontent() {
                    return itemx.join("").replace(/\s+/g, " ").replace(/^\s/, "").replace(/\s$/, "").replace(/\\(?!(\\))/g, "").replace(/\\{2}/g, "\\");
                };
                let stray = "", str = item.split(""), content = "", itemx = [], square = 0, aa = 0, bb = str.length, cc = 0;
                if (tag !== "multiline") {
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: tag,
                        types: "start"
                    }, struct);
                }
                do {
                    if (str[aa] === "[" && esctest() === false) {
                        cc = aa;
                        square = 0;
                        do {
                            if (str[cc] === "[") {
                                square = square + 1;
                            }
                            else if (str[cc] === "]") {
                                square = square - 1;
                                if (square < 1 && str[cc + 1] === "(") {
                                    content = itemx.join("").replace(/\s+/g, " ").replace(/^\s/, "").replace(/\s$/, "");
                                    if (content !== "") {
                                        parse.push(data, {
                                            begin: parse.structure[parse.structure.length - 1][1],
                                            ender: -1,
                                            lexer: "markdown",
                                            lines: 0,
                                            stack: parse.structure[parse.structure.length - 1][0],
                                            token: content,
                                            types: "content"
                                        }, "");
                                    }
                                    itemx = [];
                                    stack.push("[");
                                    if (str[aa - 1] === "!") {
                                        content = "img";
                                    }
                                    else {
                                        content = "a";
                                    }
                                    if (content === "img") {
                                        if (data.token[parse.count] === "!") {
                                            parse.pop(data);
                                        }
                                        else if (data.types[parse.count] === "content") {
                                            data.token[parse.count] = data.token[parse.count].slice(0, data.token[parse.count].length - 1).replace(/(\s)$/, "");
                                        }
                                        parse.push(data, {
                                            begin: parse.structure[parse.structure.length - 1][1],
                                            ender: -1,
                                            lexer: "markdown",
                                            lines: 1,
                                            stack: parse.structure[parse.structure.length - 1][0],
                                            token: "<img/>",
                                            types: "singleton"
                                        }, "");
                                        content = str.slice(aa + 1, cc).join("").replace(/\s+/g, " ").replace(/^\s/, "").replace(/\s$/, "");
                                        if (content !== "") {
                                            parse.push(data, {
                                                begin: parse.structure[parse.structure.length - 1][1],
                                                ender: -1,
                                                lexer: "markdown",
                                                lines: 0,
                                                stack: parse.structure[parse.structure.length - 1][0],
                                                token: "alt=\"" + content + "\"",
                                                types: "attribute"
                                            }, "");
                                        }
                                        parse.push(data, {
                                            begin: parse.structure[parse.structure.length - 1][1],
                                            ender: -1,
                                            lexer: "markdown",
                                            lines: 1,
                                            stack: parse.structure[parse.structure.length - 1][0],
                                            token: "src=\"",
                                            types: "attribute"
                                        }, "");
                                        aa = cc - 1;
                                    }
                                    else {
                                        parse.push(data, {
                                            begin: parse.structure[parse.structure.length - 1][1],
                                            ender: -1,
                                            lexer: "markdown",
                                            lines: 1,
                                            stack: parse.structure[parse.structure.length - 1][0],
                                            token: "<a>",
                                            types: "start"
                                        }, "a");
                                        parse.push(data, {
                                            begin: parse.structure[parse.structure.length - 1][1],
                                            ender: -1,
                                            lexer: "markdown",
                                            lines: 0,
                                            stack: parse.structure[parse.structure.length - 1][0],
                                            token: "href=\"",
                                            types: "attribute"
                                        }, "");
                                    }
                                    break;
                                }
                            }
                            cc = cc + 1;
                        } while (cc < bb);
                    }
                    else if (str[aa] === "]" && str[aa + 1] === "(" && esctest() === false && stack[stack.length - 1] === "[") {
                        content = gencontent();
                        if (content !== "" && content.length > 1 && parse.structure[parse.structure.length - 1][0] !== "img") {
                            parse.push(data, {
                                begin: parse.structure[parse.structure.length - 1][1],
                                ender: -1,
                                lexer: "markdown",
                                lines: 0,
                                stack: parse.structure[parse.structure.length - 1][0],
                                token: content,
                                types: "content"
                            }, "");
                        }
                        cc = aa + 1;
                        square = 0;
                        do {
                            if (str[cc] === "(") {
                                square = square + 1;
                            }
                            else if (str[cc] === ")") {
                                square = square - 1;
                                if (square === 0) {
                                    content = str.slice(aa + 2, cc).join("").replace(/\s+/g, " ").replace(/^\s/, "").replace(/\s$/, "");
                                    aa = cc;
                                    str[cc] = "";
                                    itemx = [];
                                    cc = (parse.structure[parse.structure.length - 1][0] === "a")
                                        ? parse.structure[parse.structure.length - 1][1] + 1
                                        : parse.count;
                                    if (content === "") {
                                        data.token[cc] = data.token[cc] + "\"";
                                    }
                                    else {
                                        data.token[cc] = data.token[cc] + content + "\"";
                                    }
                                    break;
                                }
                            }
                            cc = cc + 1;
                        } while (cc < bb);
                        stack.pop();
                        if (parse.structure[parse.structure.length - 1][0] === "a") {
                            parse.push(data, {
                                begin: parse.structure[parse.structure.length - 1][1],
                                ender: -1,
                                lexer: "markdown",
                                lines: 0,
                                stack: parse.structure[parse.structure.length - 1][0],
                                token: "</a>",
                                types: "end"
                            }, "");
                        }
                    }
                    else if ((str[aa] === "*" || (str[aa] === "_" && underscore() === true) || str[aa] === "~") &&
                        esctest() === false &&
                        stack[stack.length - 1] !== "`" &&
                        ((quote === "" && ((/\s/).test(str[aa - 1]) === true ||
                            aa === 0)) || quote !== "")) {
                        if (str[aa] === "~") {
                            quote = "~";
                            do {
                                str[aa] = "";
                                aa = aa + 1;
                            } while (str[aa] === "~");
                        }
                        else if (str[aa] === "*" && str[aa + 1] === "*") {
                            quote = "**";
                            str[aa + 1] = "";
                        }
                        else if (str[aa] === "_" && str[aa + 1] === "_") {
                            quote = "__";
                            str[aa + 1] = "";
                        }
                        else if (str[aa] === "_") {
                            quote = "_";
                        }
                        else if (str[aa] !== "_") {
                            quote = "*";
                        }
                        str[aa] = "";
                        if (quote === stack[stack.length - 1]) {
                            let midtag = "</em>";
                            content = gencontent();
                            if (content !== "") {
                                parse.push(data, {
                                    begin: parse.structure[parse.structure.length - 1][1],
                                    ender: -1,
                                    lexer: "markdown",
                                    lines: 0,
                                    stack: parse.structure[parse.structure.length - 1][0],
                                    token: content,
                                    types: "content"
                                }, "");
                            }
                            itemx = [];
                            if (quote === "~") {
                                midtag = "</strike>";
                            }
                            else if (quote === "**" || quote === "__") {
                                midtag = "</strong>";
                            }
                            stack.pop();
                            parse.push(data, {
                                begin: parse.structure[parse.structure.length - 1][1],
                                ender: -1,
                                lexer: "markdown",
                                lines: 0,
                                stack: parse.structure[parse.structure.length - 1][0],
                                token: midtag,
                                types: "end"
                            }, "");
                            quote = "";
                            stack = [];
                        }
                        else {
                            let midtag = "em";
                            content = gencontent();
                            if (content !== "") {
                                parse.push(data, {
                                    begin: parse.structure[parse.structure.length - 1][1],
                                    ender: -1,
                                    lexer: "markdown",
                                    lines: 0,
                                    stack: parse.structure[parse.structure.length - 1][0],
                                    token: content,
                                    types: "content"
                                }, "");
                            }
                            itemx = [];
                            if (quote === "~") {
                                midtag = "strike";
                            }
                            else if (quote === "**" || quote === "__") {
                                midtag = "strong";
                            }
                            stack.push(quote);
                            parse.push(data, {
                                begin: parse.structure[parse.structure.length - 1][1],
                                ender: -1,
                                lexer: "markdown",
                                lines: 1,
                                stack: parse.structure[parse.structure.length - 1][0],
                                token: `<${midtag}>`,
                                types: "start"
                            }, midtag);
                        }
                    }
                    else if (str[aa] === "`" && esctest() === false) {
                        content = gencontent();
                        if (content !== "") {
                            parse.push(data, {
                                begin: parse.structure[parse.structure.length - 1][1],
                                ender: -1,
                                lexer: "markdown",
                                lines: 0,
                                stack: parse.structure[parse.structure.length - 1][0],
                                token: content,
                                types: "content"
                            }, "");
                        }
                        itemx = [];
                        if (stack[stack.length - 1] === "`") {
                            str[aa] = "";
                            stack.pop();
                            parse.push(data, {
                                begin: parse.structure[parse.structure.length - 1][1],
                                ender: -1,
                                lexer: "markdown",
                                lines: 0,
                                stack: parse.structure[parse.structure.length - 1][0],
                                token: "</code>",
                                types: "end"
                            }, "");
                            quote = "";
                            stack = [];
                        }
                        else {
                            stack.push("`");
                            parse.push(data, {
                                begin: parse.structure[parse.structure.length - 1][1],
                                ender: -1,
                                lexer: "markdown",
                                lines: 1,
                                stack: parse.structure[parse.structure.length - 1][0],
                                token: "<code>",
                                types: "start"
                            }, "code");
                        }
                    }
                    if (str[aa] !== stack[stack.length - 1] && str[aa - 1] + str[aa] !== stack[stack.length - 1]) {
                        itemx.push(str[aa]);
                    }
                    aa = aa + 1;
                } while (aa < bb);
                content = gencontent();
                if (tag !== "multiline" && data.types[parse.count] === "start" && data.token[parse.count] !== tag) {
                    stray = data.token[parse.count];
                    parse.pop(data);
                    parse.structure.pop();
                    if (stray === "<code>") {
                        stray = "`";
                    }
                    else if (stray === "<em>") {
                        stray = "*";
                    }
                    else if (stray === "<strong>") {
                        stray = "**";
                    }
                    else if (stray === "<strike>") {
                        stray = "~";
                    }
                    if (data.types[parse.count] === "start") {
                        content = item;
                    }
                    else {
                        data.token[parse.count] = data.token[parse.count] + stray;
                    }
                }
                if (content !== "") {
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 1,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: content,
                        types: "content"
                    }, "");
                }
                if (listrecurse === true) {
                    list();
                }
                if (tag !== "multiline") {
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: headerId(tagend),
                        types: "end"
                    }, "");
                    quote = "";
                    stack = [];
                }
                return;
            }
            if (struct.indexOf(" ") > 0) {
                struct = struct.slice(0, struct.indexOf(" "));
            }
            if (tag !== "multiline") {
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: tag,
                    types: "start"
                }, struct);
            }
            if (listrecurse === true) {
                list();
            }
            else {
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: item.replace(/^(\s+)/, "").replace(/(\s+)$/, ""),
                    types: "content"
                }, "");
            }
            if (tag !== "multiline") {
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: headerId(tagend),
                    types: "end"
                }, "");
                quote = "";
                stack = [];
            }
        }, comtest = function lexer_markdown_comtest(index) {
            return (/^(\s{0,3}<!--)/).test(lines[index]);
        }, hrtest = function lexer_markdown_hrtest(index) {
            return (/^(\s*((-\s*){3,}|(_\s*){3,}|(\*\s*){3,})\s*)$/).test(lines[index]);
        }, codetest = function lexer_markdown_codetest(index) {
            return ((/^(\u0020{4,}\s*\S)/).test(lines[index]) === true || (/^(\s*\t\s*\S)/).test(lines[index]) === true);
        }, codeblocktest = function lexer_markdown_codeblocktest(index) {
            return (/^(\s{0,3}((`{3,})|(~{3,}))+(\S+)?\s*)$/).test(lines[index]);
        }, listtest = function lexer_markdown_listtest(index) {
            const listy = (/^(\s*(\*|-|\+|(\d{1,9}(\)|\.))))/);
            if (listy.test(lines[index]) === true) {
                const listr = lines[index].replace(listy, "");
                if (listr === "") {
                    lines[index] = lines[index] + " ";
                }
                else if ((/\s/).test(listr.charAt(0)) === false) {
                    return false;
                }
                return true;
            }
            return false;
        }, comment = function lexer_markdown_comment() {
            const com = [];
            let comment = "";
            if (lines[a].indexOf("-->") < 0) {
                do {
                    com.push(lines[a]);
                    a = a + 1;
                } while (a < b && lines[a].indexOf("-->") < 0);
            }
            else {
                com.push(lines[a]);
            }
            if (options.crlf === true) {
                comment = com.join("\r\n").replace(/^(\s*<!--+\s*)/, "").replace(/\s*-+->/, "-->");
            }
            else {
                comment = com.join("\n").replace(/^(\s*<!--+\s*)/, "").replace(/\s*-+->/, "-->");
            }
            comment = comment.slice(0, comment.indexOf("-->"));
            if (lines[a] !== undefined) {
                lines[a] = lines[a].slice(lines[a].indexOf("-->") + 3);
                if (lines[a].replace(/\s+/, "") !== "") {
                    a = a - 1;
                }
            }
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: comment,
                types: "comment"
            }, "");
        }, code = function lexer_markdown_code(codetext, language, fourspace) {
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "<p>",
                types: "start"
            }, "p");
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "<code>",
                types: "start"
            }, "code");
            if (language !== "") {
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: "class=\"language-" + language + "\"",
                    types: "attribute"
                }, "");
            }
            if (codetext !== "") {
                if (fourspace === true) {
                    if (codetext.indexOf("    ") === 0) {
                        codetext = codetext.replace(/^(\u0020{4})/, "");
                    }
                    else {
                        codetext = codetext.replace(/^(\s*\t)/, "");
                    }
                }
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: codetext,
                    types: "content"
                }, "");
            }
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "</code>",
                types: "end"
            }, "");
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "</p>",
                types: "end"
            }, "");
        }, codeblock = function lexer_markdown_codeblock(ticks, blockyquote, fourspace) {
            const indentstr = (function lexer_markdown_codeblock() {
                let inumb = (ticks === true)
                    ? (/^(\s*)/).exec(lines[a])[0].length
                    : 0;
                if (inumb > 3) {
                    return 0;
                }
                return inumb;
            }()), indent = new RegExp(`^(\\s{0,${indentstr}})`), open = (function lexer_markdown_codeblock_open() {
                const op = lines[a].replace(/^\s*/, "");
                let aa = 0;
                do {
                    aa = aa + 1;
                } while (op.charAt(aa) === op.charAt(0));
                return op.slice(0, aa);
            }()), language = (ticks === true)
                ? lines[a].replace(/(\s*((`+)|(~+))\s*)/, "").replace(/(\s*)/g, "")
                : "", endgate = new RegExp(`^\\s{0,3}${open.charAt(0)}{${open.length},}\\s*$`), codes = [];
            if (ticks === true) {
                a = a + 1;
                if (endgate.test(lines[a]) === true) {
                    code("", language, false);
                    return;
                }
            }
            do {
                if (lines[a] === undefined) {
                    break;
                }
                if (ticks === true) {
                    if (endgate.test(lines[a]) === true) {
                        break;
                    }
                    codes.push(lines[a].replace(indent, ""));
                }
                else if (lines[a] !== "") {
                    codes.push(lines[a].replace(/^(\u0020{4})/, "").replace(/^(\s*\t)/, ""));
                    if (lines[a + 1] !== "" && codetest(a + 1) === false) {
                        break;
                    }
                    if (lines[a + 1] === "" && codetest(a + 2) === false) {
                        a = a + 1;
                        break;
                    }
                }
                else {
                    if (codetest(a + 1) === false) {
                        break;
                    }
                    codes.push("");
                }
                if (blockyquote === true && (/^(\s*>)/).test(lines[a + 1]) === false) {
                    break;
                }
                a = a + 1;
            } while (a < b);
            if (options.crlf === true) {
                code(codes.join("\r\n"), language, fourspace);
            }
            else {
                code(codes.join("\n"), language, fourspace);
            }
        }, parabuild = function lexer_markdown_parabuild() {
            let x = a, tag = "<p>";
            const test = function lexer_markdown_parabuild_test(index) {
                if (lines[index] === undefined) {
                    return false;
                }
                if ((/^(\s{0,3}((=+)|(-+))\s*)$/).test(lines[index]) === true) {
                    if (lines[index].indexOf("=") > -1) {
                        tag = "<h1>";
                    }
                    else {
                        tag = "<h2>";
                    }
                    return false;
                }
                if (hrtest(index) === true) {
                    return false;
                }
                if ((/^(\s*((`{3,})|(~{3,}))+(\S+)?\s*)$/).test(lines[index]) === true) {
                    return false;
                }
                if (lines[index] === "") {
                    return false;
                }
                if ((/^(\s*>)/).test(lines[index]) === true) {
                    return false;
                }
                if ((/^(\s*#{1,6}\s)/).test(lines[index]) === true) {
                    return false;
                }
                if (listtest(index) === true && parse.structure[parse.structure.length - 1][0] !== "blockquote") {
                    return false;
                }
                return true;
            }, fixquote = function lexer_markdown_parabuild_fixquote() {
                let key = "", x = parse.count;
                if (quote === "*" || quote === "_") {
                    key = "<em>";
                }
                else if (quote === "**" || quote === "__") {
                    key = "<strong>";
                }
                else if (quote === "~") {
                    key = "<strike>";
                }
                parse.structure.pop();
                if (data.token[x] !== key) {
                    do {
                        data.begin[x] = parse.structure[parse.structure.length - 1][1];
                        data.stack[x] = parse.structure[parse.structure.length - 1][0];
                        x = x - 1;
                    } while (x > 0 && data.token[x] !== key);
                }
                if (data.types[x + 1] === "content") {
                    data.token[x + 1] = `${quote} ${data.token[x + 1]}`;
                    parse.splice({
                        data: data,
                        howmany: 1,
                        index: x
                    });
                }
                else if (data.types[x - 1] === "content") {
                    data.token[x - 1] = data.token[x - 1] + quote;
                    parse.splice({
                        data: data,
                        howmany: 1,
                        index: x
                    });
                }
                else {
                    data.token[x] = quote;
                    data.types[x] = "content";
                }
                quote = "";
            };
            if (test(a + 1) === true) {
                do {
                    x = x + 1;
                } while (x < b && test(x) === true);
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: tag,
                    types: "start"
                }, tag.replace("<", "").replace(">", ""));
                if (x === a + 1) {
                    text(lines[a], tag, false);
                }
                else {
                    do {
                        text(lines[a], "multiline", false);
                        parse.push(data, {
                            begin: parse.structure[parse.structure.length - 1][1],
                            ender: -1,
                            lexer: "markdown",
                            lines: 0,
                            stack: parse.structure[parse.structure.length - 1][0],
                            token: "<br/>",
                            types: "singleton"
                        }, "");
                        a = a + 1;
                    } while (a < x);
                    parse.pop(data);
                    if (quote !== "") {
                        fixquote();
                    }
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: tag.replace("<", "</"),
                        types: "end"
                    }, "");
                }
            }
            else {
                text(lines[a], tag, false);
                if (tag !== "<p>") {
                    a = a + 1;
                }
            }
            quote = "";
            stack = [];
        }, heading = function lexer_markdown_heading() {
            let hash = (/^(\s*#+\s+)/).exec(lines[a])[0].replace(/\s+/g, ""), hashes = function lexer_markdown_heading_hasheds(escapes) {
                return escapes.replace(/\\/g, "").replace(/\s+/g, "");
            }, content = lines[a].replace(/^(\s*#+\s+)/, "").replace(/(\s+#+\s*)$/, "").replace(/((\\?#)+\s*)$/, hashes);
            if (content === "" || (/^(#+)$/).test(content) === true) {
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: "<h" + hash.length + ">",
                    types: "start"
                }, "h" + hash.length);
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: "</h" + hash.length + ">",
                    types: "end"
                }, "");
            }
            else {
                text(content, "<h" + hash.length + ">", false);
            }
        }, blockquote = function lexer_markdown_blockquote() {
            let x = a;
            bc1 = bc1 + 1;
            bc2 = bc1;
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "<blockquote>",
                types: "start"
            }, "blockquote");
            do {
                lines[x] = lines[x].replace(/^(\s*>\u0020?)/, "");
                if (listtest(x + 1) === true) {
                    break;
                }
                if (lines[x].replace(/\s+/, "") === "") {
                    lines[x] = "";
                    if ((/^(\s*>)/).test(lines[x + 1]) === false) {
                        break;
                    }
                }
                if ((/^(\s{0,3}((-{3,})|(={3,}))\s*)$/).test(lines[x + 1]) === true) {
                    break;
                }
                x = x + 1;
            } while (x < b && lines[x] !== "" && codetest(x) === false && hrtest(x) === false);
            if (x < b - 1 && x > 0) {
                if (listtest(x) === true) {
                    lines.splice(x + 1, 0, "");
                    b = b + 1;
                }
                else if (lines[x].replace(/\s+/, "") !== "") {
                    x = x - 1;
                }
            }
            do {
                if ((/^(\s*>)/).test(lines[a]) === true) {
                    blockquote();
                }
                else if ((/^(\s*((`{3,})|(~{3,}))+(\S+)?\s*)$/).test(lines[a]) === true) {
                    if (a + 1 < x) {
                        parse.push(data, {
                            begin: parse.structure[parse.structure.length - 1][1],
                            ender: -1,
                            lexer: "markdown",
                            lines: 0,
                            stack: parse.structure[parse.structure.length - 1][0],
                            token: "<p>",
                            types: "start"
                        }, "p");
                        parse.push(data, {
                            begin: parse.structure[parse.structure.length - 1][1],
                            ender: -1,
                            lexer: "markdown",
                            lines: 0,
                            stack: parse.structure[parse.structure.length - 1][0],
                            token: "<code>",
                            types: "start"
                        }, "code");
                        parse.push(data, {
                            begin: parse.structure[parse.structure.length - 1][1],
                            ender: -1,
                            lexer: "markdown",
                            lines: 0,
                            stack: parse.structure[parse.structure.length - 1][0],
                            token: "</code>",
                            types: "end"
                        }, "");
                        parse.push(data, {
                            begin: parse.structure[parse.structure.length - 1][1],
                            ender: -1,
                            lexer: "markdown",
                            lines: 0,
                            stack: parse.structure[parse.structure.length - 1][0],
                            token: "</p>",
                            types: "end"
                        }, "");
                        lines[a] = "";
                        break;
                    }
                    codeblock(true, true, false);
                }
                else if (codetest(a) === true) {
                    codeblock(false, true, true);
                }
                else if ((/^(\s*#{1,6}\s)/).test(lines[a]) === true) {
                    heading();
                }
                else if (listtest(a) === true) {
                    list();
                }
                else if (a > x && (/^(\s{0,3}((-{3,})|(={3,}))\s*)$/).test(lines[a + 1]) === true) {
                    text(lines[a], "<p>", false);
                }
                else if (lines[a].replace(/\s+/, "") !== "") {
                    parabuild();
                }
                a = a + 1;
            } while (a < x);
            if (lines[a - 1] === "" || lines[a] !== "" || (a > x && (/^(\s{0,3}((-{3,})|(={3,}))\s*)$/).test(lines[a]) === true)) {
                a = a - 1;
            }
            bc1 = bc1 - 1;
            if (bc1 === 0) {
                do {
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: "</blockquote>",
                        types: "end"
                    }, "");
                    bc2 = bc2 - 1;
                } while (bc2 > 0);
            }
        }, list = function lexer_markdown_list() {
            let paraForce = false, ind = 0, sym = lines[a].replace(/^(\s+)/, "").charAt(0), record = {
                begin: -1,
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: "",
                token: "",
                types: ""
            }, numb = "", lasttext = "", y = 0, z = 0, order = false, end;
            const tabs = function lexer_markdown_list_tabs(spaces) {
                let output = spaces.split(""), uu = 0;
                const tt = output.length;
                do {
                    if (output[uu] === "\t") {
                        output[uu] = "    ";
                    }
                    uu = uu + 1;
                } while (uu < tt);
                return output.join("");
            }, checktest = function lexer_markdown_list_checktest() {
                return ((/^(\s*(\*|-|\+)?\s{0,3}\[( |x)\]\s*)$/).test(lines[a]) === true || (/^(\s*(\*|-|\+)?\s{0,3}\[( |x)\]\s+\S)/).test(lines[a]) === true);
            }, indentation = (/^(\s*(\*|-|\+)?\s*)/), indlen = function lexer_markdown_list_indlen(index) {
                if (lines[index] === undefined) {
                    return 0;
                }
                return indentation.exec(lines[index].replace(indentation, tabs))[0].length;
            }, space = function lexer_markdown_list_space(index, emptyLine) {
                let xind = indlen(index), xsym = (lines[index] === undefined)
                    ? ""
                    : lines[index].replace(/^(\s+)/, "").charAt(0);
                if (lines[index] === undefined) {
                    return 0;
                }
                if (order === true) {
                    xind = (/(^(\s*(\d+(\)|\.)))?\s*)/).exec(lines[index])[0].length;
                    xsym = lines[index].replace(/^(\s*\d+)/, "").charAt(0);
                }
                if (order === false && "*-+".indexOf(xsym) > -1 && xsym !== sym && xind - ind < 2 && (/\s/).test(lines[index].replace(/^(\s+)/, "").charAt(1)) === true) {
                    return -1;
                }
                if (xind - ind < 0) {
                    return xind;
                }
                if (xsym !== sym && listtest(index) === true && (emptyLine === false || (emptyLine === true && xind - ind < 2))) {
                    return 10;
                }
                return xind;
            };
            if ((/^(\s*\d{1,9}(\)|\.)\s)/).test(lines[a]) === true) {
                order = true;
                ind = (/(^(\s*(\d+(\)|\.)))?\s*)/).exec(lines[a])[0].length;
                sym = lines[a].replace(/^(\s*\d+)/, "").charAt(0);
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: "<ol>",
                    types: "start"
                }, "ol");
                numb = (/\d{1,9}/).exec(lines[a])[0].replace(/^(0+)/, "");
                if (numb !== "1") {
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: "start=\"" + numb + "\"",
                        types: "attribute"
                    }, "");
                }
            }
            else {
                ind = indlen(a);
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: "<ul>",
                    types: "start"
                }, "ul");
            }
            do {
                paraForce = false;
                // lists do not contain comments
                if (comtest(a) === true) {
                    a = a - 1;
                    break;
                }
                // an ordered list may not have unordered list items
                if (order === true && (/^(\s{0,3}(\*|-|\+)\s)/).test(lines[a]) === true) {
                    if (frontspace(a) !== "") {
                        lexer_markdown_list();
                        record.begin = parse.structure[parse.structure.length - 1][1];
                        record.stack = parse.structure[parse.structure.length - 1][0];
                        record.token = "</li>";
                        record.types = "end";
                        parse.push(data, record, "");
                    }
                    else {
                        lines.splice(a, 0, "");
                        b = b + 1;
                        break;
                    }
                }
                // an unordered list may not have ordered list items
                if (order === false && (/^(\s{0,3}\d{1,9}(\)|\.)\s)/).test(lines[a]) === true) {
                    if (frontspace(a) !== "") {
                        lexer_markdown_list();
                        record.begin = parse.structure[parse.structure.length - 1][1];
                        record.stack = parse.structure[parse.structure.length - 1][0];
                        record.token = "</li>";
                        record.types = "end";
                        parse.push(data, record, "");
                    }
                    else {
                        lines.splice(a, 0, "");
                        b = b + 1;
                        break;
                    }
                }
                numb = lines[a];
                lines[a] = lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}\.))\s+)/, "");
                //recursive list item
                if (listtest(a) === true) {
                    parse.structure.push(["ul", parse.count - 3]);
                    lexer_markdown_list();
                    record.begin = parse.structure[parse.structure.length - 1][1];
                    record.stack = parse.structure[parse.structure.length - 1][0];
                    record.token = "<li>";
                    record.types = "start";
                    y = parse.count - 1;
                    do {
                        data.begin[y] = data.begin[y] - 1;
                        y = y - 1;
                    } while (y > 0 && data.token[y + 1] !== "<li>");
                    parse.splice({
                        data: data,
                        howmany: 0,
                        index: y,
                        record: record
                    });
                    y = y + 1;
                    do {
                        if (data.types[y] === "start") {
                            data.begin[y] = y - 1;
                            data.stack[y] = data.token[y - 1].replace("<", "").replace(">", "");
                            z = y;
                        }
                        else {
                            data.begin[y] = z;
                            if (data.types[y] === "end") {
                                z = z - 1;
                            }
                        }
                        y = y + 1;
                    } while (y < parse.count + 1);
                    record.begin = z;
                    record.stack = "li";
                    record.token = "</li>";
                    record.types = "end";
                    parse.push(data, record, "");
                }
                else if (lines[a] === "") {
                    y = space(a + 1, true) - ind;
                    if (y < 0) {
                        break;
                    }
                    if (y > 1 && a < b - 1 && lines[a + 1].replace(/\s+/, "").charAt(0) !== sym && (/^(\s{0,3}>)/).test(lines[a + 1]) === false) {
                        paraForce = true;
                    }
                    else if (codetest(a + 1) === false && (parse.structure.join("").indexOf("blockquote") > 0 || y !== 0) && a < b - 1) {
                        break;
                    }
                }
                else {
                    lines[a] = numb;
                    y = space(a, false) - ind;
                    if (y < -1 || y > 9 || hrtest(a) === true) {
                        z = (lines[a + 1] === "")
                            ? a + 2
                            : a + 1;
                        if (z !== b && codetest(z) === false && listtest(z) === false && (/^\s*>/).test(lines[a]) === false && lines[a + 1] !== "") {
                            a = a - 1;
                            break;
                        }
                    }
                    if (data.token[parse.count - 1] === "<li>") {
                        paraForce = false;
                        if (lines[a - 1] === "") {
                            a = a - 1;
                            break;
                        }
                    }
                    else if (y < 1 && listtest(a) === false) {
                        paraForce = true;
                        y = 2;
                    }
                    if ((/^(\s*(\*|-|\+|(\d{1,9}(\)|\.)))\s*)$/).test(lines[a]) === true && lines[a + 1] === "") {
                        record.begin = parse.structure[parse.structure.length - 1][1];
                        record.stack = parse.structure[parse.structure.length - 1][0];
                        record.token = "<li>";
                        record.types = "start";
                        parse.push(data, record, "li");
                        record.begin = parse.structure[parse.structure.length - 1][1];
                        record.stack = parse.structure[parse.structure.length - 1][0];
                        record.token = "</li>";
                        record.types = "end";
                        parse.push(data, record, "");
                    }
                    else if (y < -1) {
                        //different list type
                        lines.splice(a, 0, "");
                        b = b + 1;
                        break;
                    }
                    else if (y > 1) {
                        if ((/^(\s*>)/).test(lines[a]) === true) {
                            //blockquote in list item
                            end = parse.pop(data);
                            record.begin = end.begin;
                            record.stack = end.stack;
                            parse.structure.push([end.stack, end.begin]);
                            blockquote();
                            record.begin = parse.structure[parse.structure.length - 1][1];
                            record.stack = parse.structure[parse.structure.length - 1][0];
                            record.token = "</li>";
                            record.types = "end";
                            parse.push(data, record, "");
                        }
                        else if (listtest(a) === true && (/^(\u0020{4,}\s*\S)/).test(lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}(\)|\.)))\s)/, "").replace(/^\t/, "    ")) === true) {
                            //code line in list item
                            record.begin = parse.structure[parse.structure.length - 1][1];
                            record.stack = parse.structure[parse.structure.length - 1][0];
                            record.token = "<li>";
                            record.types = "start";
                            parse.push(data, record, "li");
                            lines[a] = lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}(\)|\.)))\s)/, "").replace(/^\t/, "    ");
                            code(lines[a], "", true);
                            record.begin = parse.structure[parse.structure.length - 1][1];
                            record.stack = parse.structure[parse.structure.length - 1][0];
                            record.token = "</li>";
                            record.types = "end";
                            parse.push(data, record, "");
                        }
                        else if (paraForce || (codetest(a) === true && listtest(a) === false)) {
                            end = parse.pop(data);
                            record.begin = end.begin;
                            record.stack = end.stack;
                            parse.structure.push([end.stack, end.begin]);
                            if (lines[a - 1] === "" && data.token[parse.count] !== "</p>") {
                                lasttext = data.token[parse.count];
                                parse.pop(data);
                                record.token = "<p>";
                                record.types = "start";
                                parse.push(data, record, "p");
                                record.begin = parse.structure[parse.structure.length - 1][1];
                                record.stack = parse.structure[parse.structure.length - 1][0];
                                record.token = lasttext;
                                record.types = "content";
                                parse.push(data, record, "");
                                record.token = "</p>";
                                record.types = "end";
                                parse.push(data, record, "");
                            }
                            lines[a] = lines[a].replace(/^(\u0020{4})/, "").replace(/^(\s*\t)/, "");
                            if (codetest(a) === true) {
                                code(lines[a], "", true);
                            }
                            else if (data.token[parse.count] === "</p>" && lines[a - 1] !== "") {
                                parse.pop(data);
                                parse.structure.push(["p", data.begin[parse.count]]);
                                record.begin = parse.structure[parse.structure.length - 1][1];
                                record.stack = parse.structure[parse.structure.length - 1][0];
                                record.token = "<br/>";
                                record.types = "singleton";
                                parse.push(data, record, "");
                                text(lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}\.))\s+)/, ""), "multiline", false);
                                record.token = "</p>";
                                record.types = "end";
                                parse.push(data, record, "");
                            }
                            else if (data.types[parse.count] === "content") {
                                a = a - 1;
                                parse.pop(data);
                                record.token = "<p>";
                                record.types = "start";
                                record.begin = parse.structure[parse.structure.length - 1][1];
                                record.stack = parse.structure[parse.structure.length - 1][0];
                                parse.push(data, record, "p");
                                record.begin = parse.structure[parse.structure.length - 1][1];
                                record.stack = parse.structure[parse.structure.length - 1][0];
                                text(lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}\.))\s+)/, ""), "multiline", false);
                                record.token = "<br/>";
                                record.types = "singleton";
                                parse.push(data, record, "");
                                a = a + 1;
                                text(lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}\.))\s+)/, ""), "multiline", false);
                                record.token = "</p>";
                                record.types = "end";
                                parse.push(data, record, "");
                            }
                            else {
                                text(lines[a], "<p>", false);
                            }
                            parse.push(data, end, "");
                        }
                        else if (listtest(a) === true) {
                            lexer_markdown_list();
                            record.begin = parse.structure[parse.structure.length - 1][1];
                            record.stack = parse.structure[parse.structure.length - 1][0];
                            record.token = "</li>";
                            record.types = "end";
                            parse.push(data, record, "");
                        }
                    }
                    else if ((/^(\s*((`{3,})|(~{3,}))+(\S+)?\s*)$/).test(lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}(\)|\.)))\s)/, "")) === true) {
                        record.begin = parse.structure[parse.structure.length - 1][1];
                        record.stack = parse.structure[parse.structure.length - 1][0];
                        record.token = "<li>";
                        record.types = "start";
                        parse.push(data, record, "li");
                        lines[a] = lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}(\)|\.)))\s)/, "");
                        codeblock(true, false, false);
                        record.begin = parse.structure[parse.structure.length - 1][1];
                        record.stack = parse.structure[parse.structure.length - 1][0];
                        record.token = "</li>";
                        record.types = "end";
                        parse.push(data, record, "");
                    }
                    else if (checktest() === true || (listtest(a + 1) === true && space(a + 1, false) - space(a, false) > 1)) {
                        record.begin = parse.structure[parse.structure.length - 1][1];
                        record.stack = parse.structure[parse.structure.length - 1][0];
                        record.token = "<li>";
                        record.types = "start";
                        parse.push(data, record, "li");
                        if (checktest() === true) {
                            if (data.types[parse.structure[parse.structure.length - 2][1] + 1] !== "attribute") {
                                const index = parse.structure[parse.structure.length - 2][1] + 1;
                                parse.structure[parse.structure.length - 1][1] = parse.structure[parse.structure.length - 1][1] + 1;
                                if (parse.count > index) {
                                    const parent = index - 1;
                                    let aa = parse.count;
                                    do {
                                        aa = aa - 1;
                                        if (data.begin[aa] !== parent) {
                                            data.begin[aa] = data.begin[aa] + 1;
                                        }
                                        data.ender[aa] = data.ender[aa] + 1;
                                    } while (aa > index);
                                }
                                parse.splice({
                                    data: data,
                                    howmany: 0,
                                    index: index,
                                    record: {
                                        begin: parse.structure[parse.structure.length - 2][1],
                                        ender: -1,
                                        lexer: "markdown",
                                        lines: 0,
                                        stack: parse.structure[parse.structure.length - 2][0],
                                        token: "class=\"contains-task-list\"",
                                        types: "attribute"
                                    }
                                });
                            }
                            record.begin = parse.structure[parse.structure.length - 1][1];
                            record.stack = parse.structure[parse.structure.length - 1][0];
                            record.token = "class=\"task-list-item\"";
                            record.types = "attribute";
                            parse.push(data, record, "");
                            record.begin = parse.structure[parse.structure.length - 1][1];
                            record.stack = parse.structure[parse.structure.length - 1][0];
                            record.token = "<input/>";
                            record.types = "singleton";
                            parse.push(data, record, "");
                            y = parse.count;
                            record.begin = y;
                            record.stack = "input";
                            record.token = "class=\"task-list-item-checkbox\"";
                            record.types = "attribute";
                            parse.push(data, record, "");
                            record.begin = y;
                            record.stack = "input";
                            record.token = "disabled=\"disabled\"";
                            record.types = "attribute";
                            parse.push(data, record, "");
                            y = lines[a].indexOf("[x]");
                            z = lines[a].indexOf("[ ]");
                            if (y > -1 && z > -1) {
                                if (y < z) {
                                    lines[a] = lines[a].replace(/(\[x\]\s*)/, "");
                                    record.begin = data.begin[parse.count - 1];
                                    record.stack = "input";
                                    record.token = "checked=\"checked\"";
                                    record.types = "attribute";
                                    parse.push(data, record, "");
                                }
                                else {
                                    lines[a] = lines[a].replace(/(\[ \]\s*)/, "");
                                }
                            }
                            else if (y > -1) {
                                lines[a] = lines[a].replace(/(\[x\]\s*)/, "");
                                record.begin = data.begin[parse.count - 1];
                                record.stack = "input";
                                record.token = "checked=\"checked\"";
                                record.types = "attribute";
                                parse.push(data, record, "");
                            }
                            else {
                                lines[a] = lines[a].replace(/(\[ \]\s*)/, "");
                            }
                        }
                        lines[a] = lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}\.))\s+)/, "");
                        text(lines[a], "multiline", false);
                        if (listtest(a + 1) === false || a > b - 1 || frontspace(a) === frontspace(a + 1)) {
                            record.begin = parse.structure[parse.structure.length - 1][1];
                            record.stack = parse.structure[parse.structure.length - 1][0];
                            record.token = "</li>";
                            record.types = "end";
                            parse.push(data, record, "");
                        }
                    }
                    else {
                        lines[a] = lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}\.))\s+)/, "");
                        text(lines[a], "<li>", false);
                    }
                }
                a = a + 1;
            } while (a < b);
            if (lines[a] === "" || listtest(a + 1) === false) {
                if (order === true) {
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: "</ol>",
                        types: "end"
                    }, "");
                }
                else {
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: "</ul>",
                        types: "end"
                    }, "");
                }
            }
        }, table = function lexer_markdown_table() {
            let c = 0, d = 0, line = lines[a]
                .replace(/^\|/, "")
                .replace(/\|$/, "")
                .replace(/\\\|/g, "parse\\?sep")
                .split("|"), bar = lines[a + 1]
                .replace(/(\s*)/g, "")
                .replace(/^\|/, "")
                .replace(/\|$/, "")
                .split("|");
            if (line.length !== bar.length) {
                return parabuild();
            }
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "<table>",
                types: "start"
            }, "table");
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "<thead>",
                types: "start"
            }, "thead");
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "<tr>",
                types: "start"
            }, "tr");
            d = line.length;
            do {
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: "<th>",
                    types: "start"
                }, "th");
                if ((/:-+:/).test(bar[c]) === true) {
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: "style=\"text-align:center\"",
                        types: "attribute"
                    }, "");
                }
                else if ((/:-+/).test(bar[c]) === true) {
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: "style=\"text-align:left\"",
                        types: "attribute"
                    }, "");
                }
                else if ((/-+:/).test(bar[c]) === true) {
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: "style=\"text-align:right\"",
                        types: "attribute"
                    }, "");
                }
                text(line[c].replace(/parse\\\?sep/g, "|"), "multiline", false);
                quote = "";
                stack = [];
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: "</th>",
                    types: "end"
                }, "");
                c = c + 1;
            } while (c < d);
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "</tr>",
                types: "end"
            }, "");
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "</thead>",
                types: "end"
            }, "");
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "<tbody>",
                types: "start"
            }, "tbody");
            a = a + 2;
            d = bar.length;
            do {
                if (lines[a] === "") {
                    break;
                }
                if ((/^(\s*>)/).test(lines[a]) === true) {
                    if (data.token[parse.count] === "<tbody>") {
                        parse.structure.pop();
                        parse.pop(data);
                    }
                    else {
                        parse.push(data, {
                            begin: parse.structure[parse.structure.length - 1][1],
                            ender: -1,
                            lexer: "markdown",
                            lines: 0,
                            stack: parse.structure[parse.structure.length - 1][0],
                            token: "</tbody>",
                            types: "end"
                        }, "");
                    }
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: "</table>",
                        types: "end"
                    }, "");
                    return blockquote();
                }
                line = lines[a]
                    .replace(/^\|/, "")
                    .replace(/\|$/, "")
                    .replace(/\\\|/g, "parse\\?sep")
                    .split("|");
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: "<tr>",
                    types: "start"
                }, "tr");
                c = 0;
                do {
                    if (line[c] === undefined) {
                        line[c] = "";
                    }
                    if (line[c] === " " && c === bar.length) {
                        break;
                    }
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: "<td>",
                        types: "start"
                    }, "td");
                    if ((/:-+:/).test(bar[c]) === true) {
                        parse.push(data, {
                            begin: parse.structure[parse.structure.length - 1][1],
                            ender: -1,
                            lexer: "markdown",
                            lines: 0,
                            stack: parse.structure[parse.structure.length - 1][0],
                            token: "style=\"text-align:center\"",
                            types: "attribute"
                        }, "");
                    }
                    else if ((/:-+/).test(bar[c]) === true) {
                        parse.push(data, {
                            begin: parse.structure[parse.structure.length - 1][1],
                            ender: -1,
                            lexer: "markdown",
                            lines: 0,
                            stack: parse.structure[parse.structure.length - 1][0],
                            token: "style=\"text-align:left\"",
                            types: "attribute"
                        }, "");
                    }
                    else if ((/-+:/).test(bar[c]) === true) {
                        parse.push(data, {
                            begin: parse.structure[parse.structure.length - 1][1],
                            ender: -1,
                            lexer: "markdown",
                            lines: 0,
                            stack: parse.structure[parse.structure.length - 1][0],
                            token: "style=\"text-align:right\"",
                            types: "attribute"
                        }, "");
                    }
                    if (line[c] !== "") {
                        text(line[c].replace(/parse\\\?sep/g, "|"), "multiline", false);
                    }
                    quote = "";
                    stack = [];
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: "</td>",
                        types: "end"
                    }, "");
                    c = c + 1;
                } while (c < d);
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: "</tr>",
                    types: "end"
                }, "");
                a = a + 1;
            } while (a < b);
            if (data.token[parse.count] === "<tbody>") {
                parse.structure.pop();
                parse.pop(data);
            }
            else {
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: "</tbody>",
                    types: "end"
                }, "");
            }
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "</table>",
                types: "end"
            }, "");
        };
        b = lines.length;
        parse.push(data, {
            begin: parse.structure[parse.structure.length - 1][1],
            ender: -1,
            lexer: "markdown",
            lines: 0,
            stack: parse.structure[parse.structure.length - 1][0],
            token: "<body>",
            types: "start"
        }, "body");
        do {
            if ((/^(\s*)$/).test(lines[a]) === true) {
                if (lines[a - 1] === "") {
                    lines.splice(a, 1);
                    b = b - 1;
                    a = a - 1;
                }
                else {
                    lines[a] = "";
                }
            }
            else if ((/^(\s*(\*|-|\+|(\d{1,9}(\)|\.))))/).test(lines[a]) === true && lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}(\)|\.)))\s*)/, "") === "") {
                if ((/^(\u0020{2,})/).test(lines[a + 1]) === true) {
                    lines[a] = lines[a].replace(/(\s+)$/, "") + lines[a + 1].replace("  ", " ");
                    lines.splice(a + 1, 1);
                    b = b - 1;
                }
                else if ((/^(\t)/).test(lines[a + 1]) === true) {
                    lines[a] = lines[a].replace(/(\s+)$/, "") + lines[a + 1].replace("\t", " ");
                    lines.splice(a + 1, 1);
                    b = b - 1;
                }
            }
            a = a + 1;
        } while (a < b);
        a = 0;
        do {
            if (comtest(a) === true) {
                comment();
            }
            else if (codetest(a) === true) {
                if (codetest(a + 1) === true || (lines[a + 1] === "" && codetest(a + 2) === true)) {
                    codeblock(false, false, true);
                }
                else {
                    code(lines[a], "", true);
                }
            }
            else if (hrtest(a) === true) {
                hr();
            }
            else if ((/^(\s{0,3}>)/).test(lines[a]) === true) {
                blockquote();
            }
            else if ((/(((:-+)|(-+:)|(:-+:)|(-{2,}))\s*\|\s*)/).test(lines[a + 1]) === true) {
                table();
            }
            else if (codeblocktest(a) === true) {
                codeblock(true, false, false);
            }
            else if ((/^(\s*#{1,6}\s)/).test(lines[a]) === true) {
                heading();
            }
            else if (listtest(a) === true) {
                list();
            }
            else if (lines[a] !== "" && (/^(\s+)$/).test(lines[a]) === false) {
                parabuild();
            }
            a = a + 1;
        } while (a < b);
        parse.push(data, {
            begin: parse.structure[parse.structure.length - 1][1],
            ender: -1,
            lexer: "markdown",
            lines: 0,
            stack: parse.structure[parse.structure.length - 1][0],
            token: "</body>",
            types: "end"
        }, "");
        return data;
    };
    sparser.lexers.markdown = markdown;
}());
(function script_init() {
    
    const script = function lexer_script(source) {
        let a = 0, ltoke = "", ltype = "", lword = [], pword = [], lengthb = 0, wordTest = -1, paren = -1, funreferences = [], tempstore, pstack, comment;
        const parse = sparser.parse, data = parse.data, options = sparser.options, sourcemap = [
            0, ""
        ], references = parse.references, b = source.length, c = source.split(""), brace = [], classy = [], datatype = [false], 
        // identify variable declarations
        vart = {
            count: [],
            index: [],
            len: -1,
            word: []
        }, 
        // automatic semicolon insertion
        asi = function lexer_script_asi(isEnd) {
            let aa = 0;
            const next = nextchar(1, false), record = {
                begin: data.begin[parse.count],
                ender: data.begin[parse.count],
                lexer: data.lexer[parse.count],
                lines: data.lines[parse.count],
                stack: data.stack[parse.count],
                token: data.token[parse.count],
                types: data.types[parse.count]
            }, clist = (parse.structure.length === 0)
                ? ""
                : parse.structure[parse.structure.length - 1][0];
            if ((/^(\/(\/|\*)\s*parse-ignore\u002dstart)/).test(ltoke) === true) {
                return;
            }
            if (ltype === "start" || ltype === "type_start") {
                return;
            }
            if (options.language === "json" || options.language === "java" || options.language === "csharp") {
                return;
            }
            if (options.language === "json" || record.token === ";" || record.token === "," || next === "{" || record.stack === "class" || record.stack === "map" || record.stack === "attribute" || clist === "initializer" || data.types[record.begin - 1] === "generic") {
                return;
            }
            if (record.token === "}" && data.stack[record.begin - 1] === "global" && data.types[record.begin - 1] !== "operator" && record.stack === data.stack[parse.count - 1]) {
                return;
            }
            if (record.stack === "array" && record.token !== "]") {
                return;
            }
            if (data.token[data.begin[parse.count]] === "{" && record.stack === "data_type") {
                return;
            }
            if (record.types !== undefined && record.types.indexOf("template") > -1 && record.types.indexOf("template_string") < 0) {
                return;
            }
            if (next === ";" && isEnd === false) {
                return;
            }
            if (data.lexer[parse.count - 1] !== "script" && ((a < b && b === options.source.length - 1) || b < options.source.length - 1)) {
                return;
            }
            if (options.language === "qml") {
                if (record.types === "start") {
                    return;
                }
                ltoke = (options.correct === true)
                    ? ";"
                    : "x;";
                ltype = "separator";
                recordPush("");
                if (next !== "}") {
                    blockinsert();
                }
                return;
            }
            if (record.token === "}" && (record.stack === "function" || record.stack === "if" || record.stack === "else" || record.stack === "for" || record.stack === "do" || record.stack === "while" || record.stack === "switch" || record.stack === "class" || record.stack === "try" || record.stack === "catch" || record.stack === "finally" || record.stack === "block")) {
                if (record.stack === "function" && (data.stack[record.begin - 1] === "data_type" || data.types[record.begin - 1] === "type")) {
                    aa = record.begin;
                    do {
                        aa = aa - 1;
                    } while (aa > 0 && data.token[aa] !== ")" && data.stack[aa] !== "arguments");
                    aa = data.begin[aa];
                }
                else {
                    aa = data.begin[record.begin - 1];
                }
                if (data.token[aa] === "(") {
                    aa = aa - 1;
                    if (data.token[aa - 1] === "function") {
                        aa = aa - 1;
                    }
                    if (data.stack[aa - 1] === "object" || data.stack[aa - 1] === "switch") {
                        return;
                    }
                    if (data.token[aa - 1] !== "=" && data.token[aa - 1] !== "return" && data.token[aa - 1] !== ":") {
                        return;
                    }
                }
                else {
                    return;
                }
            }
            if (record.types === "comment" ||
                clist === "method" ||
                clist === "paren" ||
                clist === "expression" ||
                clist === "array" ||
                clist === "object" ||
                (clist === "switch" && record.stack !== "method" && data.token[data.begin[parse.count]] === "(" && data.token[data.begin[parse.count] - 1] !== "return" && data.types[data.begin[parse.count] - 1] !== "operator")) {
                return;
            }
            if (data.stack[parse.count] === "expression" && (data.token[data.begin[parse.count] - 1] !== "while" || (data.token[data.begin[parse.count] - 1] === "while" && data.stack[data.begin[parse.count] - 2] !== "do"))) {
                return;
            }
            if (next !== "" && "=<>+*?|^:&%~,.()]".indexOf(next) > -1 && isEnd === false) {
                return;
            }
            if (record.types === "comment") {
                aa = parse.count;
                do {
                    aa = aa - 1;
                } while (aa > 0 && data.types[aa] === "comment");
                if (aa < 1) {
                    return;
                }
                record.token = data.token[aa];
                record.types = data.types[aa];
                record.stack = data.stack[aa];
            }
            if (record.token === undefined || record.types === "start" || record.types === "separator" || (record.types === "operator" && record.token !== "++" && record.token !== "--") || record.token === "x}" || record.token === "var" || record.token === "let" || record.token === "const" || record.token === "else" || record.token.indexOf("#!/") === 0 || record.token === "instanceof") {
                return;
            }
            if (record.stack === "method" && (data.token[record.begin - 1] === "function" || data.token[record.begin - 2] === "function")) {
                return;
            }
            if (options.lexer_options.script.variable_list === "list") {
                vart.index[vart.len] = parse.count;
            }
            ltoke = (options.correct === true)
                ? ";"
                : "x;";
            ltype = "separator";
            aa = parse.linesSpace;
            parse.linesSpace = 0;
            recordPush("");
            parse.linesSpace = aa;
            blockinsert();
        }, 
        // fixes asi location if inserted after an inserted brace
        asibrace = function lexer_script_asibrace() {
            let aa = parse.count;
            do {
                aa = aa - 1;
            } while (aa > -1 && data.token[aa] === "x}");
            if (data.stack[aa] === "else") {
                return recordPush("");
            }
            aa = aa + 1;
            parse.splice({
                data: data,
                howmany: 0,
                index: aa,
                record: {
                    begin: data.begin[aa],
                    ender: -1,
                    lexer: "script",
                    lines: parse.linesSpace,
                    stack: data.stack[aa],
                    token: ltoke,
                    types: ltype
                }
            });
            recordPush("");
        }, 
        // cleans up improperly applied ASI
        asifix = function lexer_script_asifix() {
            let len = parse.count;
            if (data.types[len] === "comment") {
                do {
                    len = len - 1;
                } while (len > 0 && data.types[len] === "comment");
            }
            if (data.token[len] === "from") {
                len = len - 2;
            }
            if (data.token[len] === "x;") {
                parse.splice({ data: data, howmany: 1, index: len });
            }
        }, 
        // block comments
        blockComment = function lexer_script_blockComment() {
            asi(false);
            if (wordTest > -1) {
                word();
            }
            comment = parse.wrapCommentBlock({
                chars: c,
                end: b,
                lexer: "script",
                opening: "/*",
                start: a,
                terminator: "\u002a/"
            });
            a = comment[1];
            if (data.token[parse.count] === "var" || data.token[parse.count] === "let" || data.token[parse.count] === "const") {
                tempstore = parse.pop(data);
                recordPush("");
                parse.push(data, tempstore, "");
                if (data.lines[parse.count - 2] === 0) {
                    data.lines[parse.count - 2] = data.lines[parse.count];
                }
                data.lines[parse.count] = 0;
            }
            else if (comment[0] !== "") {
                ltoke = comment[0];
                ltype = (/^\/\*\s*parse-ignore-start/).test(ltoke)
                    ? "ignore"
                    : "comment";
                if (ltoke.indexOf("# sourceMappingURL=") === 2) {
                    sourcemap[0] = parse.count + 1;
                    sourcemap[1] = ltoke;
                }
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "script",
                    lines: parse.linesSpace,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: ltoke,
                    types: ltype
                }, "");
            }
            if ((/\/\*\s*global\s+/).test(data.token[parse.count]) === true && data.types.indexOf("word") < 0) {
                references[0] = data.token[parse.count].replace(/\/\*\s*global\s+/, "").replace("\u002a/", "").replace(/,\s+/g, ",").split(",");
            }
        }, 
        // inserts ending curly brace (where absent)
        blockinsert = function lexer_script_blockinsert() {
            let next = nextchar(5, false), name = "";
            const g = parse.count, lines = parse.linesSpace;
            if (options.language === "json" || brace.length < 1 || brace[brace.length - 1].charAt(0) !== "x" || (/^x?(;|\}|\))$/).test(ltoke) === false) {
                return;
            }
            if (data.stack[parse.count] === "do" && next === "while" && data.token[parse.count] === "}") {
                return;
            }
            if (ltoke === ";" && data.token[g - 1] === "x{") {
                name = data.token[data.begin[g - 2] - 1];
                if (data.token[g - 2] === "do" || (data.token[g - 2] === ")" && "ifforwhilecatch".indexOf(name) > -1)) {
                    tempstore = parse.pop(data);
                    ltoke = (options.correct === true)
                        ? "}"
                        : "x}";
                    ltype = "end";
                    pstack = parse.structure[parse.structure.length - 1];
                    recordPush("");
                    brace.pop();
                    parse.linesSpace = lines;
                    return;
                }
                // to prevent the semicolon from inserting between the braces --> while (x) {};
                tempstore = parse.pop(data);
                ltoke = (options.correct === true)
                    ? "}"
                    : "x}";
                ltype = "end";
                pstack = parse.structure[parse.structure.length - 1];
                recordPush("");
                brace.pop();
                ltoke = ";";
                ltype = "end";
                parse.push(data, tempstore, "");
                parse.linesSpace = lines;
                return;
            }
            ltoke = (options.correct === true)
                ? "}"
                : "x}";
            ltype = "end";
            if (data.token[parse.count] === "x}") {
                return;
            }
            if (data.stack[parse.count] === "if" && (data.token[parse.count] === ";" || data.token[parse.count] === "x;") && next === "else") {
                pstack = parse.structure[parse.structure.length - 1];
                recordPush("");
                brace.pop();
                parse.linesSpace = lines;
                return;
            }
            do {
                pstack = parse.structure[parse.structure.length - 1];
                recordPush("");
                brace.pop();
                if (data.stack[parse.count] === "do") {
                    break;
                }
            } while (brace[brace.length - 1] === "x{");
            parse.linesSpace = lines;
        }, 
        // commaComment ensures that commas immediately precede comments instead of
        // immediately follow
        commaComment = function lexer_script_commacomment() {
            let x = parse.count;
            if (data.stack[x] === "object" && options.lexer_options.script.object_sort === true) {
                ltoke = ",";
                ltype = "separator";
                asifix();
                recordPush("");
            }
            else {
                do {
                    x = x - 1;
                } while (x > 0 && data.types[x - 1] === "comment");
                parse.splice({
                    data: data,
                    howmany: 0,
                    index: x,
                    record: {
                        begin: data.begin[x],
                        ender: -1,
                        lexer: "script",
                        lines: parse.linesSpace,
                        stack: data.stack[x],
                        token: ",",
                        types: "separator"
                    }
                });
                recordPush("");
            }
        }, 
        // operations for end types: ), ], }
        end = function lexer_script_end(x) {
            let insert = false, newarr = false;
            const next = nextchar(1, false), count = (data.token[parse.count] === "(")
                ? parse.count
                : data.begin[parse.count], newarray = function lexer_script_end_newarray() {
                let arraylen = 0;
                const ar = (data.token[count - 1] === "Array"), startar = (ar === true)
                    ? "["
                    : "{", endar = (ar === true)
                    ? "]"
                    : "}", namear = (ar === true)
                    ? "array"
                    : "object";
                if (ar === true && data.types[parse.count] === "number") {
                    arraylen = Number(data.token[parse.count]);
                    tempstore = parse.pop(data);
                }
                tempstore = parse.pop(data);
                tempstore = parse.pop(data);
                tempstore = parse.pop(data);
                parse.structure.pop();
                ltoke = startar;
                ltype = "start";
                recordPush(namear);
                if (arraylen > 0) {
                    ltoke = ",";
                    ltype = "separator";
                    do {
                        recordPush("");
                        arraylen = arraylen - 1;
                    } while (arraylen > 0);
                }
                ltoke = endar;
                ltype = "end";
                recordPush("");
            };
            if (wordTest > -1) {
                word();
            }
            if (classy.length > 0) {
                if (classy[classy.length - 1] === 0) {
                    classy.pop();
                }
                else {
                    classy[classy.length - 1] = classy[classy.length - 1] - 1;
                }
            }
            if (x === ")" || x === "x)" || x === "]") {
                if (options.correct === true) {
                    plusplus();
                }
                asifix();
            }
            if (x === ")" || x === "x)") {
                asi(false);
            }
            if (vart.len > -1) {
                if (x === "}" && ((options.lexer_options.script.variable_list === "list" && vart.count[vart.len] === 0) || (data.token[parse.count] === "x;" && options.lexer_options.script.variable_list === "each"))) {
                    vartpop();
                }
                vart.count[vart.len] = vart.count[vart.len] - 1;
                if (vart.count[vart.len] < 0) {
                    vartpop();
                }
            }
            if (ltoke === "," && data.stack[parse.count] !== "initializer" && ((x === "]" && data.token[parse.count - 1] === "[") || x === "}")) {
                tempstore = parse.pop(data);
            }
            if (x === ")" || x === "x)") {
                ltoke = x;
                if (lword.length > 0) {
                    pword = lword[lword.length - 1];
                    if (pword.length > 1 && next !== "{" && (pword[0] === "if" || pword[0] === "for" || (pword[0] === "while" && data.stack[pword[1] - 2] !== undefined && data.stack[pword[1] - 2] !== "do") || pword[0] === "with")) {
                        insert = true;
                    }
                }
            }
            else if (x === "]") {
                ltoke = "]";
            }
            else if (x === "}") {
                if (ltoke !== "," && options.correct === true) {
                    plusplus();
                }
                if (parse.structure.length > 0 && parse.structure[parse.structure.length - 1][0] !== "object") {
                    asi(true);
                }
                if (options.lexer_options.script.object_sort === true && parse.structure[parse.structure.length - 1][0] === "object") {
                    parse.object_sort(data);
                }
                if (ltype === "comment") {
                    ltoke = data.token[parse.count];
                    ltype = data.types[parse.count];
                }
                ltoke = "}";
            }
            if (parse.structure[parse.structure.length - 1][0] === "data_type") {
                ltype = "type_end";
            }
            else {
                ltype = "end";
            }
            lword.pop();
            pstack = parse.structure[parse.structure.length - 1];
            if (x === ")" && options.correct === true && count - parse.count < 2 && (data.token[parse.count] === "(" || data.types[parse.count] === "number") && (data.token[count - 1] === "Array" || data.token[count - 1] === "Object") && data.token[count - 2] === "new") {
                newarray();
                newarr = true;
            }
            if (brace[brace.length - 1] === "x{" && x === "}") {
                blockinsert();
                brace.pop();
                if (data.stack[parse.count] !== "try") {
                    if (next !== ":" && next !== ";" && data.token[data.begin[a] - 1] !== "?") {
                        blockinsert();
                    }
                }
                ltoke = "}";
            }
            else {
                brace.pop();
            }
            // options.end_comma
            if (options.lexer_options.script.end_comma !== undefined && options.lexer_options.script.end_comma !== "none" && parse.structure[parse.structure.length - 1][0] === "array" || parse.structure[parse.structure.length - 1][0] === "object" || parse.structure[parse.structure.length - 1][0] === "data_type") {
                if (options.lexer_options.script.end_comma === "always" && data.token[parse.count] !== ",") {
                    const begin = parse.structure[parse.structure.length - 1][1];
                    let y = parse.count;
                    do {
                        if (data.begin[y] === begin) {
                            if (data.token[y] === ",") {
                                break;
                            }
                        }
                        else {
                            y = data.begin[y];
                        }
                        y = y - 1;
                    } while (y > begin);
                    if (y > begin) {
                        const type = ltype, toke = ltoke;
                        ltoke = ",";
                        ltype = "separator";
                        recordPush("");
                        ltoke = toke;
                        ltype = type;
                    }
                }
                else if (options.lexer_options.script.end_comma === "never" && data.token[parse.count] === ",") {
                    parse.pop(data);
                }
            }
            if (newarr === false) {
                recordPush("");
                if (ltoke === "}" && data.stack[parse.count] !== "object" && data.stack[parse.count] !== "class" && data.stack[parse.count] !== "data_type") {
                    references.pop();
                    blockinsert();
                }
            }
            if (insert === true) {
                ltoke = (options.correct === true)
                    ? "{"
                    : "x{";
                ltype = "start";
                recordPush(pword[0]);
                brace.push("x{");
                pword[1] = parse.count;
            }
            datatype.pop();
            if (parse.structure[parse.structure.length - 1][0] !== "data_type") {
                datatype[datatype.length - 1] = false;
            }
        }, 
        // the general function is a generic tokenizer start argument contains the
        // token's starting syntax offset argument is length of start minus control
        // chars end is how is to identify where the token ends
        general = function lexer_script_general(starting, ending, type) {
            let ee = 0, escape = false, ext = false, build = [starting], ender = ending.split(""), temp;
            const endlen = ender.length, start = a, qc = (options.lexer_options.script.quote_convert === undefined)
                ? "none"
                : options.lexer_options.script.quote_convert, base = a + starting.length, cleanUp = function lexer_script_general_cleanUp() {
                let linesSpace = 0;
                build = [];
                ltype = type;
                ee = a;
                if (type === "string" && (/\s/).test(c[ee + 1]) === true) {
                    linesSpace = 1;
                    do {
                        ee = ee + 1;
                        if (c[ee] === "\n") {
                            linesSpace = linesSpace + 1;
                        }
                    } while (ee < b && (/\s/).test(c[ee + 1]) === true);
                    parse.linesSpace = linesSpace;
                }
            }, finish = function lexer_script_general_finish() {
                let str = "";
                //pads certain template tag delimiters with a space
                const bracketSpace = function lexer_script_general_finish_bracketSpace(input) {
                    if (options.language !== "javascript" && options.language !== "typescript" && options.language !== "jsx" && options.language !== "tsx") {
                        const spaceStart = function lexer_script_general_finish_bracketSpace_spaceStart(start) {
                            return start.replace(/\s*$/, " ");
                        }, spaceEnd = function lexer_script_general_finish_bracketSpace_spaceStart(end) {
                            return end.replace(/^\s*/, " ");
                        };
                        if ((/\{(#|\/|(%>)|(%\]))/).test(input) === true || (/\}%(>|\])/).test(input) === true) {
                            return input;
                        }
                        input = input.replace(/\{((\{+)|%-?)\s*/g, spaceStart);
                        input = input.replace(/\s*((\}\}+)|(-?%\}))/g, spaceEnd);
                        return input;
                    }
                    return input;
                };
                if (starting === "\"" && qc === "single") {
                    build[0] = "'";
                    build[build.length - 1] = "'";
                }
                else if (starting === "'" && qc === "double") {
                    build[0] = "\"";
                    build[build.length - 1] = "\"";
                }
                else if (escape === true) {
                    str = build[build.length - 1];
                    build.pop();
                    build.pop();
                    build.push(str);
                }
                a = ee;
                if (ending === "\n") {
                    a = a - 1;
                    build.pop();
                }
                ltoke = build.join("");
                if (starting === "\"" || starting === "'" || starting === "{{" || starting === "{%" || starting === "{{{") {
                    ltoke = bracketSpace(ltoke);
                }
                if (starting === "{%" || starting === "{{") {
                    temp = tname(ltoke);
                    ltype = temp[0];
                    recordPush(temp[1]);
                    return;
                }
                if (type === "string") {
                    ltype = "string";
                    if (options.language === "json") {
                        ltoke = ltoke
                            .replace(/\u0000/g, "\\u0000")
                            .replace(/\u0001/g, "\\u0001")
                            .replace(/\u0002/g, "\\u0002")
                            .replace(/\u0003/g, "\\u0003")
                            .replace(/\u0004/g, "\\u0004")
                            .replace(/\u0005/g, "\\u0005")
                            .replace(/\u0006/g, "\\u0006")
                            .replace(/\u0007/g, "\\u0007")
                            .replace(/\u0008/g, "\\u0008")
                            .replace(/\u0009/g, "\\u0009")
                            .replace(/\u000a/g, "\\u000a")
                            .replace(/\u000b/g, "\\u000b")
                            .replace(/\u000c/g, "\\u000c")
                            .replace(/\u000d/g, "\\u000d")
                            .replace(/\u000e/g, "\\u000e")
                            .replace(/\u000f/g, "\\u000f")
                            .replace(/\u0010/g, "\\u0010")
                            .replace(/\u0011/g, "\\u0011")
                            .replace(/\u0012/g, "\\u0012")
                            .replace(/\u0013/g, "\\u0013")
                            .replace(/\u0014/g, "\\u0014")
                            .replace(/\u0015/g, "\\u0015")
                            .replace(/\u0016/g, "\\u0016")
                            .replace(/\u0017/g, "\\u0017")
                            .replace(/\u0018/g, "\\u0018")
                            .replace(/\u0019/g, "\\u0019")
                            .replace(/\u001a/g, "\\u001a")
                            .replace(/\u001b/g, "\\u001b")
                            .replace(/\u001c/g, "\\u001c")
                            .replace(/\u001d/g, "\\u001d")
                            .replace(/\u001e/g, "\\u001e")
                            .replace(/\u001f/g, "\\u001f");
                    }
                    else if (starting.indexOf("#!") === 0) {
                        ltoke = ltoke.slice(0, ltoke.length - 1);
                        parse.linesSpace = 2;
                    }
                    else if (parse.structure[parse.structure.length - 1][0] !== "object" || (parse.structure[parse.structure.length - 1][0] === "object" && nextchar(1, false) !== ":" && data.token[parse.count] !== "," && data.token[parse.count] !== "{")) {
                        if ((ltoke.length > options.wrap && options.wrap > 0) || (options.wrap !== 0 && data.token[parse.count] === "+" && (data.token[parse.count - 1].charAt(0) === "\"" || data.token[parse.count - 1].charAt(0) === "'"))) {
                            let item = ltoke, q = (qc === "double")
                                ? "\""
                                : (qc === "single")
                                    ? "'"
                                    : item.charAt(0), segment = "";
                            const limit = options.wrap, uchar = (/u[0-9a-fA-F]{4}/), xchar = (/x[0-9a-fA-F]{2}/);
                            item = item.slice(1, item.length - 1);
                            if (data.token[parse.count] === "+" && (data.token[parse.count - 1].charAt(0) === "\"" || data.token[parse.count - 1].charAt(0) === "'")) {
                                parse.pop(data);
                                q = data.token[parse.count].charAt(0);
                                item = data.token[parse.count].slice(1, data.token[parse.count].length - 1) + item;
                                parse.pop(data);
                            }
                            if (item.length > limit && limit > 0) {
                                do {
                                    segment = item.slice(0, limit);
                                    if (segment.charAt(limit - 5) === "\\" && uchar.test(item.slice(limit - 4, limit + 1)) === true) {
                                        segment = segment.slice(0, limit - 5);
                                    }
                                    else if (segment.charAt(limit - 4) === "\\" && uchar.test(item.slice(limit - 3, limit + 2)) === true) {
                                        segment = segment.slice(0, limit - 4);
                                    }
                                    else if (segment.charAt(limit - 3) === "\\" && (uchar.test(item.slice(limit - 2, limit + 3)) === true || xchar.test(item.slice(limit - 2, limit + 1)) === true)) {
                                        segment = segment.slice(0, limit - 3);
                                    }
                                    else if (segment.charAt(limit - 2) === "\\" && (uchar.test(item.slice(limit - 1, limit + 4)) === true || xchar.test(item.slice(limit - 1, limit + 2)) === true)) {
                                        segment = segment.slice(0, limit - 2);
                                    }
                                    else if (segment.charAt(limit - 1) === "\\") {
                                        segment = segment.slice(0, limit - 1);
                                    }
                                    segment = q + segment + q;
                                    item = item.slice(segment.length - 2);
                                    ltoke = segment;
                                    ltype = "string";
                                    recordPush("");
                                    parse.linesSpace = 0;
                                    ltoke = "+";
                                    ltype = "operator";
                                    recordPush("");
                                } while (item.length > limit);
                            }
                            if (item === "") {
                                ltoke = q + q;
                            }
                            else {
                                ltoke = q + item + q;
                            }
                            ltype = "string";
                        }
                    }
                }
                else if ((/\{\s*\?>$/).test(ltoke) === true) {
                    if ((/^<\?(=|(php))\s*\}\s*else/).test(ltoke) === true) {
                        ltype = "template_else";
                    }
                    else {
                        ltype = "template_start";
                    }
                }
                else if ((/^<\?(=|(php))\s*\}/).test(ltoke) === true) {
                    if ((/^<\?(=|(php))\s*\}\s*else/).test(ltoke) === true) {
                        ltype = "template_else";
                    }
                    else {
                        ltype = "template_end";
                    }
                }
                else {
                    ltype = type;
                }
                if (ltoke.length > 0) {
                    recordPush("");
                }
            };
            if (wordTest > -1) {
                word();
            }
            // this insanity is for JSON where all the required quote characters are
            // escaped.
            if (c[a - 1] === "\\" && slashes(a - 1) === true && (c[a] === "\"" || c[a] === "'")) {
                parse.pop(data);
                if (data.token[0] === "{") {
                    if (c[a] === "\"") {
                        starting = "\"";
                        ending = "\\\"";
                        build = ["\""];
                    }
                    else {
                        starting = "'";
                        ending = "\\'";
                        build = ["'"];
                    }
                    escape = true;
                }
                else {
                    if (c[a] === "\"") {
                        build = ["\\\""];
                        finish();
                        return;
                    }
                    build = ["\\'"];
                    finish();
                    return;
                }
            }
            ee = base;
            if (ee < b) {
                do {
                    if (data.token[0] !== "{" && data.token[0] !== "[" && qc !== "none" && (c[ee] === "\"" || c[ee] === "'")) {
                        if (c[ee - 1] === "\\") {
                            if (slashes(ee - 1) === true) {
                                if (qc === "double" && c[ee] === "'") {
                                    build.pop();
                                }
                                else if (qc === "single" && c[ee] === "\"") {
                                    build.pop();
                                }
                            }
                        }
                        else if (qc === "double" && c[ee] === "\"" && c[a] === "'") {
                            c[ee] = "\\\"";
                        }
                        else if (qc === "single" && c[ee] === "'" && c[a] === "\"") {
                            c[ee] = "\\'";
                        }
                        build.push(c[ee]);
                    }
                    else if (ee > start) {
                        ext = true;
                        if (c[ee] === "<" && c[ee + 1] === "?" && c[ee + 2] === "p" && c[ee + 3] === "h" && c[ee + 4] === "p" && c[ee + 5] !== starting) {
                            finish();
                            // php
                            lexer_script_general("<?php", "?>", "template");
                            cleanUp();
                        }
                        else if (c[ee] === "<" && c[ee + 1] === "?" && c[ee + 2] === "=" && c[ee + 3] !== starting) {
                            finish();
                            // php
                            lexer_script_general("<?=", "?>", "template");
                            cleanUp();
                        }
                        else if (c[ee] === "<" && c[ee + 1] === "%" && c[ee + 2] !== starting) {
                            finish();
                            // asp
                            lexer_script_general("<%", "%>", "template");
                            cleanUp();
                        }
                        else if (c[ee] === "{" && c[ee + 1] === "%" && c[ee + 2] !== starting) {
                            finish();
                            // twig
                            lexer_script_general("{%", "%}", "template");
                            cleanUp();
                        }
                        else if (c[ee] === "{" && c[ee + 1] === "{" && c[ee + 2] === "{" && c[ee + 3] !== starting) {
                            finish();
                            // mustache
                            lexer_script_general("{{{", "}}}", "template");
                            cleanUp();
                        }
                        else if (c[ee] === "{" && c[ee + 1] === "{" && c[ee + 2] !== starting) {
                            finish();
                            // handlebars
                            lexer_script_general("{{", "}}", "template");
                            cleanUp();
                        }
                        else if (c[ee] === "<" && c[ee + 1] === "!" && c[ee + 2] === "-" && c[ee + 3] === "-" && c[ee + 4] === "#" && c[ee + 5] !== starting) {
                            finish();
                            // ssi
                            lexer_script_general("<!--#", "-->", "template");
                            cleanUp();
                        }
                        else {
                            ext = false;
                            build.push(c[ee]);
                        }
                    }
                    else {
                        build.push(c[ee]);
                    }
                    if ((starting === "\"" || starting === "'") && (ext === true || ee > start) && options.language !== "json" && c[ee - 1] !== "\\" && c[ee] !== "\"" && c[ee] !== "'" && (c[ee] === "\n" || ee === b - 1)) {
                        sparser.parseerror = "Unterminated string in script on line number " + parse.lineNumber;
                        break;
                    }
                    if (c[ee] === ender[endlen - 1] && (c[ee - 1] !== "\\" || slashes(ee - 1) === false)) {
                        if (endlen === 1) {
                            break;
                        }
                        // `ee - base` is a cheap means of computing length of build array the `ee -
                        // base` and `endlen` are both length based values, so adding two (1 for each)
                        // provides an index based number
                        if (build[ee - base] === ender[0] && build.slice(ee - base - endlen + 2).join("") === ending) {
                            break;
                        }
                    }
                    ee = ee + 1;
                } while (ee < b);
            }
            finish();
        }, 
        // line comments
        lineComment = function lexer_script_lineComment() {
            asi(false);
            blockinsert();
            if (wordTest > -1) {
                word();
            }
            comment = parse.wrapCommentLine({
                chars: c,
                end: b,
                lexer: "script",
                opening: "//",
                start: a,
                terminator: "\n"
            });
            a = comment[1];
            if (comment[0] !== "") {
                ltoke = comment[0];
                ltype = (/^(\/\/\s*parse-ignore-start)/).test(ltoke)
                    ? "ignore"
                    : "comment";
                if (ltoke.indexOf("# sourceMappingURL=") === 2) {
                    sourcemap[0] = parse.count + 1;
                    sourcemap[1] = ltoke;
                }
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "script",
                    lines: parse.linesSpace,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: ltoke,
                    types: ltype
                }, "");
            }
        }, 
        // Identifies blocks of markup embedded within JavaScript for language super sets
        // like React JSX.
        markup = function lexer_script_markup() {
            let curlytest = false, endtag = false, anglecount = 0, curlycount = 0, tagcount = 0, d = 0, next = "", priorToken = "", priorType = "", output = [];
            const dt = datatype[datatype.length - 1], syntaxnum = "0123456789=<>+-*?|^:&.,;%(){}[]~", applyMarkup = function lexer_script_markup_applyMarkup() {
                if (ltoke === "(") {
                    parse.structure[parse.structure.length - 1] = ["paren", parse.count];
                }
                sparser.lexers.markup(output.join(""));
            };
            if (wordTest > -1) {
                word();
            }
            // type generics tokenizer
            priorToken = (parse.count > 0)
                ? data.token[parse.count - 1]
                : "";
            priorType = (parse.count > 0)
                ? data.types[parse.count - 1]
                : "";
            next = nextchar(1, false);
            if (options.language !== "jsx" && options.language !== "tsx" && (/\d/).test(next) === false && (ltoke === "function" ||
                priorToken === "=>" ||
                priorToken === "void" ||
                priorToken === "." ||
                data.stack[parse.count] === "arguments" ||
                ((options.language === "csharp" || options.language === "java") && priorToken === "public" || priorToken === "private" || priorToken === "final" || priorToken === "static") ||
                (ltype === "type" && priorToken === "type") ||
                (ltype === "reference" && (priorType === "operator" || priorToken === "function" || priorToken === "class" || priorToken === "new")) ||
                (ltype === "type" && priorType === "operator") ||
                ltoke === "return" ||
                ltype === "operator")) {
                let inc = 0, e = 0;
                const build = [];
                d = a;
                do {
                    build.push(c[d]);
                    if (c[d] === "<") {
                        inc = inc + 1;
                    }
                    else if (c[d] === ">") {
                        inc = inc - 1;
                        if (inc < 1) {
                            break;
                        }
                    }
                    d = d + 1;
                } while (d < b);
                e = a;
                a = d;
                next = nextchar(1, false);
                if (c[d] === ">" && (dt === true || priorToken === "=>" || priorToken === "." || priorType !== "operator" || (priorType === "operator" && (next === "(" || next === "=")))) {
                    ltype = "generic";
                    ltoke = build.join("").replace(/^<\s+/, "<").replace(/\s+>$/, ">").replace(/,\s*/g, ", ");
                    recordPush("");
                    return;
                }
                a = e;
            }
            d = parse.count;
            if (data.types[d] === "comment") {
                do {
                    d = d - 1;
                } while (d > 0 && data.types[d] === "comment");
            }
            if (dt === false &&
                nextchar(1, false) !== ">" && ((c[a] !== "<" && syntaxnum.indexOf(c[a + 1]) > -1) ||
                data.token[d] === "++" ||
                data.token[d] === "--" ||
                (/\s/).test(c[a + 1]) === true ||
                ((/\d/).test(c[a + 1]) === true &&
                    (ltype === "operator" ||
                        ltype === "string" ||
                        ltype === "number" ||
                        ltype === "reference" ||
                        (ltype === "word" && ltoke !== "return"))))) {
                ltype = "operator";
                ltoke = operator();
                return recordPush("");
            }
            if (options.language !== "typescript" && options.language !== "flow" && (data.token[d] === "return" || data.types[d] === "operator" || data.types[d] === "start" || data.types[d] === "separator" || data.types[d] === "jsx_attribute_start" || (data.token[d] === "}" && parse.structure[parse.structure.length - 1][0] === "global"))) {
                ltype = "markup";
                options.language = "jsx";
                do {
                    output.push(c[a]);
                    if (c[a] === "{") {
                        curlycount = curlycount + 1;
                        curlytest = true;
                    }
                    else if (c[a] === "}") {
                        curlycount = curlycount - 1;
                        if (curlycount === 0) {
                            curlytest = false;
                        }
                    }
                    else if (c[a] === "<" && curlytest === false) {
                        if (c[a + 1] === "<") {
                            do {
                                output.push(c[a]);
                                a = a + 1;
                            } while (a < b && c[a + 1] === "<");
                        }
                        anglecount = anglecount + 1;
                        if (nextchar(1, false) === "/") {
                            endtag = true;
                        }
                    }
                    else if (c[a] === ">" && curlytest === false) {
                        if (c[a + 1] === ">") {
                            do {
                                output.push(c[a]);
                                a = a + 1;
                            } while (c[a + 1] === ">");
                        }
                        anglecount = anglecount - 1;
                        if (endtag === true) {
                            tagcount = tagcount - 1;
                        }
                        else if (c[a - 1] !== "/") {
                            tagcount = tagcount + 1;
                        }
                        if (anglecount === 0 && curlycount === 0 && tagcount < 1) {
                            next = nextchar(2, false);
                            if (next.charAt(0) !== "<") {
                                // if followed by nonmarkup
                                return applyMarkup();
                            }
                            // catch additional trailing tag sets
                            if (next.charAt(0) === "<" && syntaxnum.indexOf(next.charAt(1)) < 0 && (/\s/).test(next.charAt(1)) === false) {
                                // perform a minor safety test to verify if "<" is a tag start or a less than
                                // operator
                                d = a + 1;
                                do {
                                    d = d + 1;
                                    if (c[d] === ">" || ((/\s/).test(c[d - 1]) === true && syntaxnum.indexOf(c[d]) < 0)) {
                                        break;
                                    }
                                    if (syntaxnum.indexOf(c[d]) > -1) {
                                        // if followed by additional markup tags
                                        return applyMarkup();
                                    }
                                } while (d < b);
                            }
                            else {
                                // if a nonmarkup "<" follows markup
                                return applyMarkup();
                            }
                        }
                        endtag = false;
                    }
                    a = a + 1;
                } while (a < b);
                return applyMarkup();
            }
            ltype = "operator";
            ltoke = operator();
            recordPush("");
            return;
        }, 
        // peek at whats up next
        nextchar = function lexer_script_nextchar(len, current) {
            let cc = (current === true)
                ? a
                : a + 1, dd = "";
            if (typeof len !== "number" || len < 1) {
                len = 1;
            }
            if (c[a] === "/") {
                if (c[a + 1] === "/") {
                    dd = "\n";
                }
                else if (c[a + 1] === "*") {
                    dd = "/";
                }
            }
            if (cc < b) {
                do {
                    if ((/\s/).test(c[cc]) === false) {
                        if (c[cc] === "/") {
                            if (dd === "") {
                                if (c[cc + 1] === "/") {
                                    dd = "\n";
                                }
                                else if (c[cc + 1] === "*") {
                                    dd = "/";
                                }
                            }
                            else if (dd === "/" && c[cc - 1] === "*") {
                                dd = "";
                            }
                        }
                        if (dd === "" && c[cc - 1] + c[cc] !== "\u002a/") {
                            return c
                                .slice(cc, cc + len)
                                .join("");
                        }
                    }
                    else if (dd === "\n" && c[cc] === "\n") {
                        dd = "";
                    }
                    cc = cc + 1;
                } while (cc < b);
            }
            return "";
        }, 
        // a tokenizer for numbers
        numb = function lexer_script_number() {
            const f = b, build = [c[a]];
            let ee = 0, test = /zz/, dot = (build[0] === ".");
            if (a < b - 2 && c[a] === "0") {
                if (c[a + 1] === "x") {
                    test = /[0-9a-fA-F]/;
                }
                else if (c[a + 1] === "o") {
                    test = /[0-9]/;
                }
                else if (c[a + 1] === "b") {
                    test = /0|1/;
                }
                if (test.test(c[a + 2]) === true) {
                    build.push(c[a + 1]);
                    ee = a + 1;
                    do {
                        ee = ee + 1;
                        build.push(c[ee]);
                    } while (test.test(c[ee + 1]) === true);
                    a = ee;
                    return build.join("");
                }
            }
            ee = a + 1;
            if (ee < f) {
                do {
                    if ((/[0-9]/).test(c[ee]) || (c[ee] === "." && dot === false)) {
                        build.push(c[ee]);
                        if (c[ee] === ".") {
                            dot = true;
                        }
                    }
                    else {
                        break;
                    }
                    ee = ee + 1;
                } while (ee < f);
            }
            if (ee < f - 1 && ((/\d/).test(c[ee - 1]) === true || ((/\d/).test(c[ee - 2]) === true && (c[ee - 1] === "-" || c[ee - 1] === "+"))) && (c[ee] === "e" || c[ee] === "E")) {
                build.push(c[ee]);
                if (c[ee + 1] === "-" || c[ee + 1] === "+") {
                    build.push(c[ee + 1]);
                    ee = ee + 1;
                }
                dot = false;
                ee = ee + 1;
                if (ee < f) {
                    do {
                        if ((/[0-9]/).test(c[ee]) || (c[ee] === "." && dot === false)) {
                            build.push(c[ee]);
                            if (c[ee] === ".") {
                                dot = true;
                            }
                        }
                        else {
                            break;
                        }
                        ee = ee + 1;
                    } while (ee < f);
                }
            }
            a = ee - 1;
            return build.join("");
        }, 
        // a unique tokenizer for operator characters
        operator = function lexer_script_operator() {
            let g = 0, h = 0, jj = b, output = "";
            const syntax = [
                "=",
                "<",
                ">",
                "+",
                "*",
                "?",
                "|",
                "^",
                ":",
                "&",
                "%",
                "~"
            ], synlen = syntax.length;
            if (wordTest > -1) {
                word();
            }
            if (c[a] === "/" && (parse.count > -1 && ((ltype !== "word" && ltype !== "reference") || ltoke === "typeof" || ltoke === "return" || ltoke === "else") && ltype !== "number" && ltype !== "string" && ltype !== "end")) {
                if (ltoke === "return" || ltoke === "typeof" || ltoke === "else" || ltype !== "word") {
                    ltoke = regex();
                    ltype = "regex";
                }
                else {
                    ltoke = "/";
                    ltype = "operator";
                }
                recordPush("");
                return "regex";
            }
            if (c[a] === "?" && ("+-\u002a/.?".indexOf(c[a + 1]) > -1 || (c[a + 1] === ":" && syntax.join("").indexOf(c[a + 2]) < 0))) {
                if (c[a + 1] === "." && (/\d/).test(c[a + 2]) === false) {
                    output = "?.";
                }
                else if (c[a + 1] === "?") {
                    output = "??";
                }
                if (output === "") {
                    return "?";
                }
            }
            if (c[a] === ":" && "+-\u002a/".indexOf(c[a + 1]) > -1) {
                return ":";
            }
            if (a < b - 1) {
                if (c[a] !== "<" && c[a + 1] === "<") {
                    return c[a];
                }
                if (c[a] === "!" && c[a + 1] === "/") {
                    return "!";
                }
                if (c[a] === "-") {
                    datatype[datatype.length - 1] = false;
                    if (c[a + 1] === "-") {
                        output = "--";
                    }
                    else if (c[a + 1] === "=") {
                        output = "-=";
                    }
                    else if (c[a + 1] === ">") {
                        output = "->";
                    }
                    if (output === "") {
                        return "-";
                    }
                }
                if (c[a] === "+") {
                    datatype[datatype.length - 1] = false;
                    if (c[a + 1] === "+") {
                        output = "++";
                    }
                    else if (c[a + 1] === "=") {
                        output = "+=";
                    }
                    if (output === "") {
                        return "+";
                    }
                }
                if (c[a] === "=" && c[a + 1] !== "=" && c[a + 1] !== "!" && c[a + 1] !== ">") {
                    datatype[datatype.length - 1] = false;
                    return "=";
                }
            }
            if (c[a] === ":") {
                if (options.language === "typescript" || options.language === "flow") {
                    if (data.stack[parse.count] === "arguments") {
                        if (data.token[parse.count] === "?") {
                            parse.pop(data);
                            output = "?:";
                            a = a - 1;
                        }
                        datatype[datatype.length - 1] = true;
                    }
                    else if (ltoke === ")" && (data.token[data.begin[parse.count] - 1] === "function" || data.token[data.begin[parse.count] - 2] === "function")) {
                        datatype[datatype.length - 1] = true;
                    }
                    else if (ltype === "reference") {
                        g = parse.count;
                        let colon = false;
                        do {
                            if (data.begin[g] === data.begin[parse.count]) {
                                if (g < parse.count && data.token[g] === ":" && data.types[g + 1] !== "type") {
                                    colon = true;
                                }
                                if (data.token[g] === "?" && colon === false) {
                                    break;
                                }
                                if (data.token[g] === ";" || data.token[g] === "x;") {
                                    break;
                                }
                                if (data.token[g] === "var" || data.token[g] === "let" || data.token[g] === "const" || data.types[g] === "type") {
                                    datatype[datatype.length - 1] = true;
                                    break;
                                }
                            }
                            else {
                                if (data.types[g] === "type_end") {
                                    datatype[datatype.length - 1] = true;
                                    break;
                                }
                                g = data.begin[g];
                            }
                            g = g - 1;
                        } while (g > data.begin[parse.count]);
                    }
                }
                else if ((data.types[parse.count] === "word" || data.types[parse.count] === "reference") && data.token[parse.count - 1] === "[") {
                    parse.structure[parse.structure.length - 1][0] = "attribute";
                    data.stack[parse.count] = "attribute";
                }
            }
            if (output === "") {
                if ((c[a + 1] === "+" && c[a + 2] === "+") || (c[a + 1] === "-" && c[a + 2] === "-")) {
                    output = c[a];
                }
                else {
                    const buildout = [c[a]];
                    g = a + 1;
                    if (g < jj) {
                        do {
                            if ((c[g] === "+" && c[g + 1] === "+") || (c[g] === "-" && c[g + 1] === "-")) {
                                break;
                            }
                            h = 0;
                            if (h < synlen) {
                                do {
                                    if (c[g] === syntax[h]) {
                                        buildout.push(syntax[h]);
                                        break;
                                    }
                                    h = h + 1;
                                } while (h < synlen);
                            }
                            if (h === synlen) {
                                break;
                            }
                            g = g + 1;
                        } while (g < jj);
                    }
                    output = buildout.join("");
                }
            }
            a = a + (output.length - 1);
            if (output === "=>" && ltoke === ")") {
                g = parse.count;
                jj = data.begin[g];
                do {
                    if (data.begin[g] === jj) {
                        data.stack[g] = "method";
                    }
                    g = g - 1;
                } while (g > jj - 1);
            }
            return output;
        }, 
        // convert ++ and -- into "= x +"  and "= x -" in most cases
        plusplus = function lexer_script_plusplus() {
            let pre = true, toke = "+", tokea = "", tokeb = "", tokec = "", inc = 0, ind = 0, walk = 0, next = "";
            const store = [], end = function lexer_script_plusplus_end() {
                walk = data.begin[walk] - 1;
                if (data.types[walk] === "end") {
                    lexer_script_plusplus_end();
                }
                else if (data.token[walk - 1] === ".") {
                    period();
                }
            }, period = function lexer_script_plusplus_period() {
                walk = walk - 2;
                if (data.types[walk] === "end") {
                    end();
                }
                else if (data.token[walk - 1] === ".") {
                    lexer_script_plusplus_period();
                }
            }, applyStore = function lexer_script_plusplus_applyStore() {
                let x = 0;
                const y = store.length;
                if (x < y) {
                    do {
                        parse.push(data, store[x], "");
                        x = x + 1;
                    } while (x < y);
                }
            }, recordStore = function lexer_script_plusplus_recordStore(index) {
                return {
                    begin: data.begin[index],
                    ender: data.ender[index],
                    lexer: data.lexer[index],
                    lines: data.lines[index],
                    stack: data.stack[index],
                    token: data.token[index],
                    types: data.types[index]
                };
            };
            tokea = data.token[parse.count];
            tokeb = data.token[parse.count - 1];
            tokec = data.token[parse.count - 2];
            if (tokea !== "++" && tokea !== "--" && tokeb !== "++" && tokeb !== "--") {
                walk = parse.count;
                if (data.types[walk] === "end") {
                    end();
                }
                else if (data.token[walk - 1] === ".") {
                    period();
                }
            }
            if (data.token[walk - 1] === "++" || data.token[walk - 1] === "--") {
                if ("startendoperator".indexOf(data.types[walk - 2]) > -1) {
                    return;
                }
                inc = walk;
                if (inc < parse.count + 1) {
                    do {
                        store.push(recordStore(inc));
                        inc = inc + 1;
                    } while (inc < parse.count + 1);
                    parse.splice({
                        data: data,
                        howmany: parse.count - walk,
                        index: walk
                    });
                }
            }
            else {
                if (options.correct === false || (tokea !== "++" && tokea !== "--" && tokeb !== "++" && tokeb !== "--")) {
                    return;
                }
                next = nextchar(1, false);
                if ((tokea === "++" || tokea === "--") && (c[a] === ";" || next === ";" || c[a] === "}" || next === "}" || c[a] === ")" || next === ")")) {
                    toke = data.stack[parse.count];
                    if (toke === "array" || toke === "method" || toke === "object" || toke === "paren" || toke === "notation" || (data.token[data.begin[parse.count] - 1] === "while" && toke !== "while")) {
                        return;
                    }
                    inc = parse.count;
                    do {
                        inc = inc - 1;
                        if (data.token[inc] === "return") {
                            return;
                        }
                        if (data.types[inc] === "end") {
                            do {
                                inc = data.begin[inc] - 1;
                            } while (data.types[inc] === "end" && inc > 0);
                        }
                    } while (inc > 0 && (data.token[inc] === "." || data.types[inc] === "word" || data.types[inc] === "reference" || data.types[inc] === "end"));
                    if (data.token[inc] === "," && c[a] !== ";" && next !== ";" && c[a] !== "}" && next !== "}" && c[a] !== ")" && next !== ")") {
                        return;
                    }
                    if (data.types[inc] === "operator") {
                        if (data.stack[inc] === "switch" && data.token[inc] === ":") {
                            do {
                                inc = inc - 1;
                                if (data.types[inc] === "start") {
                                    ind = ind - 1;
                                    if (ind < 0) {
                                        break;
                                    }
                                }
                                else if (data.types[inc] === "end") {
                                    ind = ind + 1;
                                }
                                if (data.token[inc] === "?" && ind === 0) {
                                    return;
                                }
                            } while (inc > 0);
                        }
                        else {
                            return;
                        }
                    }
                    pre = false;
                    if (tokea === "--") {
                        toke = "-";
                    }
                    else {
                        toke = "+";
                    }
                }
                else if (tokec === "[" || tokec === ";" || tokec === "x;" || tokec === "}" || tokec === "{" || tokec === "(" || tokec === ")" || tokec === "," || tokec === "return") {
                    if (tokea === "++" || tokea === "--") {
                        if (tokec === "[" || tokec === "(" || tokec === "," || tokec === "return") {
                            return;
                        }
                        if (tokea === "--") {
                            toke = "-";
                        }
                        pre = false;
                    }
                    else if (tokeb === "--" || tokea === "--") {
                        toke = "-";
                    }
                }
                else {
                    return;
                }
                if (pre === false) {
                    tempstore = parse.pop(data);
                }
                walk = parse.count;
                if (data.types[walk] === "end") {
                    end();
                }
                else if (data.token[walk - 1] === ".") {
                    period();
                }
                inc = walk;
                if (inc < parse.count + 1) {
                    do {
                        store.push(recordStore(inc));
                        inc = inc + 1;
                    } while (inc < parse.count + 1);
                }
            }
            if (pre === true) {
                parse.splice({
                    data: data,
                    howmany: 1,
                    index: walk - 1
                });
                ltoke = "=";
                ltype = "operator";
                recordPush("");
                applyStore();
                ltoke = toke;
                ltype = "operator";
                recordPush("");
                ltoke = "1";
                ltype = "number";
                recordPush("");
            }
            else {
                ltoke = "=";
                ltype = "operator";
                recordPush("");
                applyStore();
                ltoke = toke;
                ltype = "operator";
                recordPush("");
                ltoke = "1";
                ltype = "number";
                recordPush("");
            }
            ltoke = data.token[parse.count];
            ltype = data.types[parse.count];
            if (next === "}" && c[a] !== ";") {
                asi(false);
            }
        }, 
        // determine the definition of containment by stack
        recordPush = function lexer_script_recordPush(structure) {
            const record = {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "script",
                lines: parse.linesSpace,
                stack: parse.structure[parse.structure.length - 1][0],
                token: ltoke,
                types: ltype
            };
            parse.push(data, record, structure);
        }, 
        // a tokenizer for regular expressions
        regex = function lexer_script_regex() {
            let ee = a + 1, h = 0, i = 0, output = "", square = false;
            const f = b, build = ["/"];
            if (ee < f) {
                do {
                    build.push(c[ee]);
                    if (c[ee - 1] !== "\\" || c[ee - 2] === "\\") {
                        if (c[ee] === "[") {
                            square = true;
                        }
                        if (c[ee] === "]") {
                            square = false;
                        }
                    }
                    if (c[ee] === "/" && square === false) {
                        if (c[ee - 1] === "\\") {
                            i = 0;
                            h = ee - 1;
                            if (h > 0) {
                                do {
                                    if (c[h] === "\\") {
                                        i = i + 1;
                                    }
                                    else {
                                        break;
                                    }
                                    h = h - 1;
                                } while (h > 0);
                            }
                            if (i % 2 === 0) {
                                break;
                            }
                        }
                        else {
                            break;
                        }
                    }
                    ee = ee + 1;
                } while (ee < f);
            }
            if (c[ee + 1] === "g" || c[ee + 1] === "i" || c[ee + 1] === "m" || c[ee + 1] === "y" || c[ee + 1] === "u") {
                build.push(c[ee + 1]);
                if (c[ee + 2] !== c[ee + 1] && (c[ee + 2] === "g" || c[ee + 2] === "i" || c[ee + 2] === "m" || c[ee + 2] === "y" || c[ee + 2] === "u")) {
                    build.push(c[ee + 2]);
                    if (c[ee + 3] !== c[ee + 1] && c[ee + 3] !== c[ee + 2] && (c[ee + 3] === "g" || c[ee + 3] === "i" || c[ee + 3] === "m" || c[ee + 3] === "y" || c[ee + 3] === "u")) {
                        build.push(c[ee + 3]);
                        if (c[ee + 4] !== c[ee + 1] && c[ee + 4] !== c[ee + 2] && c[ee + 4] !== c[ee + 3] && (c[ee + 4] === "g" || c[ee + 4] === "i" || c[ee + 4] === "m" || c[ee + 4] === "y" || c[ee + 4] === "u")) {
                            build.push(c[ee + 4]);
                            if (c[ee + 5] !== c[ee + 1] && c[ee + 5] !== c[ee + 2] && c[ee + 5] !== c[ee + 3] && c[ee + 5] !== c[ee + 4] && (c[ee + 5] === "g" || c[ee + 5] === "i" || c[ee + 5] === "m" || c[ee + 5] === "y" || c[ee + 5] === "u")) {
                                build.push(c[ee + 4]);
                                a = ee + 5;
                            }
                            else {
                                a = ee + 4;
                            }
                        }
                        else {
                            a = ee + 3;
                        }
                    }
                    else {
                        a = ee + 2;
                    }
                }
                else {
                    a = ee + 1;
                }
            }
            else {
                a = ee;
            }
            output = build.join("");
            return output;
        }, 
        // determines if a slash comprises a valid escape or if it is escaped itself
        slashes = function lexer_script_slashes(index) {
            const slashy = index;
            do {
                index = index - 1;
            } while (c[index] === "\\" && index > 0);
            if ((slashy - index) % 2 === 1) {
                return true;
            }
            return false;
        }, 
        // operations for start types: (, [, {
        start = function lexer_script_start(x) {
            let aa = parse.count, wordx = "", wordy = "", stack = "", func = false;
            brace.push(x);
            if (x === "{" && (data.types[parse.count] === "type" || data.types[parse.count] === "type_end" || data.types[parse.count] === "generic")) {
                // this block determines if a function body follows a type annotation
                let begin = 0;
                if (data.types[parse.count] === "type_end") {
                    aa = data.begin[parse.count];
                }
                begin = aa;
                do {
                    aa = aa - 1;
                    if (data.begin[aa] !== begin && data.begin[aa] !== -1) {
                        break;
                    }
                    if (data.token[aa] === ":") {
                        break;
                    }
                } while (aa > data.begin[aa]);
                if (data.token[aa] === ":" && data.stack[aa - 1] === "arguments") {
                    datatype.push(false);
                    func = true;
                }
                else {
                    datatype.push(datatype[datatype.length - 1]);
                }
                aa = parse.count;
            }
            else if (x === "[" && data.types[parse.count] === "type_end") {
                datatype.push(true);
            }
            else {
                datatype.push(datatype[datatype.length - 1]);
            }
            if (wordTest > -1) {
                word();
                aa = parse.count;
            }
            if (vart.len > -1) {
                vart.count[vart.len] = vart.count[vart.len] + 1;
            }
            if (data.token[aa - 1] === "function") {
                lword.push([
                    "function", aa + 1
                ]);
            }
            else {
                lword.push([
                    ltoke, aa + 1
                ]);
            }
            ltoke = x;
            if (datatype[datatype.length - 1] === true) {
                ltype = "type_start";
            }
            else {
                ltype = "start";
            }
            if (x === "(" || x === "x(") {
                asifix();
            }
            else if (x === "{") {
                if (paren > -1) {
                    if (data.begin[paren - 1] === data.begin[data.begin[aa] - 1] || data.token[data.begin[aa]] === "x(") {
                        paren = -1;
                        if (options.correct === true) {
                            end(")");
                        }
                        else {
                            end("x)");
                        }
                        asifix();
                        ltoke = "{";
                        ltype = "start";
                    }
                }
                else if (ltoke === ")") {
                    asifix();
                }
                if (ltype === "comment" && data.token[aa - 1] === ")") {
                    ltoke = data.token[aa];
                    data.token[aa] = "{";
                    ltype = data.types[aa];
                    data.types[aa] = "start";
                }
            }
            wordx = (function lexer_script_start_wordx() {
                let bb = parse.count;
                if (data.types[bb] === "comment") {
                    do {
                        bb = bb - 1;
                    } while (bb > 0 && data.types[bb] === "comment");
                }
                return data.token[bb];
            }());
            wordy = (data.stack[aa] === undefined)
                ? ""
                : (function lexer_script_start_wordy() {
                    let bb = parse.count;
                    if (data.types[bb] === "comment") {
                        do {
                            bb = bb - 1;
                        } while (bb > 0 && data.types[bb] === "comment");
                    }
                    return data.token[data.begin[bb] - 1];
                }());
            if (ltoke === "{" && (data.types[aa] === "word" || data.token[aa] === "]")) {
                let bb = aa;
                if (data.token[bb] === "]") {
                    do {
                        bb = data.begin[bb] - 1;
                    } while (data.token[bb] === "]");
                }
                do {
                    if (data.types[bb] === "start" || data.types[bb] === "end" || data.types[bb] === "operator") {
                        break;
                    }
                    bb = bb - 1;
                } while (bb > 0);
                if (data.token[bb] === ":" && data.stack[bb - 1] === "arguments") {
                    stack = "function";
                    references.push(funreferences);
                    funreferences = [];
                }
            }
            if (ltype === "type_start") {
                stack = "data_type";
            }
            else if (stack === "" && (ltoke === "{" || ltoke === "x{")) {
                if (wordx === "else" || wordx === "do" || wordx === "try" || wordx === "finally" || wordx === "switch") {
                    stack = wordx;
                }
                else if (classy[classy.length - 1] === 0 && wordx !== "return") {
                    classy.pop();
                    stack = "class";
                }
                else if (data.token[aa - 1] === "class") {
                    stack = "class";
                }
                else if (data.token[aa] === "]" && data.token[aa - 1] === "[") {
                    stack = "array";
                }
                else if ((data.types[aa] === "word" || data.types[aa] === "reference") &&
                    (data.types[aa - 1] === "word" ||
                        data.types[aa - 1] === "reference" ||
                        (data.token[aa - 1] === "?" && (data.types[aa - 2] === "word" || data.types[aa - 2] === "reference"))) &&
                    data.token[aa] !== "in" &&
                    data.token[aa - 1] !== "export" &&
                    data.token[aa - 1] !== "import") {
                    stack = "map";
                }
                else if (data.stack[aa] === "method" &&
                    data.types[aa] === "end" &&
                    (data.types[data.begin[aa] - 1] === "word" || data.types[data.begin[aa] - 1] === "reference") &&
                    data.token[data.begin[aa] - 2] === "new") {
                    stack = "initializer";
                }
                else if (ltoke === "{" &&
                    (wordx === ")" || wordx === "x)") &&
                    (data.types[data.begin[aa] - 1] === "word" || data.types[data.begin[aa] - 1] === "reference" || data.token[data.begin[aa] - 1] === "]")) {
                    if (wordy === "if") {
                        stack = "if";
                    }
                    else if (wordy === "for") {
                        stack = "for";
                    }
                    else if (wordy === "while") {
                        stack = "while";
                    }
                    else if (wordy === "class") {
                        stack = "class";
                    }
                    else if (wordy === "switch" || data.token[data.begin[aa] - 1] === "switch") {
                        stack = "switch";
                    }
                    else if (wordy === "catch") {
                        stack = "catch";
                    }
                    else {
                        stack = "function";
                    }
                }
                else if (ltoke === "{" && (wordx === ";" || wordx === "x;")) {
                    // ES6 block
                    stack = "block";
                }
                else if (ltoke === "{" && data.token[aa] === ":" && data.stack[aa] === "switch") {
                    // ES6 block
                    stack = "block";
                }
                else if (data.token[aa - 1] === "import" || data.token[aa - 2] === "import" || data.token[aa - 1] === "export" || data.token[aa - 2] === "export") {
                    stack = "object";
                }
                else if (wordx === ")" && (pword[0] === "function" || pword[0] === "if" || pword[0] === "for" || pword[0] === "class" || pword[0] === "while" || pword[0] === "switch" || pword[0] === "catch")) {
                    // if preceeded by a paren the prior containment is preceeded by a keyword if
                    // (...) {
                    stack = pword[0];
                }
                else if (data.stack[aa] === "notation") {
                    // if following a TSX array type declaration
                    stack = "function";
                }
                else if ((data.types[aa] === "number" ||
                    data.types[aa] === "string" ||
                    data.types[aa] === "word" ||
                    data.types[aa] === "reference") &&
                    (data.types[aa - 1] === "word" || data.types[aa - 1] === "reference") &&
                    data.token[data.begin[aa] - 1] !== "for") {
                    // if preceed by a word and either string or word public class {
                    stack = "function";
                }
                else if (parse.structure.length > 0 && data.token[aa] !== ":" && parse.structure[parse.structure.length - 1][0] === "object" && (data.token[data.begin[aa] - 2] === "{" || data.token[data.begin[aa] - 2] === ",")) {
                    // if an object wrapped in some containment which is itself preceeded by a curly
                    // brace or comma var a={({b:{cat:"meow"}})};
                    stack = "function";
                }
                else if (data.types[pword[1] - 1] === "markup" && data.token[pword[1] - 3] === "function") {
                    // checking for TSX function using an angle brace name
                    stack = "function";
                }
                else if (wordx === "=>") {
                    // checking for fat arrow assignment
                    stack = "function";
                }
                else if (func === true || (data.types[parse.count] === "type_end" && data.stack[data.begin[parse.count] - 2] === "arguments")) {
                    // working around typescript inline interface
                    stack = "function";
                }
                else if (wordx === ")" &&
                    data.stack[aa] === "method" &&
                    (data.types[data.begin[aa] - 1] === "word" || data.types[data.begin[aa] - 1] === "property" || data.types[data.begin[aa] - 1] === "reference")) {
                    stack = "function";
                }
                else if (data.types[aa] === "word" && ltoke === "{" && data.token[aa] !== "return" && data.token[aa] !== "in" && data.token[aa] !== "import" && data.token[aa] !== "const" && data.token[aa] !== "let" && data.token[aa] !== "") {
                    // ES6 block
                    stack = "block";
                }
                else if (ltoke === "{" && (data.token[aa] === "x}" || data.token[aa] === "}") && "if|else|for|while|function|class|switch|catch|finally".indexOf(data.stack[aa]) > -1) {
                    // ES6 block
                    stack = "block";
                }
                else if (data.stack[aa] === "arguments") {
                    stack = "function";
                }
                else if (data.types[aa] === "generic") {
                    do {
                        aa = aa - 1;
                        if (data.token[aa] === "function" || data.stack[aa] === "arguments") {
                            stack = "function";
                            break;
                        }
                        if (data.token[aa] === "interface") {
                            stack = "map";
                            break;
                        }
                        if (data.token[aa] === ";") {
                            stack = "object";
                            break;
                        }
                    } while (aa > data.begin[parse.count]);
                }
                else if ((options.language === "java" || options.language === "csharp") && data.types[parse.count - 1] === "reference" && data.token[parse.count - 2] === "]") {
                    stack = "array";
                }
                else {
                    stack = "object";
                }
                if (stack !== "object" && stack !== "class") {
                    if (stack === "function") {
                        references.push(funreferences);
                        funreferences = [];
                    }
                    else {
                        references.push([]);
                    }
                }
            }
            else if (ltoke === "[") {
                if ((/\s/).test(c[a - 1]) === true && (data.types[aa] === "word" || data.types[aa] === "reference") && wordx !== "return" && options.language !== "twig") {
                    stack = "notation";
                }
                else {
                    stack = "array";
                }
            }
            else if (ltoke === "(" || ltoke === "x(") {
                if (wordx === "function" || data.token[aa - 1] === "function" || data.token[aa - 1] === "function*" || data.token[aa - 2] === "function") {
                    stack = "arguments";
                }
                else if (data.token[aa - 1] === "." || data.token[data.begin[aa] - 2] === ".") {
                    stack = "method";
                }
                else if (data.types[aa] === "generic") {
                    stack = "method";
                }
                else if (data.token[aa] === "}" && data.stack[aa] === "function") {
                    stack = "method";
                }
                else if (wordx === "if" || wordx === "for" || wordx === "class" || wordx === "while" || wordx === "catch" || wordx === "finally" || wordx === "switch" || wordx === "with") {
                    stack = "expression";
                }
                else if (data.types[aa] === "word" || data.types[aa] === "property" || data.types[aa] === "reference") {
                    stack = "method";
                }
                else {
                    stack = "paren";
                }
            }
            recordPush(stack);
            if (classy.length > 0) {
                classy[classy.length - 1] = classy[classy.length - 1] + 1;
            }
        }, 
        // ES6 template string support
        tempstring = function lexer_script_tempstring() {
            const output = [c[a]];
            a = a + 1;
            if (a < b) {
                do {
                    output.push(c[a]);
                    if (c[a] === "`" && (c[a - 1] !== "\\" || slashes(a - 1) === false)) {
                        break;
                    }
                    if (c[a - 1] === "$" && c[a] === "{" && (c[a - 2] !== "\\" || slashes(a - 2) === false)) {
                        break;
                    }
                    a = a + 1;
                } while (a < b);
            }
            return output.join("");
        }, 
        // determines tag names for {% %} based template tags and returns a type
        tname = function lexer_script_tname(x) {
            let sn = 2, en = 0, name = "";
            const st = x.slice(0, 2), len = x.length, namelist = [
                "autoescape",
                "block",
                "capture",
                "case",
                "comment",
                "embed",
                "filter",
                "for",
                "form",
                "if",
                "macro",
                "paginate",
                "raw",
                "sandbox",
                "spaceless",
                "tablerow",
                "unless",
                "verbatim"
            ];
            if (x.charAt(2) === "-") {
                sn = sn + 1;
            }
            if ((/\s/).test(x.charAt(sn)) === true) {
                do {
                    sn = sn + 1;
                } while ((/\s/).test(x.charAt(sn)) === true && sn < len);
            }
            en = sn;
            do {
                en = en + 1;
            } while ((/\s/).test(x.charAt(en)) === false && x.charAt(en) !== "(" && en < len);
            if (en === len) {
                en = x.length - 2;
            }
            name = x.slice(sn, en);
            if (name === "else" || (st === "{%" && (name === "elseif" || name === "when" || name === "elif"))) {
                return ["template_else", `template_${name}`];
            }
            if (st === "{{") {
                if (name === "end") {
                    return ["template_end", ""];
                }
                if ((name === "block" && (/\{%\s*\w/).test(source) === false) || name === "define" || name === "form" || name === "if" || name === "range" || name === "with") {
                    return ["template_start", `template_${name}`];
                }
                return ["template", ""];
            }
            en = namelist.length - 1;
            if (en > -1) {
                do {
                    if (name === namelist[en] && (name !== "block" || (/\{%\s*\w/).test(source) === false)) {
                        return ["template_start", `template_${name}`];
                    }
                    if (name === "end" + namelist[en]) {
                        return ["template_end", ""];
                    }
                    en = en - 1;
                } while (en > -1);
            }
            return ["template", ""];
        }, 
        // remove "vart" object data
        vartpop = function lexer_script_vartpop() {
            vart
                .count
                .pop();
            vart
                .index
                .pop();
            vart
                .word
                .pop();
            vart.len = vart.len - 1;
        }, 
        // A lexer for keywords, reserved words, and variables
        word = function lexer_script_word() {
            let f = wordTest, g = 1, output = "", nextitem = "", tokel = ltoke, typel = ltype;
            const lex = [], elsefix = function lexer_script_word_elsefix() {
                brace.push("x{");
                parse.splice({
                    data: data,
                    howmany: 1,
                    index: parse.count - 3
                });
            }, hoisting = function lexer_script_word_hoisting(index, ref, samescope) {
                const begin = data.begin[index];
                let parent = 0;
                do {
                    if (data.token[index] === ref && data.types[index] === "word") {
                        if (samescope === true) {
                            // the simple state is for hoisted references, var and function declarations
                            data.types[index] = "reference";
                        }
                        else if (data.begin[index] > begin && data.token[data.begin[index]] === "{" && data.stack[index] !== "object" && data.stack[index] !== "class" && data.stack[index] !== "data_type") {
                            // the complex state is for non-hoisted references living in prior functions of the same parent scope
                            if (data.stack[index] === "function") {
                                data.types[index] = "reference";
                            }
                            else {
                                // this looping is necessary to determine if there is a function between the reference and the declared scope
                                parent = data.begin[index];
                                do {
                                    if (data.stack[parent] === "function") {
                                        data.types[index] = "reference";
                                        break;
                                    }
                                    parent = data.begin[parent];
                                } while (parent > begin);
                            }
                        }
                    }
                    index = index - 1;
                } while (index > begin);
            };
            do {
                lex.push(c[f]);
                if (c[f] === "\\") {
                    sparser.parseerror = `Illegal escape in JavaScript on line number ${parse.lineNumber}`;
                }
                f = f + 1;
            } while (f < a);
            if (ltoke.charAt(0) === "\u201c") {
                sparser.parseerror = `Quote looking character (\u201c, \\u201c) used instead of actual quotes on line number ${parse.lineNumber}`;
            }
            else if (ltoke.charAt(0) === "\u201d") {
                sparser.parseerror = `Quote looking character (\u201d, \\u201d) used instead of actual quotes on line number ${parse.lineNumber}`;
            }
            output = lex.join("");
            wordTest = -1;
            if (parse.count > 0 && output === "function" && data.token[parse.count] === "(" && (data.token[parse.count - 1] === "{" || data.token[parse.count - 1] === "x{")) {
                data.types[parse.count] = "start";
            }
            if (parse.count > 1 && output === "function" && ltoke === "(" && (data.token[parse.count - 1] === "}" || data.token[parse.count - 1] === "x}")) {
                if (data.token[parse.count - 1] === "}") {
                    f = parse.count - 2;
                    if (f > -1) {
                        do {
                            if (data.types[f] === "end") {
                                g = g + 1;
                            }
                            else if (data.types[f] === "start" || data.types[f] === "end") {
                                g = g - 1;
                            }
                            if (g === 0) {
                                break;
                            }
                            f = f - 1;
                        } while (f > -1);
                    }
                    if (data.token[f] === "{" && data.token[f - 1] === ")") {
                        g = 1;
                        f = f - 2;
                        if (f > -1) {
                            do {
                                if (data.types[f] === "end") {
                                    g = g + 1;
                                }
                                else if (data.types[f] === "start" || data.types[f] === "end") {
                                    g = g - 1;
                                }
                                if (g === 0) {
                                    break;
                                }
                                f = f - 1;
                            } while (f > -1);
                        }
                        if (data.token[f - 1] !== "function" && data.token[f - 2] !== "function") {
                            data.types[parse.count] = "start";
                        }
                    }
                }
                else {
                    data.types[parse.count] = "start";
                }
            }
            if (options.correct === true && (output === "Object" || output === "Array") && c[a + 1] === "(" && c[a + 2] === ")" && data.token[parse.count - 1] === "=" && data.token[parse.count] === "new") {
                if (output === "Object") {
                    data.token[parse.count] = "{";
                    ltoke = "}";
                    data.stack[parse.count] = "object";
                    parse.structure[parse.structure.length - 1][0] = "object";
                }
                else {
                    data.token[parse.count] = "[";
                    ltoke = "]";
                    data.stack[parse.count] = "array";
                    parse.structure[parse.structure.length - 1][0] = "array";
                }
                data.types[parse.count] = "start";
                ltype = "end";
                c[a + 1] = "";
                c[a + 2] = "";
                a = a + 2;
            }
            else {
                g = parse.count;
                f = g;
                if (options.lexer_options.script.variable_list !== "none" && (output === "var" || output === "let" || output === "const")) {
                    if (data.types[g] === "comment") {
                        do {
                            g = g - 1;
                        } while (g > 0 && (data.types[g] === "comment"));
                    }
                    if (options.lexer_options.script.variable_list === "list" && vart.len > -1 && vart.index[vart.len] === g && output === vart.word[vart.len]) {
                        ltoke = ",";
                        ltype = "separator";
                        data.token[g] = ltoke;
                        data.types[g] = ltype;
                        vart.count[vart.len] = 0;
                        vart.index[vart.len] = g;
                        vart.word[vart.len] = output;
                        return;
                    }
                    vart.len = vart.len + 1;
                    vart
                        .count
                        .push(0);
                    vart
                        .index
                        .push(g);
                    vart
                        .word
                        .push(output);
                    g = f;
                }
                else if (vart.len > -1 && output !== vart.word[vart.len] && parse.count === vart.index[vart.len] && data.token[vart.index[vart.len]] === ";" && ltoke !== vart.word[vart.len] && options.lexer_options.script.variable_list === "list") {
                    vartpop();
                }
                if (output === "from" && data.token[parse.count] === "x;" && data.token[parse.count - 1] === "}") {
                    asifix();
                }
                if (output === "while" && data.token[parse.count] === "x;" && data.token[parse.count - 1] === "}") {
                    let d = 0, e = parse.count - 2;
                    if (e > -1) {
                        do {
                            if (data.types[e] === "end") {
                                d = d + 1;
                            }
                            else if (data.types[e] === "start") {
                                d = d - 1;
                            }
                            if (d < 0) {
                                if (data.token[e] === "{" && data.token[e - 1] === "do") {
                                    asifix();
                                }
                                return;
                            }
                            e = e - 1;
                        } while (e > -1);
                    }
                }
                if (typel === "comment") {
                    let d = parse.count;
                    do {
                        d = d - 1;
                    } while (d > 0 && data.types[d] === "comment");
                    typel = data.types[d];
                    tokel = data.token[d];
                }
                nextitem = nextchar(2, false);
                if (output === "void") {
                    if (tokel === ":" && data.stack[parse.count - 1] === "arguments") {
                        ltype = "type";
                    }
                    else {
                        ltype = "word";
                    }
                }
                else if ((options.language === "java" || options.language === "csharp") && output === "static") {
                    ltype = "word";
                }
                else if ((parse.structure[parse.structure.length - 1][0] === "object" ||
                    parse.structure[parse.structure.length - 1][0] === "class" ||
                    parse.structure[parse.structure.length - 1][0] === "data_type") && (data.token[parse.count] === "{" ||
                    (data.token[data.begin[parse.count]] === "{" && data.token[parse.count] === ",") ||
                    (data.types[parse.count] === "template_end" && (data.token[data.begin[parse.count] - 1] === "{" || data.token[data.begin[parse.count] - 1] === ",")))) {
                    if (output === "return" || output === "break") {
                        ltype = "word";
                    }
                    else {
                        ltype = "property";
                    }
                }
                else if (datatype[datatype.length - 1] === true || ((options.language === "typescript" || options.language === "flow") && tokel === "type")) {
                    ltype = "type";
                }
                else if ((options.language === "java" || options.language === "csharp") && (tokel === "public" || tokel === "private" || tokel === "static" || tokel === "final")) {
                    ltype = "reference";
                }
                else if ((options.language === "java" || options.language === "csharp") && ltoke !== "var" && (ltype === "end" || ltype === "word") && nextitem.charAt(0) === "=" && nextitem.charAt(1) !== "=") {
                    ltype = "reference";
                }
                else if (references.length > 0 && (tokel === "function" || tokel === "class" || tokel === "const" || tokel === "let" || tokel === "var" || tokel === "new" || tokel === "void")) {
                    ltype = "reference";
                    references[references.length - 1].push(output);
                    if (options.language === "javascript" || options.language === "jsx" || options.language === "typescript" || options.language === "flow") {
                        if (tokel === "var" || (tokel === "function" && data.types[parse.count - 1] !== "operator" && data.types[parse.count - 1] !== "start" && data.types[parse.count - 1] !== "end")) {
                            hoisting(parse.count, output, true);
                        }
                        else {
                            hoisting(parse.count, output, false);
                        }
                    }
                    else {
                        hoisting(parse.count, output, false);
                    }
                }
                else if (parse.structure[parse.structure.length - 1][0] === "arguments" && ltype !== "operator") {
                    ltype = "reference";
                    funreferences.push(output);
                }
                else if (tokel === "," && data.stack[parse.count] !== "method" && (data.stack[parse.count] !== "expression" || data.token[data.begin[parse.count] - 1] === "for")) {
                    let d = parse.count;
                    const e = parse.structure[parse.structure.length - 1][1];
                    do {
                        if (data.begin[d] === e) {
                            if (data.token[d] === ";") {
                                break;
                            }
                            if (data.token[d] === "var" || data.token[d] === "let" || data.token[d] === "const" || data.token[d] === "type") {
                                break;
                            }
                        }
                        else if (data.types[d] === "end") {
                            d = data.begin[d];
                        }
                        d = d - 1;
                    } while (d > e);
                    if (references.length > 0 && data.token[d] === "var") {
                        ltype = "reference";
                        references[references.length - 1].push(output);
                        if (options.language === "javascript" || options.language === "jsx" || options.language === "typescript" || options.language === "flow") {
                            hoisting(d, output, true);
                        }
                        else {
                            hoisting(d, output, false);
                        }
                    }
                    else if (references.length > 0 && (data.token[d] === "let" || data.token[d] === "const" || (data.token[d] === "type" && (options.language === "typescript" || options.language === "flow")))) {
                        ltype = "reference";
                        references[references.length - 1].push(output);
                        hoisting(d, output, false);
                    }
                    else {
                        ltype = "word";
                    }
                }
                else if (parse.structure[parse.structure.length - 1][0] !== "object" || (parse.structure[parse.structure.length - 1][0] === "object" && ltoke !== "," && ltoke !== "{")) {
                    let d = references.length, e = 0;
                    if (d > 0) {
                        do {
                            d = d - 1;
                            e = references[d].length;
                            if (e > 0) {
                                do {
                                    e = e - 1;
                                    if (output === references[d][e]) {
                                        break;
                                    }
                                } while (e > 0);
                                if (output === references[d][e]) {
                                    break;
                                }
                            }
                        } while (d > 0);
                        if (references[d][e] === output && tokel !== ".") {
                            ltype = "reference";
                        }
                        else {
                            ltype = "word";
                        }
                    }
                    else {
                        ltype = "word";
                    }
                }
                else {
                    ltype = "word";
                }
                ltoke = output;
                if (output === "from" && data.token[parse.count] === "}") {
                    asifix();
                }
            }
            recordPush("");
            if (output === "class") {
                classy.push(0);
            }
            if (output === "do") {
                nextitem = nextchar(1, true);
                if (nextitem !== "{") {
                    ltoke = (options.correct === true)
                        ? "{"
                        : "x{";
                    ltype = "start";
                    brace.push("x{");
                    recordPush("do");
                }
            }
            if (output === "else") {
                nextitem = nextchar(2, true);
                let x = parse.count - 1;
                if (data.types[x] === "comment") {
                    do {
                        x = x - 1;
                    } while (x > 0 && data.types[x] === "comment");
                }
                if (data.token[x] === "x}") {
                    if (data.token[parse.count] === "else") {
                        if (data.stack[parse.count - 1] !== "if" && data.types[parse.count - 1] !== "comment" && data.stack[parse.count - 1] !== "else") {
                            brace.pop();
                            parse.splice({
                                data: data,
                                howmany: 0,
                                index: parse.count - 1,
                                record: {
                                    begin: data.begin[data.begin[data.begin[parse.count - 1] - 1] - 1],
                                    ender: -1,
                                    lexer: "script",
                                    lines: 0,
                                    stack: "if",
                                    token: (options.correct === true)
                                        ? "}"
                                        : "x}",
                                    types: "end"
                                }
                            });
                            if (parse.structure.length > 1) {
                                parse.structure.splice(parse.structure.length - 2, 1);
                                parse.structure[parse.structure.length - 1][1] = parse.count;
                            }
                        }
                        else if (data.token[parse.count - 2] === "x}" && pstack[0] !== "if" && data.stack[parse.count] === "else") {
                            elsefix();
                        }
                        else if (data.token[parse.count - 2] === "}" && data.stack[parse.count - 2] === "if" && pstack[0] === "if" && data.token[pstack[1] - 1] !== "if" && data.token[data.begin[parse.count - 1]] === "x{") {
                            // fixes when "else" is following a block that isn't "if"
                            elsefix();
                        }
                    }
                    else if (data.token[parse.count] === "x}" && data.stack[parse.count] === "if") {
                        elsefix();
                    }
                }
                if (nextitem !== "if" && nextitem.charAt(0) !== "{") {
                    ltoke = (options.correct === true)
                        ? "{"
                        : "x{";
                    ltype = "start";
                    brace.push("x{");
                    recordPush("else");
                }
            }
            if ((output === "for" || output === "if" || output === "switch" || output === "catch") && options.language !== "twig" && data.token[parse.count - 1] !== ".") {
                nextitem = nextchar(1, true);
                if (nextitem !== "(") {
                    paren = parse.count;
                    if (options.correct === true) {
                        start("(");
                    }
                    else {
                        start("x(");
                    }
                }
            }
        };
        do {
            if ((/\s/).test(c[a]) === true) {
                if (wordTest > -1) {
                    word();
                }
                a = parse.spacer({ array: c, end: b, index: a });
                if (parse.linesSpace > 1 && ltoke !== ";" && lengthb < parse.count && c[a + 1] !== "}") {
                    asi(false);
                    lengthb = parse.count;
                }
            }
            else if (c[a] === "<" && c[a + 1] === "?" && c[a + 2] === "p" && c[a + 3] === "h" && c[a + 4] === "p") {
                // php
                general("<?php", "?>", "template");
            }
            else if (c[a] === "<" && c[a + 1] === "?" && c[a + 2] === "=") {
                // php
                general("<?=", "?>", "template");
            }
            else if (c[a] === "<" && c[a + 1] === "%") {
                // asp
                general("<%", "%>", "template");
            }
            else if (c[a] === "{" && c[a + 1] === "%") {
                // twig
                general("{%", "%}", "template");
            }
            else if (c[a] === "{" && c[a + 1] === "{" && c[a + 2] === "{") {
                // mustache
                general("{{{", "}}}", "template");
            }
            else if (c[a] === "{" && c[a + 1] === "{") {
                // handlebars
                general("{{", "}}", "template");
            }
            else if (c[a] === "<" && c[a + 1] === "!" && c[a + 2] === "-" && c[a + 3] === "-" && c[a + 4] === "#") {
                // ssi
                general("<!--#", "-->", "template");
            }
            else if (c[a] === "<" && c[a + 1] === "!" && c[a + 2] === "-" && c[a + 3] === "-") {
                // markup comment
                general("<!--", "-->", "comment");
            }
            else if (c[a] === "<") {
                // markup
                markup();
            }
            else if (c[a] === "/" && (a === b - 1 || c[a + 1] === "*")) {
                // comment block
                blockComment();
            }
            else if ((parse.count < 0 || data.lines[parse.count] > 0) && c[a] === "#" && c[a + 1] === "!" && (c[a + 2] === "/" || c[a + 2] === "[")) {
                // shebang
                general("#!" + c[a + 2], "\n", "string");
            }
            else if (c[a] === "/" && (a === b - 1 || c[a + 1] === "/")) {
                // comment line
                lineComment();
            }
            else if (c[a] === "#" && c[a + 1] === "r" && c[a + 2] === "e" && c[a + 3] === "g" && c[a + 4] === "i" && c[a + 5] === "o" && c[a + 6] === "n" && (/\s/).test(c[a + 7]) === true) {
                // comment line
                asi(false);
                general("#region", "\n", "comment");
            }
            else if (c[a] === "#" && c[a + 1] === "e" && c[a + 2] === "n" && c[a + 3] === "d" && c[a + 4] === "r" && c[a + 5] === "e" && c[a + 6] === "g" && c[a + 7] === "i" && c[a + 8] === "o" && c[a + 9] === "n") {
                // comment line
                asi(false);
                general("#endregion", "\n", "comment");
            }
            else if (c[a] === "`" || (c[a] === "}" && parse.structure[parse.structure.length - 1][0] === "template_string")) {
                // template string
                if (wordTest > -1) {
                    word();
                }
                ltoke = tempstring();
                if (ltoke.charAt(0) === "}" && ltoke.slice(ltoke.length - 2) === "${") {
                    ltype = "template_string_else";
                    recordPush("template_string");
                }
                else if (ltoke.slice(ltoke.length - 2) === "${") {
                    ltype = "template_string_start";
                    recordPush("template_string");
                }
                else if (ltoke.charAt(0) === "}") {
                    ltype = "template_string_end";
                    recordPush("");
                }
                else {
                    ltype = "string";
                    recordPush("");
                }
            }
            else if (c[a] === "\"" || c[a] === "'") {
                // string
                general(c[a], c[a], "string");
            }
            else if (c[a] === "-" &&
                (a < b - 1 && c[a + 1] !== "=" && c[a + 1] !== "-") &&
                (ltype === "number" || ltype === "word" || ltype === "reference") &&
                ltoke !== "return" &&
                (ltoke === ")" || ltoke === "]" || ltype === "word" || ltype === "reference" || ltype === "number")) {
                // subtraction
                if (wordTest > -1) {
                    word();
                }
                ltoke = "-";
                ltype = "operator";
                recordPush("");
            }
            else if (wordTest === -1 && (c[a] !== "0" || (c[a] === "0" && c[a + 1] !== "b")) && ((/\d/).test(c[a]) || (a !== b - 2 && c[a] === "-" && c[a + 1] === "." && (/\d/).test(c[a + 2])) || (a !== b - 1 && (c[a] === "-" || c[a] === ".") && (/\d/).test(c[a + 1])))) {
                // number
                if (wordTest > -1) {
                    word();
                }
                if (ltype === "end" && c[a] === "-") {
                    ltoke = "-";
                    ltype = "operator";
                }
                else {
                    ltoke = numb();
                    ltype = "number";
                }
                recordPush("");
            }
            else if (c[a] === ":" && c[a + 1] === ":") {
                if (wordTest > -1) {
                    word();
                }
                if (options.correct === true) {
                    plusplus();
                }
                asifix();
                a = a + 1;
                ltoke = "::";
                ltype = "separator";
                recordPush("");
            }
            else if (c[a] === ",") {
                // comma
                if (wordTest > -1) {
                    word();
                }
                if (options.correct === true) {
                    plusplus();
                }
                if (datatype[datatype.length - 1] === true && data.stack[parse.count].indexOf("type") < 0) {
                    datatype[datatype.length - 1] = false;
                }
                if (ltype === "comment") {
                    commaComment();
                }
                else if (vart.len > -1 && vart.count[vart.len] === 0 && options.lexer_options.script.variable_list === "each") {
                    asifix();
                    ltoke = ";";
                    ltype = "separator";
                    recordPush("");
                    ltoke = vart.word[vart.len];
                    ltype = "word";
                    recordPush("");
                    vart.index[vart.len] = parse.count;
                }
                else {
                    ltoke = ",";
                    ltype = "separator";
                    asifix();
                    recordPush("");
                }
            }
            else if (c[a] === ".") {
                // period
                if (wordTest > -1) {
                    word();
                }
                datatype[datatype.length - 1] = false;
                if (c[a + 1] === "." && c[a + 2] === ".") {
                    ltoke = "...";
                    ltype = "operator";
                    a = a + 2;
                }
                else {
                    asifix();
                    ltoke = ".";
                    ltype = "separator";
                }
                if ((/\s/).test(c[a - 1]) === true) {
                    parse.linesSpace = 1;
                }
                recordPush("");
            }
            else if (c[a] === ";") {
                // semicolon
                if (wordTest > -1) {
                    word();
                }
                if (datatype[datatype.length - 1] === true && data.stack[parse.count].indexOf("type") < 0) {
                    datatype[datatype.length - 1] = false;
                }
                if (options.language === "qml") {
                    ltoke = (options.correct === true)
                        ? ";"
                        : "x;";
                    ltype = "separator";
                    recordPush("");
                }
                else {
                    if (classy[classy.length - 1] === 0) {
                        classy.pop();
                    }
                    if (vart.len > -1 && vart.count[vart.len] === 0) {
                        if (options.lexer_options.script.variable_list === "each") {
                            vartpop();
                        }
                        else {
                            vart.index[vart.len] = parse.count + 1;
                        }
                    }
                    if (options.correct === true) {
                        plusplus();
                    }
                    ltoke = ";";
                    ltype = "separator";
                    if (data.token[parse.count] === "x}") {
                        asibrace();
                    }
                    else {
                        recordPush("");
                    }
                }
                blockinsert();
            }
            else if (c[a] === "(" || c[a] === "[" || c[a] === "{") {
                start(c[a]);
            }
            else if (c[a] === ")" || c[a] === "]" || c[a] === "}") {
                end(c[a]);
            }
            else if (c[a] === "*" && data.stack[parse.count] === "object" && wordTest < 0 && (/\s/).test(c[a + 1]) === false && c[a + 1] !== "=" && (/\d/).test(c[a + 1]) === false) {
                wordTest = a;
            }
            else if (c[a] === "=" || c[a] === "&" || c[a] === "<" || c[a] === ">" || c[a] === "+" || c[a] === "-" || c[a] === "*" || c[a] === "/" || c[a] === "!" || c[a] === "?" || c[a] === "|" || c[a] === "^" || c[a] === ":" || c[a] === "%" || c[a] === "~") {
                // operator
                ltoke = operator();
                if (ltoke === "regex") {
                    ltoke = data.token[parse.count];
                }
                else if (ltoke === "*" && data.token[parse.count] === "function") {
                    data.token[parse.count] = "function*";
                }
                else {
                    ltype = "operator";
                    if (ltoke !== "!" && ltoke !== "++" && ltoke !== "--") {
                        asifix();
                    }
                    recordPush("");
                }
            }
            else if (wordTest < 0 && c[a] !== "") {
                wordTest = a;
            }
            if (vart.len > -1 && parse.count === vart.index[vart.len] + 1 && data.token[vart.index[vart.len]] === ";" && ltoke !== vart.word[vart.len] && ltype !== "comment" && options.lexer_options.script.variable_list === "list") {
                vartpop();
            }
            a = a + 1;
        } while (a < b);
        if (wordTest > -1) {
            word();
        }
        if (((data.token[parse.count] !== "}" && data.token[0] === "{") || data.token[0] !== "{") && ((data.token[parse.count] !== "]" && data.token[0] === "[") || data.token[0] !== "[")) {
            asi(false);
        }
        if (sourcemap[0] === parse.count) {
            ltoke = "\n" + sourcemap[1];
            ltype = "string";
            recordPush("");
        }
        if (data.token[parse.count] === "x;" && (data.token[parse.count - 1] === "}" || data.token[parse.count - 1] === "]") && data.begin[parse.count - 1] === 0) {
            parse.pop(data);
        }
        return data;
    };
    sparser.lexers.script = script;
}());
(function markup_init() {
    
    const markup = function lexer_markup(source) {
        let a = 0, sgmlflag = 0, html = "", cftransaction = false, ext = false;
        const parse = sparser.parse, data = parse.data, count = {
            end: 0,
            index: -1,
            start: 0
        }, options = sparser.options, b = source.split(""), c = b.length, htmlblocks = {
            body: "block",
            colgroup: "block",
            dd: "block",
            dt: "block",
            head: "block",
            html: "block",
            li: "block",
            option: "block",
            p: "block",
            tbody: "block",
            td: "block",
            tfoot: "block",
            th: "block",
            thead: "block",
            tr: "block",
        }, attribute_sort_list = (typeof options.lexer_options.markup.attribute_sort_list === "string" && options.lexer_options.markup.attribute_sort_list !== "")
            ? options.lexer_options.markup.attribute_sort_list.split(",")
            : [], asl = attribute_sort_list.length, 
        //pads certain template tag delimiters with a space
        bracketSpace = function lexer_markup_bracketSpace(input) {
            if (options.language !== "html" && options.language !== "xml" && options.language !== "sgml" && options.language !== "jsx") {
                const spaceStart = function lexer_markup_tag_spaceStart(start) {
                    return start.replace(/\s*$/, " ");
                }, spaceEnd = function lexer_markup_tag_spaceStart(end) {
                    return end.replace(/^\s*/, " ");
                };
                if ((/\{(=|#|\/|(%>)|(%\]))/).test(input) === true || (/\}%(>|\])/).test(input) === true) {
                    return input;
                }
                input = input.replace(/\{((\{+)|%-?)\s*/g, spaceStart);
                input = input.replace(/\s*((\}\}+)|(-?%\}))/g, spaceEnd);
                return input;
            }
            return input;
        }, 
        // pushes a record into the parse table
        recordPush = function lexer_markup_recordPush(target, record, structure) {
            if (target === data) {
                if (record.types.indexOf("end") > -1) {
                    count.end = count.end + 1;
                }
                else if (record.types.indexOf("start") > -1) {
                    count.start = count.start + 1;
                }
            }
            if (options.lexer_options.markup.parse_space === true) {
                record.lines = 0;
            }
            parse.push(target, record, structure);
        }, 
        // Find the lowercase tag name of the provided token.
        tagName = function lexer_markup_tagName(el) {
            let space = 0, name = "";
            const reg = (/^((\{|<)((%-?)|\{-?)=?\s*)/);
            if (typeof el !== "string") {
                return "";
            }
            space = el
                .replace(reg, "%")
                .replace(/\s+/, " ")
                .indexOf(" ");
            name = el.replace(reg, " ");
            name = (space < 0)
                ? name.slice(1, el.length - 1)
                : name.slice(1, space);
            if (html === "html" || options.language === "coldfusion") {
                name = name.toLowerCase();
            }
            name = name.replace(/(\}\})$/, "");
            if (name.indexOf("(") > 0) {
                name = name.slice(0, name.indexOf("("));
            }
            if (name === "?xml?") {
                return "xml";
            }
            return name;
        }, 
        // A fix for HTML missing end tags
        fixHtmlEnd = function lexer_markup_fixHtmlEnd(element, end) {
            const tname = tagName(element), record = {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markup",
                lines: (data.lines[parse.count] > 0) ? 1 : 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: `</${parse.structure[parse.structure.length - 1][0]}>`,
                types: "end"
            };
            recordPush(data, record, "");
            if (htmlblocks[parse.structure[parse.structure.length - 1][0]] === "block" && ((end === true && parse.structure.length > 1) || (end === false && `/${parse.structure[parse.structure.length - 1][0]}` !== tname))) {
                do {
                    record.begin = parse.structure[parse.structure.length - 1][1];
                    record.stack = parse.structure[parse.structure.length - 1][0];
                    record.token = `</${parse.structure[parse.structure.length - 1][0]}>`;
                    recordPush(data, record, "");
                } while (htmlblocks[parse.structure[parse.structure.length - 1][0]] === "block" && ((end === true && parse.structure.length > 1) || (end === false && `/${parse.structure[parse.structure.length - 1][0]}` !== tname)));
            }
        }, 
        // A fix for Vapor Leaf end structure parsing
        vaporEnd = function lexer_markup_vaporEnd() {
            const liner = parse.linesSpace, rec = {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markup",
                lines: liner,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "}",
                types: "template_end"
            };
            let aa = a + 1;
            if ((/\s/).test(b[aa]) === true) {
                aa = parse.spacer({ array: b, end: c, index: aa }) + 1;
            }
            if (b[aa] === "e" && b[aa + 1] === "l" && b[aa + 2] === "s" && b[aa + 3] === "e") {
                if (b[aa + 4] === "{") {
                    rec.token = "} else {";
                    rec.types = "template_else";
                    recordPush(data, rec, "else");
                    a = aa;
                    return;
                }
                if ((/\s/).test(b[aa + 4]) === true) {
                    aa = parse.spacer({ array: b, end: c, index: aa + 4 }) + 1;
                    if (b[aa] === "{") {
                        rec.token = "} else {";
                        rec.types = "template_else";
                        recordPush(data, rec, "else");
                        a = aa;
                        return;
                    }
                    if (b[aa] === "i" && b[aa + 1] === "f") {
                        aa = aa + 2;
                        if ((/\s/).test(b[aa]) === true) {
                            aa = parse.spacer({ array: b, end: c, index: aa }) + 1;
                        }
                        if (b[aa] === "(") {
                            let paren = 0;
                            do {
                                if (b[aa] === "(") {
                                    paren = paren + 1;
                                }
                                else if (b[aa] === ")") {
                                    paren = paren - 1;
                                    if (paren < 1) {
                                        aa = aa + 1;
                                        break;
                                    }
                                }
                                aa = aa + 1;
                            } while (aa < c);
                            if ((/\s/).test(b[aa]) === true) {
                                aa = parse.spacer({ array: b, end: c, index: aa }) + 1;
                            }
                            if (b[aa] === "{") {
                                rec.token = b.slice(a, aa + 1).join("");
                                rec.types = "template_else";
                                recordPush(data, rec, "else");
                                a = aa;
                                return;
                            }
                        }
                    }
                }
            }
            recordPush(data, rec, "");
            parse.linesSpace = liner;
        }, 
        // A fix for Vapor Leaf start structure parsing
        vaporStart = function lexer_markup_vaporStart() {
            const rec = parse.pop(data);
            rec.token = `${rec.token} {`;
            rec.types = "template_start";
            recordPush(data, rec, rec.token.slice(0, rec.token.indexOf("(")));
        }, 
        //parses tags, attributes, and template elements
        tag = function lexer_markup_tag(end) {
            // markup is two smaller lexers that work together: tag - evaluates markup and
            // template tags content - evaluates text content and code for external lexers
            //
            //type definitions:
            // * start      end     type
            // * <![CDATA[   ]]>    cdata
            // * <!--       -->     comment
            // * <#--       -->     comment
            // * <%--       --%>    comment
            // * {!         !}      comment
            // * <!--[if    -->     conditional
            // * text       text    content
            // * </         >       end
            // * <pre       </pre>  ignore (html only)
            // * text       text    script
            // * <!         >       sgml
            // * <          />      singleton
            // * <          >       start
            // * text       text    style
            // * <!--#      -->     template
            // * <%         %>      template
            // * {{{        }}}     template
            // * {{         }}      template
            // * {%         %}      template
            // * [%         %]      template
            // * {@         @}      template
            // * {#         #}      template
            // * {#         /}      template
            // * {?         /}      template
            // * {^         /}      template
            // * {@         /}      template
            // * {<         /}      template
            // * {+         /}      template
            // * {~         }       template
            // * <?         ?>      template
            // * {:else}            template_else
            // * <#else     >       template_else
            // * {@}else{@}         template_else
            // * <%}else{%>         template_else
            // * {{         }}      template_end
            // * <%\s*}     %>      template_end
            // * [%\s*}     %]      template_end
            // * {@\s*}     @}      template_end
            // * {          }       template_end
            // * {{#        }}      template_start
            // * <%         {\s*%>  template_start
            // * [%         {\s*%]  template_start
            // * {@         {\s*@}  template_start
            // * {#         }       template_start
            // * {?         }       template_start
            // * {^         }       template_start
            // * {@         }       template_start
            // * {<         }       template_start
            // * {+         }       template_start
            // * <?xml      ?>      xml
            let igcount = 0, element = "", lastchar = "", ltype = "", tname = "", start = "", cheat = false, earlyexit = false, ignoreme = false, jscom = false, nosort = false, preserve = false, simple = false, singleton = false, attstore = [], comm = ["", 0];
            const record = {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markup",
                lines: parse.linesSpace,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "",
                types: ""
            }, 
            //cftags is a list of supported coldfusion tags
            // * required - means must have a separate matching end tag
            // * optional - means the tag could have a separate end tag, but is probably a
            // singleton
            // * prohibited - means there is no corresponding end tag
            cftags = {
                "cfNTauthenticate": "optional",
                "cfabort": "prohibited",
                "cfajaximport": "optional",
                "cfajaxproxy": "optional",
                "cfapplet": "prohibited",
                "cfapplication": "prohibited",
                "cfargument": "prohibited",
                "cfassociate": "prohibited",
                "cfauthenticate": "prohibited",
                "cfbreak": "prohibited",
                "cfcache": "optional",
                "cfcalendar": "optional",
                "cfcase": "required",
                "cfcatch": "required",
                "cfchart": "optional",
                "cfchartdata": "prohibited",
                "cfchartseries": "optional",
                "cfclient": "required",
                "cfclientsettings": "optional",
                "cfcol": "prohibited",
                "cfcollection": "prohibited",
                "cfcomponent": "required",
                "cfcontent": "optional",
                "cfcontinue": "prohibited",
                "cfcookie": "prohibited",
                "cfdbinfo": "prohibited",
                "cfdefaultcase": "required",
                "cfdirectory": "prohibited",
                "cfdiv": "optional",
                "cfdocument": "optional",
                "cfdocumentitem": "optional",
                "cfdocumentsection": "optional",
                "cfdump": "optional",
                "cfelse": "prohibited",
                "cfelseif": "prohibited",
                "cferror": "prohibited",
                "cfexchangecalendar": "optional",
                "cfexchangeconnection": "optional",
                "cfexchangecontact": "optional",
                "cfexchangeconversation": "optional",
                "cfexchangefilter": "optional",
                "cfexchangefolder": "optional",
                "cfexchangemail": "optional",
                "cfexchangetask": "optional",
                "cfexecute": "required",
                "cfexit": "prohibited",
                "cffeed": "prohibited",
                "cffile": "optional",
                "cffileupload": "optional",
                "cffinally": "required",
                "cfflush": "prohibited",
                "cfform": "required",
                "cfformgroup": "required",
                "cfformitem": "optional",
                "cfforward": "prohibited",
                "cfftp": "prohibited",
                "cffunction": "required",
                "cfgraph": "required",
                "cfgraphdata": "prohibited",
                "cfgrid": "required",
                "cfgridcolumn": "optional",
                "cfgridrow": "optional",
                "cfgridupdate": "optional",
                "cfheader": "prohibited",
                "cfhtmlbody": "optional",
                "cfhtmlhead": "optional",
                "cfhtmltopdf": "optional",
                "cfhtmltopdfitem": "optional",
                "cfhttp": "optional",
                "cfhttpparam": "prohibited",
                "cfif": "required",
                "cfimage": "prohibited",
                "cfimap": "prohibited",
                "cfimapfilter": "optional",
                "cfimport": "prohibited",
                "cfinclude": "prohibited",
                "cfindex": "prohibited",
                "cfinput": "prohibited",
                "cfinsert": "prohibited",
                "cfinterface": "required",
                "cfinvoke": "optional",
                "cfinvokeargument": "prohibited",
                "cflayout": "optional",
                "cflayoutarea": "optional",
                "cfldap": "prohibited",
                "cflocation": "prohibited",
                "cflock": "required",
                "cflog": "prohibited",
                "cflogic": "required",
                "cfloginuser": "prohibited",
                "cflogout": "prohibited",
                "cfloop": "required",
                "cfmail": "required",
                "cfmailparam": "prohibited",
                "cfmailpart": "required",
                "cfmap": "optional",
                "cfmapitem": "optional",
                "cfmediaplayer": "optional",
                "cfmenu": "required",
                "cfmenuitem": "optional",
                "cfmessagebox": "optional",
                "cfmodule": "optional",
                "cfoauth": "optional",
                "cfobject": "prohibited",
                "cfobjectcache": "prohibited",
                "cfoutput": "required",
                "cfpageencoding": "optional",
                "cfparam": "prohibited",
                "cfpdf": "optional",
                "cfpdfform": "optional",
                "cfpdfformparam": "optional",
                "cfpdfparam": "prohibited",
                "cfpdfsubform": "required",
                "cfpod": "optional",
                "cfpop": "prohibited",
                "cfpresentation": "required",
                "cfpresentationslide": "optional",
                "cfpresenter": "optional",
                "cfprint": "optional",
                "cfprocessingdirective": "optional",
                "cfprocparam": "prohibited",
                "cfprocresult": "prohibited",
                "cfprogressbar": "optional",
                "cfproperty": "prohibited",
                "cfquery": "required",
                "cfqueryparam": "prohibited",
                "cfregistry": "prohibited",
                "cfreport": "optional",
                "cfreportparam": "optional",
                "cfrethrow": "prohibited",
                "cfretry": "prohibited",
                "cfreturn": "prohibited",
                "cfsavecontent": "required",
                "cfschedule": "prohibited",
                "cfscript": "required",
                "cfsearch": "prohibited",
                "cfselect": "required",
                "cfservlet": "prohibited",
                "cfservletparam": "prohibited",
                "cfset": "prohibited",
                "cfsetting": "optional",
                "cfsharepoint": "optional",
                "cfsilent": "required",
                "cfsleep": "prohibited",
                "cfslider": "prohibited",
                "cfspreadsheet": "optional",
                "cfsprydataset": "optional",
                "cfstatic": "required",
                "cfstopwatch": "required",
                "cfstoredproc": "optional",
                "cfswitch": "required",
                "cftable": "required",
                "cftextarea": "optional",
                "cfthread": "optional",
                "cfthrow": "prohibited",
                "cftimer": "required",
                "cftooltip": "required",
                "cftrace": "optional",
                "cftransaction": "required",
                "cftree": "required",
                "cftreeitem": "optional",
                "cftry": "required",
                "cfupdate": "prohibited",
                "cfvideo": "prohibited",
                "cfvideoplayer": "optional",
                "cfwddx": "prohibited",
                "cfwebsocket": "optional",
                "cfwhile": "required",
                "cfwindow": "optional",
                "cfx_": "prohibited",
                "cfxml": "required",
                "cfzip": "optional",
                "cfzipparam": "prohibited"
            }, 
            //attribute name
            arname = function lexer_markup_tag_name(x) {
                const eq = x.indexOf("=");
                if (eq > 0 && ((eq < x.indexOf("\"") && x.indexOf("\"") > 0) || (eq < x.indexOf("'") && x.indexOf("'") > 0))) {
                    return [x.slice(0, eq), x.slice(eq + 1)];
                }
                return [x, ""];
            }, 
            // attribute parser
            attributeRecord = function lexer_markup_tag_attributeRecord() {
                let ind = 0, eq = 0, dq = 0, sq = 0, slice = "", name = "", cft = cftags[tname
                    .toLowerCase()
                    .replace(/\/$/, "")], store = [], len = attstore.length;
                const qc = (options.lexer_options.markup.quote_convert === undefined)
                    ? "none"
                    : options.lexer_options.markup.quote_convert, begin = parse.count, stack = tname.replace(/\/$/, ""), syntax = "<{\"'=/", convertQ = function lexer_markup_tag_attributeRecord_convertQ() {
                    if (ignoreme === true || qc === "none" || record.types !== "attribute" || (qc === "single" && record.token.indexOf("\"") < 0) || (qc === "double" && record.token.indexOf("'") < 0)) {
                        recordPush(data, record, "");
                    }
                    else {
                        let ee = 0, inner = false;
                        const chars = record.token.split(""), eq = record.token.indexOf("="), len = chars.length - 1;
                        if (chars[eq + 1] !== "\"" && qc === "single" && chars[chars.length - 1] !== "\"") {
                            recordPush(data, record, "");
                        }
                        else if (chars[eq + 1] !== "'" && qc === "double" && chars[chars.length - 1] !== "'") {
                            recordPush(data, record, "");
                        }
                        else {
                            ee = eq + 2;
                            if (qc === "double") {
                                if (record.token.slice(eq + 2, len).indexOf("\"") > -1) {
                                    inner = true;
                                }
                                chars[eq + 1] = "\"";
                                chars[chars.length - 1] = "\"";
                            }
                            else {
                                if (record.token.slice(eq + 2, len).indexOf("'") > -1) {
                                    inner = true;
                                }
                                chars[eq + 1] = "'";
                                chars[chars.length - 1] = "'";
                            }
                            if (inner === true) {
                                do {
                                    if (chars[ee] === "'" && qc === "single") {
                                        chars[ee] = "\"";
                                    }
                                    else if (chars[ee] === "\"" && qc === "double") {
                                        chars[ee] = "'";
                                    }
                                    ee = ee + 1;
                                } while (ee < len);
                            }
                            record.token = chars.join("");
                            recordPush(data, record, "");
                        }
                    }
                }, templateAtt = function lexer_markup_tag_attributeRecord_templateAtt(sample, token) {
                    if (sample.charAt(0) === "{" && "{%#@:/?^<+~=".indexOf(sample.charAt(1)) > -1) {
                        record.types = "template_attribute";
                    }
                    else if (sample.charAt(0) === "<") {
                        record.types = "template_attribute";
                    }
                    else if (sample === "[%") {
                        record.types = "template_attribute";
                    }
                    else {
                        record.token = token;
                        convertQ();
                        return;
                    }
                    record.token = token;
                    convertQ();
                    record.types = "attribute";
                };
                if (attstore.length < 1) {
                    return;
                }
                // fix for singleton tags, since "/" at the end of the tag is not an attribute
                if (attstore[attstore.length - 1][0] === "/") {
                    attstore.pop();
                    element = element.replace(/>$/, "/>");
                }
                // reconnects attribute names to their respective values if separated on "="
                eq = attstore.length;
                dq = 1;
                if (dq < eq) {
                    do {
                        name = attstore[dq - 1][0];
                        if (name.charAt(name.length - 1) === "=" && attstore[dq][0].indexOf("=") < 0) {
                            attstore[dq - 1][0] = name + attstore[dq][0];
                            attstore.splice(dq, 1);
                            eq = eq - 1;
                            dq = dq - 1;
                        }
                        dq = dq + 1;
                    } while (dq < eq);
                }
                // sort the attributes
                if ((options.lexer_options.markup.attribute_sort === true || options.lexer_options.markup.tag_sort === true) && jscom === false && options.language !== "jsx" && nosort === false && tname !== "cfif" && tname !== "cfelseif" && tname !== "cfset") {
                    // if making use of the 'attribute_sort_list` option
                    if (asl > 0) {
                        const tempstore = [];
                        dq = 0;
                        eq = 0;
                        len = attstore.length;
                        // loop through the attribute_sort_list looking for attribute name matches
                        do {
                            // loop through the attstore
                            eq = 0;
                            do {
                                name = attstore[eq][0].split("=")[0];
                                if (attribute_sort_list[dq] === name) {
                                    tempstore.push(attstore[eq]);
                                    attstore.splice(eq, 1);
                                    len = len - 1;
                                    break;
                                }
                                eq = eq + 1;
                            } while (eq < len);
                            dq = dq + 1;
                        } while (dq < asl);
                        attstore = parse.safeSort(attstore, "", false);
                        attstore = tempstore.concat(attstore);
                        len = attstore.length;
                    }
                    else {
                        attstore = parse.safeSort(attstore, "", false);
                    }
                }
                // preparation for a coldfusion edge case
                if (tname.slice(0, 3).toLowerCase() === "cf_") {
                    cft = "required";
                }
                record.begin = begin;
                record.stack = stack;
                record.types = "attribute";
                store = [];
                if (ind < len) {
                    do {
                        if (attstore[ind] === undefined) {
                            break;
                        }
                        attstore[ind][0] = attstore[ind][0].replace(/\s+$/, "");
                        record.lines = attstore[ind][1];
                        eq = attstore[ind][0].indexOf("=");
                        dq = attstore[ind][0].indexOf("\"");
                        sq = attstore[ind][0].indexOf("'");
                        if ((/^\/(\/|\*)/).test(attstore[ind][0]) === true && options.language === "jsx") {
                            record.types = "comment_attribute";
                            record.token = attstore[ind][0];
                            convertQ();
                        }
                        else if (eq > -1 && store.length > 0) {
                            // put certain attributes together for coldfusion
                            record.token = store.join(" ");
                            convertQ();
                            if (attstore[ind][0].indexOf("=") > 0 && attstore[ind][0].indexOf("//") < 0 && attstore[ind][0].charAt(0) !== ";") {
                                record.token = attstore[ind][0].replace(/\s$/, "");
                            }
                            else {
                                record.token = attstore[ind][0];
                            }
                            convertQ();
                            store = [];
                        }
                        else if (ltype === "sgml") {
                            store.push(attstore[ind][0]);
                        }
                        else if (cft !== undefined && eq < 0 && attstore[ind][0].indexOf("=") < 0) {
                            // put certain attributes together for coldfusion
                            store.push(attstore[ind][0]);
                        }
                        else if ((cft !== undefined && eq < 0) || (dq > 0 && dq < eq) || (sq > 0 && sq < eq) || syntax.indexOf(attstore[ind][0].charAt(0)) > -1) {
                            // tags stored as attributes of other tags
                            templateAtt(attstore[ind][0].replace(/^("|')/, "").slice(0, 2), attstore[ind][0].replace(/\s$/, ""));
                        }
                        else if (eq < 0 && cft === undefined) {
                            // in most markup languages an attribute without an expressed value has its name
                            // as its string value
                            if (html === "html" && "[{(".indexOf(attstore[ind][0].charAt(0)) < 0 && attstore[ind][0].charAt(0) !== "#" && (/^\*?ng[A-Z]/).test(attstore[ind][0]) === false) {
                                record.token = attstore[ind][0].toLowerCase();
                            }
                            else if (options.language === "xml" || options.language === "coldfusion") {
                                if (options.lexer_options.markup.quote_convert === "single") {
                                    record.token = `${attstore[ind][0]}='${attstore[ind][0]}'`;
                                }
                                else {
                                    record.token = `${attstore[ind][0]}="${attstore[ind][0]}"`;
                                }
                            }
                            else {
                                record.token = attstore[ind][0];
                            }
                            convertQ();
                        }
                        else {
                            // separates out the attribute name from its value
                            slice = attstore[ind][0].slice(eq + 1);
                            if (syntax.indexOf(slice.charAt(0)) < 0 && cft === undefined) {
                                slice = "\"" + slice + "\"";
                            }
                            name = attstore[ind][0].slice(0, eq);
                            if (html === "html" && "[{(".indexOf(name.charAt(0)) < 0 && cft === undefined && (/^\*?ng[A-Z]/).test(attstore[ind][0]) === false) {
                                name = name.toLowerCase();
                            }
                            if (options.language === "jsx" && (/^(\s*\{)/).test(slice) === true) {
                                record.token = name + "={";
                                record.types = "jsx_attribute_start";
                                recordPush(data, record, "jsx_attribute");
                                sparser.lexers.script(slice.slice(1, slice.length - 1));
                                record.begin = parse.count;
                                if ((/\s\}$/).test(slice) === true) {
                                    slice = slice.slice(0, slice.length - 1);
                                    slice = (/\s+$/).exec(slice)[0];
                                    if (slice.indexOf("\n") < 0) {
                                        record.lines = 1;
                                    }
                                    else {
                                        record.lines = slice.split("\n").length;
                                    }
                                }
                                else {
                                    record.lines = 0;
                                }
                                record.begin = parse.structure[parse.structure.length - 1][1];
                                record.stack = parse.structure[parse.structure.length - 1][0];
                                record.token = "}";
                                record.types = "jsx_attribute_end";
                                convertQ();
                                record.types = "attribute";
                                record.begin = begin;
                                record.stack = stack;
                            }
                            else {
                                name = name + "=" + slice;
                                templateAtt(slice.replace(/^("|')/, "").slice(0, 2), name.replace(/(\s+)$/, ""));
                            }
                        }
                        ind = ind + 1;
                    } while (ind < len);
                }
                if (store.length > 0) {
                    record.token = store.join(" ");
                    convertQ();
                }
            };
            ext = false;
            // this complex series of conditions determines an elements delimiters look to
            // the types being pushed to quickly reason about the logic no type is pushed
            // for start tags or singleton tags just yet some types set the `preserve` flag,
            // which means to preserve internal white space The `nopush` flag is set when
            // parsed tags are to be ignored and forgotten
            (function lexer_markup_tag_types() {
                if (end === "]>") {
                    end = ">";
                    sgmlflag = sgmlflag - 1;
                    ltype = "end";
                }
                else if (end === "---") {
                    ltype = "comment";
                    start = "---";
                }
                else if (end === ")" && options.language === "vapor") {
                    ltype = "template";
                }
                else if (b[a] === "<") {
                    if (b[a + 1] === "/") {
                        if (b[a + 2] === "#") {
                            ltype = "template_end";
                        }
                        else {
                            ltype = "end";
                        }
                        end = ">";
                    }
                    else if (b[a + 1] === "!") {
                        if (b[a + 2] === "-" && b[a + 3] === "-") {
                            if (b[a + 4] === "#") {
                                end = "-->";
                                ltype = "template";
                            }
                            else if (b[a + 4] === "-" && (/<cf[a-z]/i).test(source) === true) {
                                end = "--->";
                                ltype = "comment";
                                start = "<!---";
                            }
                            else {
                                end = "-->";
                                ltype = "comment";
                                start = "<!--";
                            }
                        }
                        else if (b[a + 2] === "[" && b[a + 3] === "C" && b[a + 4] === "D" && b[a + 5] === "A" && b[a + 6] === "T" && b[a + 7] === "A" && b[a + 8] === "[") {
                            end = "]]>";
                            ltype = "cdata";
                            preserve = true;
                        }
                        else {
                            end = ">";
                            sgmlflag = sgmlflag + 1;
                            ltype = "sgml";
                        }
                    }
                    else if (b[a + 1] === "?") {
                        end = "?>";
                        if (b[a + 2] === "x" && b[a + 3] === "m" && b[a + 4] === "l") {
                            ltype = "xml";
                            simple = true;
                        }
                        else {
                            preserve = true;
                            ltype = "template";
                        }
                    }
                    else if (b[a + 1] === "%") {
                        preserve = true;
                        if (b[a + 2] === "-" && b[a + 3] === "-") {
                            end = "--%>";
                            ltype = "comment";
                            start = "<%--";
                        }
                        else if (b[a + 2] === "#") {
                            end = "%>";
                            ltype = "comment";
                            start = "<%#";
                        }
                        else {
                            end = "%>";
                            ltype = "template";
                        }
                    }
                    else if ((b[a + 1] === "p" || b[a + 1] === "P") && (b[a + 2] === "r" || b[a + 2] === "R") && (b[a + 3] === "e" || b[a + 3] === "E") && (b[a + 4] === ">" || (/\s/).test(b[a + 4]) === true)) {
                        end = "</pre>";
                        preserve = true;
                        ltype = "ignore";
                    }
                    else if ((b[a + 1] === "x" || b[a + 1] === "X") && (b[a + 2] === "m" || b[a + 2] === "M") && (b[a + 3] === "l" || b[a + 3] === "L") && b[a + 4] === ":" && (b[a + 5] === "t" || b[a + 5] === "T") && (b[a + 6] === "e" || b[a + 6] === "E") && (b[a + 7] === "x" || b[a + 7] === "X") && (b[a + 8] === "t" || b[a + 8] === "T") && (b[a + 9] === ">" || (/\s/).test(b[a + 9]) === true)) {
                        end = "</xsl:text>";
                        preserve = true;
                        ltype = "ignore";
                    }
                    else if ((b[a + 1] === "c" || b[a + 1] === "C") && (b[a + 2] === "f" || b[a + 2] === "F") && (b[a + 3] === "q" || b[a + 3] === "Q") && (b[a + 4] === "u" || b[a + 4] === "U") && (b[a + 5] === "e" || b[a + 5] === "E") && (b[a + 6] === "r" || b[a + 6] === "R") && (b[a + 7] === "y" || b[a + 7] === "Y") && (b[a + 8] === ">" || (/\s/).test(b[a + 8]) === true)) {
                        end = "</" + b.slice(a + 1, a + 8).join("") + ">";
                        preserve = true;
                        ltype = "content_preserve";
                    }
                    else if (b[a + 1] === "<") {
                        if (b[a + 2] === "<") {
                            end = ">>>";
                        }
                        else {
                            end = ">>";
                        }
                        ltype = "template";
                    }
                    else if (b[a + 1] === "#") {
                        if (b[a + 2] === "e" && b[a + 3] === "l" && b[a + 4] === "s" && b[a + 5] === "e") {
                            end = ">";
                            ltype = "template_else";
                        }
                        else if (b[a + 2] === "-" && b[a + 3] === "-") {
                            end = "-->";
                            ltype = "comment";
                            start = "<#--";
                        }
                        else {
                            end = ">";
                            ltype = "template_start";
                        }
                    }
                    else {
                        simple = true;
                        end = ">";
                    }
                }
                else if (b[a] === "{") {
                    preserve = true;
                    if (options.language === "jsx") {
                        ext = true;
                        earlyexit = true;
                        record.token = "{";
                        record.types = "script_start";
                        recordPush(data, record, "");
                        parse.structure.push(["script", parse.count]);
                        return;
                    }
                    if (options.language === "dustjs") {
                        if (b[a + 1] === ":" && b[a + 2] === "e" && b[a + 3] === "l" && b[a + 4] === "s" && b[a + 5] === "e" && b[a + 6] === "}") {
                            a = a + 6;
                            earlyexit = true;
                            record.token = "{:else}";
                            record.types = "template_else";
                            recordPush(data, record, "else");
                            return;
                        }
                        if (b[a + 1] === "!") {
                            end = "!}";
                            ltype = "comment";
                            start = "{!";
                        }
                        else if (b[a + 1] === "/") {
                            end = "}";
                            ltype = "template_end";
                        }
                        else if (b[a + 1] === "~") {
                            end = "}";
                            ltype = "singleton";
                        }
                        else if (b[a + 1] === ">") {
                            end = "/}";
                            ltype = "singleton";
                        }
                        else if (b[a + 1] === "#" || b[a + 1] === "?" || b[a + 1] === "^" || b[a + 1] === "@" || b[a + 1] === "<" || b[a + 1] === "+") {
                            end = "}";
                            ltype = "template_start";
                        }
                        else {
                            end = "}";
                            ltype = "template";
                        }
                    }
                    else if (b[a + 1] === "{") {
                        if (b[a + 2] === "{") {
                            end = "}}}";
                            ltype = "template";
                        }
                        else if (b[a + 2] === "#") {
                            end = "}}";
                            ltype = "template_start";
                        }
                        else if (b[a + 2] === "/") {
                            end = "}}";
                            ltype = "template_end";
                        }
                        else if (b[a + 2] === "e" && b[a + 3] === "n" && b[a + 4] === "d") {
                            end = "}}";
                            ltype = "template_end";
                        }
                        else if (b[a + 2] === "e" && b[a + 3] === "l" && b[a + 4] === "s" && b[a + 5] === "e") {
                            end = "}}";
                            ltype = "template_else";
                        }
                        else {
                            end = "}}";
                            ltype = "template";
                        }
                    }
                    else if (b[a + 1] === "%") {
                        end = "%}";
                        ltype = "template";
                    }
                    else if (b[a + 1] === "#") {
                        end = "#}";
                        ltype = "comment";
                        start = "{#";
                    }
                    else {
                        end = b[a + 1] + "}";
                        ltype = "template";
                    }
                    if (b[a + 1] === "@" && b[a + 2] === "}" && b[a + 3] === "e" && b[a + 4] === "l" && b[a + 5] === "s" && b[a + 6] === "e" && b[a + 7] === "{" && b[a + 8] === "@" && b[a + 9] === "}") {
                        a = a + 9;
                        earlyexit = true;
                        record.token = "{@}else{@}";
                        record.types = "template_else";
                        recordPush(data, record, "else");
                        return;
                    }
                }
                else if (b[a] === "[" && b[a + 1] === "%") {
                    end = "%]";
                    ltype = "template";
                }
                else if (b[a] === "#" && options.language === "apacheVelocity") {
                    if (b[a + 1] === "*") {
                        end = "*#";
                        ltype = "comment";
                        start = "#*";
                    }
                    else if (b[a + 1] === "[" && b[a + 2] === "[") {
                        end = "]]#";
                        ltype = "comment";
                        start = "#[[";
                    }
                    else if (b[a + 1] === "#") {
                        end = "\n";
                        ltype = "comment";
                        start = "##";
                    }
                    else if (b[a + 1] === "e" && b[a + 2] === "l" && b[a + 3] === "s" && b[a + 4] === "e" && (/\s/).test(b[a + 5]) === true) {
                        end = "\n";
                        ltype = "template_else";
                    }
                    else if (b[a + 1] === "i" && b[a + 2] === "f") {
                        end = "\n";
                        ltype = "template_start";
                    }
                    else if (b[a + 1] === "f" && b[a + 2] === "o" && b[a + 3] === "r" && b[a + 4] === "e" && b[a + 5] === "a" && b[a + 6] === "c" && b[a + 7] === "h") {
                        end = "\n";
                        ltype = "template_start";
                    }
                    else if (b[a + 1] === "e" && b[a + 2] === "n" && b[a + 3] === "d") {
                        end = "\n";
                        ltype = "template_end";
                    }
                    else {
                        end = "\n";
                        ltype = "template";
                    }
                }
                else if (b[a] === "$" && options.language === "apacheVelocity") {
                    end = "\n";
                    ltype = "template";
                }
                if (options.lexer_options.markup.unformatted === true) {
                    preserve = true;
                }
            }());
            if (earlyexit === true) {
                return;
            }
            // This is the real tag lexer. Everything that follows is attribute handling and
            // edge cases
            lastchar = end.charAt(end.length - 1);
            if (ltype === "comment" && b[a] === "<") {
                comm = parse.wrapCommentBlock({
                    chars: b,
                    end: c,
                    lexer: "markup",
                    opening: start,
                    start: a,
                    terminator: end
                });
                element = comm[0];
                a = comm[1];
                if (element.replace(start, "").replace(/(^\s*)/, "").indexOf("parse-ignore-start") === 0) {
                    record.token = element;
                    record.types = "ignore";
                    recordPush(data, record, "");
                    return;
                }
            }
            else if (a < c) {
                let bcount = 0, braccount = 0, jsxcount = 0, e = 0, f = 0, parncount = 0, lines = 1, quote = "", jsxquote = "", stest = false, quotetest = false, dustatt = [], attribute = [];
                const lex = [], 
                //finds slash escape sequences
                slashy = function lexer_markup_tag_slashy() {
                    let x = a;
                    do {
                        x = x - 1;
                    } while (b[x] === "\\");
                    x = a - x;
                    if (x % 2 === 1) {
                        return false;
                    }
                    return true;
                }, 
                // attribute lexer
                attributeLexer = function lexer_markup_tag_attributeLexer(quotes) {
                    let atty = "", name, aa = 0, bb = 0;
                    if (quotes === true) {
                        atty = attribute.join("");
                        name = arname(atty);
                        if (name[0] === "data-parse-ignore" || name[0] === "data-prettydiff-ignore") {
                            ignoreme = true;
                        }
                        quote = "";
                    }
                    else {
                        atty = attribute
                            .join("");
                        if (options.language !== "jsx" || (options.language === "jsx" && atty.charAt(atty.length - 1) !== "}")) {
                            atty = atty.replace(/\s+/g, " ");
                        }
                        name = arname(atty);
                        if (name[0] === "data-parse-ignore" || name[0] === "data-prettydiff-ignore") {
                            ignoreme = true;
                        }
                        if (options.language === "jsx" && attribute[0] === "{" && attribute[attribute.length - 1] === "}") {
                            jsxcount = 0;
                        }
                    }
                    if (atty.slice(0, 3) === "<%=" || atty.slice(0, 2) === "{%") {
                        nosort = true;
                    }
                    atty = atty
                        .replace(/^\u0020/, "")
                        .replace(/\u0020$/, "");
                    attribute = atty
                        .replace(/\r\n/g, "\n")
                        .split("\n");
                    bb = attribute.length;
                    if (aa < bb) {
                        do {
                            attribute[aa] = attribute[aa].replace(/(\s+)$/, "");
                            aa = aa + 1;
                        } while (aa < bb);
                    }
                    if (options.crlf === true) {
                        atty = attribute.join("\r\n");
                    }
                    else {
                        atty = attribute.join("\n");
                    }
                    atty = bracketSpace(atty);
                    if (atty === "=") {
                        attstore[attstore.length - 1][0] = `${attstore[attstore.length - 1][0]}=`;
                    }
                    else if (atty.charAt(0) === "=" && attstore.length > 0 && attstore[attstore.length - 1][0].indexOf("=") < 0) {
                        //if an attribute starts with a `=` then adjoin it to the last attribute
                        attstore[attstore.length - 1][0] = attstore[attstore.length - 1][0] + atty;
                    }
                    else if (atty.charAt(0) !== "=" && attstore.length > 0 && attstore[attstore.length - 1][0].indexOf("=") === attstore[attstore.length - 1][0].length - 1) {
                        // if an attribute follows an attribute ending with `=` then adjoin it to the
                        // last attribute
                        attstore[attstore.length - 1][0] = attstore[attstore.length - 1][0] + atty;
                    }
                    else if (options.language === "coldfusion" && attstore.length > 0 && (("+-\u002a/(^").indexOf(atty) > -1 || ("+-\u002a/(^").indexOf(attstore[attstore.length - 1][0].charAt(attstore[attstore.length - 1][0].length - 1)) > -1)) {
                        attstore[attstore.length - 1][0] = `${attstore[attstore.length - 1][0]} ${atty}`;
                    }
                    else if (atty !== "" && atty !== " ") {
                        attstore.push([atty, lines]);
                    }
                    if (attstore.length > 0 && attstore[attstore.length - 1][0].indexOf("=\u201c") > 0) {
                        sparser.parseerror = `Quote looking character (\u201c, &#x201c) used instead of actual quotes on line number ${parse.lineNumber}`;
                    }
                    else if (attstore.length > 0 && attstore[attstore.length - 1][0].indexOf("=\u201d") > 0) {
                        sparser.parseerror = `Quote looking character (\u201d, &#x201d) used instead of actual quotes on line number ${parse.lineNumber}`;
                    }
                    attribute = [];
                    lines = (b[a] === "\n")
                        ? 2
                        : 1;
                };
                do {
                    if (b[a] === "\n") {
                        lines = lines + 1;
                        if (options.language === "apacheVelocity" && lex[0] === "#") {
                            a = a - 1;
                            break;
                        }
                        parse.lineNumber = parse.lineNumber + 1;
                    }
                    if (preserve === true || (((/\s/).test(b[a]) === false && quote !== "}") || quote === "}")) {
                        lex.push(b[a]);
                        if (lex[0] === "<" && lex[1] === ">" && end === ">") {
                            record.token = "<>";
                            record.types = "start";
                            recordPush(data, record, "(empty)");
                            return;
                        }
                        if (lex[0] === "<" && lex[1] === "/" && lex[2] === ">" && end === ">") {
                            record.token = "</>";
                            record.types = "end";
                            recordPush(data, record, "");
                            return;
                        }
                    }
                    if (ltype === "cdata" && b[a] === ">" && b[a - 1] === "]" && b[a - 2] !== "]") {
                        sparser.parseerror = `CDATA tag ${lex.join("")} is not properly terminated with ]]>`;
                        break;
                    }
                    if (ltype === "comment") {
                        quote = "";
                        //comments must ignore fancy encapsulations and attribute parsing
                        if (b[a] === lastchar && lex.length > end.length + 1) {
                            //if current character matches the last character of the tag ending sequence
                            f = lex.length;
                            e = end.length - 1;
                            if (e > -1) {
                                do {
                                    f = f - 1;
                                    if (lex[f] !== end.charAt(e)) {
                                        break;
                                    }
                                    e = e - 1;
                                } while (e > -1);
                            }
                            if (e < 0) {
                                if (end === "endcomment") {
                                    f = f - 1;
                                    if ((/\s/).test(lex[f]) === true) {
                                        do {
                                            f = f - 1;
                                        } while (f > 0 && (/\s/).test(lex[f]) === true);
                                    }
                                    if (lex[f - 2] === "{" && lex[f - 1] === "%" && lex[f] === "-") {
                                        end = "-%}";
                                        lastchar = "}";
                                    }
                                    else if (lex[f - 1] === "{" && lex[f] === "%") {
                                        end = "%}";
                                        lastchar = "}";
                                    }
                                }
                                else {
                                    break;
                                }
                            }
                        }
                    }
                    else {
                        if (quote === "") {
                            if (lex[0] + lex[1] === "<!" && ltype !== "cdata") {
                                if (b[a] === "[") {
                                    if (b[a + 1] === "<") {
                                        ltype = "start";
                                        break;
                                    }
                                    if ((/\s/).test(b[a + 1]) === true) {
                                        do {
                                            a = a + 1;
                                            if (b[a] === "\n") {
                                                lines = lines + 1;
                                            }
                                        } while (a < c - 1 && (/\s/).test(b[a + 1]) === true);
                                    }
                                    if (b[a + 1] === "<") {
                                        ltype = "start";
                                        break;
                                    }
                                }
                                if (b[a] !== ">" && b[a + 1] === "<") {
                                    sparser.parseerror = `SGML tag ${lex.join("")} is missing termination with '[' or '>'.`;
                                    break;
                                }
                            }
                            if (options.language === "jsx") {
                                if (b[a] === "{") {
                                    jsxcount = jsxcount + 1;
                                }
                                else if (b[a] === "}") {
                                    jsxcount = jsxcount - 1;
                                }
                            }
                            if (data.types[parse.count] === "sgml" && b[a] === "[" && lex.length > 4) {
                                data.types[parse.count] = "template_start";
                                count.start = count.start + 1;
                                break;
                            }
                            if (b[a] === "<" && options.language !== "coldfusion" && preserve === false && lex.length > 1 && end !== ">>" && end !== ">>>" && simple === true) {
                                sparser.parseerror = `Parse error on line ${parse.lineNumber} on element: ${lex.join("")}`;
                            }
                            if (stest === true && (/\s/).test(b[a]) === false && b[a] !== lastchar) {
                                //attribute start
                                stest = false;
                                quote = jsxquote;
                                igcount = 0;
                                lex.pop();
                                if (a < c) {
                                    do {
                                        if (b[a] === "\n") {
                                            parse.lineNumber = parse.lineNumber + 1;
                                        }
                                        if (options.lexer_options.markup.unformatted === true) {
                                            lex.push(b[a]);
                                        }
                                        else {
                                            attribute.push(b[a]);
                                        }
                                        if ((b[a] === "<" || b[a] === ">") && (quote === "" || quote === ">") && options.language !== "jsx") {
                                            if (quote === "" && b[a] === "<") {
                                                quote = ">";
                                                braccount = 1;
                                            }
                                            else if (quote === ">") {
                                                if (b[a] === "<") {
                                                    braccount = braccount + 1;
                                                }
                                                else if (b[a] === ">") {
                                                    braccount = braccount - 1;
                                                    if (braccount === 0) {
                                                        // the following detects if a coldfusion tag is embedded within another markup
                                                        // tag
                                                        tname = tagName(attribute.join(""));
                                                        if (cftags[tname] === "required") {
                                                            quote = "</" + tname + ">";
                                                        }
                                                        else {
                                                            quote = "";
                                                            igcount = 0;
                                                            attributeLexer(false);
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        else if (quote === "") {
                                            if (b[a + 1] === lastchar) {
                                                //if at end of tag
                                                if (attribute[attribute.length - 1] === "/" || (attribute[attribute.length - 1] === "?" && ltype === "xml")) {
                                                    attribute.pop();
                                                    if (preserve === true) {
                                                        lex.pop();
                                                    }
                                                    a = a - 1;
                                                }
                                                if (attribute.length > 0) {
                                                    attributeLexer(false);
                                                }
                                                break;
                                            }
                                            if ((/^=?("|')?((\{(\{|%|#|@|:|\/|\?|\^|<|\+|~|=))|(\[%)|<)/).test(b[a] + b[a + 1] + b[a + 2] + b[a + 3]) === true) {
                                                attribute.pop();
                                                if (b[a] !== "=" && attribute.length > 0) {
                                                    attributeLexer(false);
                                                }
                                                quote = "";
                                                do {
                                                    attribute.push(b[a]);
                                                    if (b[a] === dustatt[dustatt.length - 1]) {
                                                        dustatt.pop();
                                                        if (b[a] === "}" && b[a + 1] === "}") {
                                                            attribute.push("}");
                                                            a = a + 1;
                                                            if (b[a + 1] === "}") {
                                                                attribute.push("}");
                                                                a = a + 1;
                                                            }
                                                        }
                                                        if (dustatt.length < 1) {
                                                            attributeLexer(false);
                                                            b[a] = " ";
                                                            break;
                                                        }
                                                    }
                                                    else if ((b[a] === "\"" || b[a] === "'") && dustatt[dustatt.length - 1] !== "\"" && dustatt[dustatt.length - 1] !== "'") {
                                                        dustatt.push(b[a]);
                                                    }
                                                    else if (b[a] === "{" && "{%#@:/?^<+~=".indexOf(b[a + 1]) && dustatt[dustatt.length - 1] !== "}") {
                                                        dustatt.push("}");
                                                    }
                                                    else if (b[a] === "<" && dustatt[dustatt.length - 1] !== ">") {
                                                        dustatt.push(">");
                                                    }
                                                    else if (b[a] === "[" && b[a + 1] === ":" && dustatt[dustatt.length - 1] !== "]") {
                                                        dustatt.push("]");
                                                    }
                                                    a = a + 1;
                                                } while (a < c);
                                            }
                                            else if (b[a] === "{" && b[a - 1] === "=" && options.language !== "jsx") {
                                                quote = "}";
                                            }
                                            else if (b[a] === "\"" || b[a] === "'") {
                                                quote = b[a];
                                                if (b[a - 1] === "=" &&
                                                    (b[a + 1] === "<" ||
                                                        (b[a + 1] === "{" && b[a + 2] === "%") ||
                                                        ((/\s/).test(b[a + 1]) === true && b[a - 1] !== "="))) {
                                                    igcount = a;
                                                }
                                            }
                                            else if (b[a] === "(") {
                                                quote = ")";
                                                parncount = 1;
                                            }
                                            else if (options.language === "jsx") {
                                                //jsx variable attribute
                                                if ((b[a - 1] === "=" || (/\s/).test(b[a - 1]) === true) && b[a] === "{") {
                                                    quote = "}";
                                                    bcount = 1;
                                                }
                                                else if (b[a] === "/") {
                                                    //jsx comments
                                                    if (b[a + 1] === "*") {
                                                        quote = "\u002a/";
                                                    }
                                                    else if (b[a + 1] === "/") {
                                                        quote = "\n";
                                                    }
                                                }
                                            }
                                            else if (lex[0] !== "{" && b[a] === "{" && (b[a + 1] === "{" || b[a + 1] === "%" || b[a + 1] === "@" || b[a + 1] === "#")) {
                                                //opening embedded template expression
                                                if (b[a + 1] === "{") {
                                                    if (b[a + 2] === "{") {
                                                        quote = "}}}";
                                                    }
                                                    else {
                                                        quote = "}}";
                                                    }
                                                }
                                                else {
                                                    quote = b[a + 1] + "}";
                                                }
                                            }
                                            if ((/\s/).test(b[a]) === true && quote === "") {
                                                // testing for a run of spaces between an attribute's = and a quoted value.
                                                // Unquoted values separated by space are separate attributes
                                                if (attribute[attribute.length - 2] === "=") {
                                                    e = a + 1;
                                                    if (e < c) {
                                                        do {
                                                            if ((/\s/).test(b[e]) === false) {
                                                                if (b[e] === "\"" || b[e] === "'") {
                                                                    a = e - 1;
                                                                    quotetest = true;
                                                                    attribute.pop();
                                                                }
                                                                break;
                                                            }
                                                            e = e + 1;
                                                        } while (e < c);
                                                    }
                                                }
                                                if (quotetest === true) {
                                                    quotetest = false;
                                                }
                                                else if (jsxcount === 0 || (jsxcount === 1 && attribute[0] === "{")) {
                                                    //if there is an unquoted space attribute is complete
                                                    attribute.pop();
                                                    attributeLexer(false);
                                                    stest = true;
                                                    break;
                                                }
                                            }
                                        }
                                        else if (b[a] === "(" && quote === ")") {
                                            parncount = parncount + 1;
                                        }
                                        else if (b[a] === ")" && quote === ")") {
                                            parncount = parncount - 1;
                                            if (parncount === 0) {
                                                quote = "";
                                                if (b[a + 1] === end.charAt(0)) {
                                                    attributeLexer(false);
                                                    break;
                                                }
                                            }
                                        }
                                        else if (options.language === "jsx" && (quote === "}" || (quote === "\n" && b[a] === "\n") || (quote === "\u002a/" && b[a - 1] === "*" && b[a] === "/"))) {
                                            //jsx attributes
                                            if (quote === "}") {
                                                if (b[a] === "{") {
                                                    bcount = bcount + 1;
                                                }
                                                else if (b[a] === quote) {
                                                    bcount = bcount - 1;
                                                    if (bcount === 0) {
                                                        jsxcount = 0;
                                                        quote = "";
                                                        element = attribute.join("");
                                                        if (options.lexer_options.markup.unformatted === false) {
                                                            if (options.language === "jsx") {
                                                                if ((/^(\s*)$/).test(element) === false) {
                                                                    attstore.push([element, lines]);
                                                                }
                                                            }
                                                            else {
                                                                element = element.replace(/\s+/g, " ");
                                                                if (element !== " ") {
                                                                    attstore.push([element, lines]);
                                                                }
                                                            }
                                                        }
                                                        attribute = [];
                                                        lines = 1;
                                                        break;
                                                    }
                                                }
                                            }
                                            else {
                                                jsxquote = "";
                                                jscom = true;
                                                element = attribute.join("");
                                                if (element !== " ") {
                                                    attstore.push([element, lines]);
                                                }
                                                attribute = [];
                                                lines = (quote === "\n")
                                                    ? 2
                                                    : 1;
                                                quote = "";
                                                break;
                                            }
                                        }
                                        else if (b[a] === "{" && b[a + 1] === "%" && b[igcount - 1] === "=" && (quote === "\"" || quote === "'")) {
                                            quote = quote + "{%";
                                            igcount = 0;
                                        }
                                        else if (b[a - 1] === "%" && b[a] === "}" && (quote === "\"{%" || quote === "'{%")) {
                                            quote = quote.charAt(0);
                                            igcount = 0;
                                        }
                                        else if (b[a] === "<" && end === ">" && b[igcount - 1] === "=" && (quote === "\"" || quote === "'")) {
                                            quote = quote + "<";
                                            igcount = 0;
                                        }
                                        else if (b[a] === ">" && (quote === "\"<" || quote === "'<")) {
                                            quote = quote.charAt(0);
                                            igcount = 0;
                                        }
                                        else if (igcount === 0 && quote !== ">" && (quote.length < 2 || (quote.charAt(0) !== "\"" && quote.charAt(0) !== "'"))) {
                                            //terminate attribute at the conclusion of a quote pair
                                            f = 0;
                                            if (lex.length > 1) {
                                                tname = lex[1] + lex[2];
                                                tname = tname.toLowerCase();
                                            }
                                            // in coldfusion quotes are escaped in a string with double the characters:
                                            // "cat"" and dog"
                                            if (tname === "cf" && b[a] === b[a + 1] && (b[a] === "\"" || b[a] === "'")) {
                                                attribute.push(b[a + 1]);
                                                a = a + 1;
                                            }
                                            else {
                                                e = quote.length - 1;
                                                if (e > -1) {
                                                    do {
                                                        if (b[a - f] !== quote.charAt(e)) {
                                                            break;
                                                        }
                                                        f = f + 1;
                                                        e = e - 1;
                                                    } while (e > -1);
                                                }
                                                if (e < 0) {
                                                    attributeLexer(true);
                                                    if (b[a + 1] === lastchar) {
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        else if (igcount > 0 && (/\s/).test(b[a]) === false) {
                                            igcount = 0;
                                        }
                                        a = a + 1;
                                    } while (a < c);
                                }
                            }
                            else if (end !== "%>" && end !== "\n" && (b[a] === "\"" || b[a] === "'")) {
                                //opening quote
                                quote = b[a];
                            }
                            else if (ltype !== "comment" && end !== "\n" && b[a] === "<" && b[a + 1] === "!" && b[a + 2] === "-" && b[a + 3] === "-" && b[a + 4] !== "#" && data.types[parse.count] !== "conditional") {
                                quote = "-->";
                            }
                            else if (b[a] === "{" && lex[0] !== "{" && end !== "\n" && end !== "%>" && end !== "%]" && (options.language === "dustjs" || b[a + 1] === "{" || b[a + 1] === "%" || b[a + 1] === "@" || b[a + 1] === "#")) {
                                //opening embedded template expression
                                if (b[a + 1] === "{") {
                                    if (b[a + 2] === "{") {
                                        quote = "}}}";
                                    }
                                    else {
                                        quote = "}}";
                                    }
                                }
                                else if (options.language === "dustjs") {
                                    if (attribute.length < 1 && (attstore.length < 1 || (/\s/).test(b[a - 1]) === true)) {
                                        lex.pop();
                                        do {
                                            if (b[a] === "\n") {
                                                lines = lines + 1;
                                            }
                                            attribute.push(b[a]);
                                            a = a + 1;
                                        } while (a < c && b[a] !== "}");
                                        attribute.push("}");
                                        attstore.push([attribute.join(""), lines]);
                                        attribute = [];
                                        lines = 1;
                                    }
                                    else {
                                        quote = "}";
                                    }
                                }
                                else {
                                    quote = b[a + 1] + "}";
                                    if (attribute.length < 1 && (attstore.length < 1 || (/\s/).test(b[a - 1]) === true)) {
                                        lex.pop();
                                        do {
                                            if (b[a] === "\n") {
                                                lines = lines + 1;
                                            }
                                            attribute.push(b[a]);
                                            a = a + 1;
                                        } while (a < c && b[a - 1] + b[a] !== quote);
                                        attribute.push("}");
                                        attstore.push([attribute.join(""), lines]);
                                        attribute = [];
                                        lines = 1;
                                        quote = "";
                                    }
                                }
                                if (quote === end) {
                                    quote = "";
                                }
                            }
                            else if ((simple === true || ltype === "sgml") && end !== "\n" && (/\s/).test(b[a]) === true && b[a - 1] !== "<") {
                                //identify a space in a regular start or singleton tag
                                if (ltype === "sgml") {
                                    lex.push(" ");
                                }
                                else {
                                    stest = true;
                                }
                            }
                            else if (simple === true && options.language === "jsx" && b[a] === "/" && (b[a + 1] === "*" || b[a + 1] === "/")) {
                                //jsx comment immediately following tag name
                                stest = true;
                                lex[lex.length - 1] = " ";
                                attribute.push(b[a]);
                                if (b[a + 1] === "*") {
                                    jsxquote = "\u002a/";
                                }
                                else {
                                    jsxquote = "\n";
                                }
                            }
                            else if ((b[a] === lastchar || (end === "\n" && b[a + 1] === "<")) && (lex.length > end.length + 1 || lex[0] === "]") && (options.language !== "jsx" || jsxcount === 0)) {
                                if (end === "\n") {
                                    if ((/\s/).test(lex[lex.length - 1]) === true) {
                                        do {
                                            lex.pop();
                                            a = a - 1;
                                        } while ((/\s/).test(lex[lex.length - 1]) === true);
                                    }
                                    break;
                                }
                                if (lex[0] === "{" && lex[1] === "%" && lex.join("").replace(/\s+/g, "") === "{%comment%}") {
                                    end = "endcomment";
                                    lastchar = "t";
                                    preserve = true;
                                    ltype = "comment";
                                }
                                else if (lex[0] === "{" && lex[1] === "%" && lex[2] === "-" && lex.join("").replace(/\s+/g, "") === "{%-comment-%}") {
                                    end = "endcomment";
                                    lastchar = "t";
                                    preserve = true;
                                    ltype = "comment";
                                }
                                else {
                                    //if current character matches the last character of the tag ending sequence
                                    f = lex.length;
                                    e = end.length - 1;
                                    if (e > -1) {
                                        do {
                                            f = f - 1;
                                            if (lex[f] !== end.charAt(e)) {
                                                break;
                                            }
                                            e = e - 1;
                                        } while (e > -1);
                                    }
                                    if (e < 0) {
                                        break;
                                    }
                                }
                            }
                        }
                        else if (b[a] === quote.charAt(quote.length - 1) && ((options.language === "jsx" && end === "}" && (b[a - 1] !== "\\" || slashy() === false)) || options.language !== "jsx" || end !== "}")) {
                            //find the closing quote or embedded template expression
                            f = 0;
                            if (lex.length > 1) {
                                tname = lex[1] + lex[2];
                                tname = tname.toLowerCase();
                            }
                            // in coldfusion quotes are escaped in a string with double the characters:
                            // "cat"" and dog"
                            if (tname === "cf" && b[a] === b[a + 1] && (b[a] === "\"" || b[a] === "'")) {
                                attribute.push(b[a + 1]);
                                a = a + 1;
                            }
                            else {
                                e = quote.length - 1;
                                if (e > -1) {
                                    do {
                                        if (b[a - f] !== quote.charAt(e)) {
                                            break;
                                        }
                                        f = f + 1;
                                        e = e - 1;
                                    } while (e > -1);
                                }
                                if (e < 0) {
                                    quote = "";
                                }
                            }
                        }
                    }
                    a = a + 1;
                } while (a < c);
                //a correction to incomplete template tags that use multiple angle braces
                if (options.correct === true) {
                    if (b[a + 1] === ">" && lex[0] === "<" && lex[1] !== "<") {
                        do {
                            a = a + 1;
                        } while (b[a + 1] === ">");
                    }
                    else if (lex[0] === "<" && lex[1] === "<" && b[a + 1] !== ">" && lex[lex.length - 2] !== ">") {
                        do {
                            lex.splice(1, 1);
                        } while (lex[1] === "<");
                    }
                }
                igcount = 0;
                element = lex.join("");
                tname = tagName(element);
                element = bracketSpace(element);
                if (tname === "xml") {
                    html = "xml";
                }
                else if (html === "" && tname === "!DOCTYPE" && element.toLowerCase().indexOf("xhtml") > 0) {
                    html = "xml";
                }
                else if (html === "" && tname === "html") {
                    html = "html";
                }
                if (element.replace(start, "").replace(/^\s+/, "").indexOf("parse-ignore-start") === 0) {
                    a = a + 1;
                    do {
                        lex.push(b[a]);
                        if (b[a] === "d" && lex.slice(lex.length - 16).join("") === "parse-ignore-end") {
                            break;
                        }
                        a = a + 1;
                    } while (a < c);
                    do {
                        lex.push(b[a]);
                        if (b[a] === end.charAt(end.length - 1) && b.slice(a - (end.length - 1), a + 1).join("") === end) {
                            break;
                        }
                        a = a + 1;
                    } while (a < c);
                    record.token = lex.join("");
                    record.types = "ignore";
                    recordPush(data, record, "");
                    return;
                }
            }
            record.token = element;
            record.types = ltype;
            tname = tagName(element);
            // Twig language allows {% block %} elements to be singleton or start.  You don't
            // know until you encounter a {% endblock %} tag
            if (tname === "endblock" && element.slice(0, 2) === "{%") {
                const endName = element.replace(/\{%\s*endblock\s+/, "").replace(/\s*%\}/, "");
                let aa = parse.count, bb = parse.count, startName = "";
                do {
                    if (data.types[aa].indexOf("end") > 0) {
                        aa = data.begin[aa];
                        if (aa < 0) {
                            break;
                        }
                    }
                    else if ((/\{%\s*block/).test(data.token[aa]) === true) {
                        if (endName === "") {
                            break;
                        }
                        startName = data.token[aa].replace(/\{%\s*block\s+/, "").split(/\s+/)[0].replace(/\s+/, "");
                        if (endName === startName) {
                            break;
                        }
                    }
                    aa = aa - 1;
                } while (aa > -1);
                count.start = count.start + 1;
                data.types[aa] = "template_start";
                data.ender[aa] = parse.count + 1;
                record.begin = aa;
                record.stack = "block";
                record.token = element;
                record.types = "template_end";
                if (aa > -1) {
                    do {
                        if (data.types[bb].indexOf("end") > 0) {
                            bb = data.begin[bb];
                            data.begin[bb] = aa;
                            data.stack[bb] = "block";
                        }
                        else if (data.begin[bb] < aa) {
                            data.begin[bb] = aa;
                            if (data.types[bb].indexOf("start") < 0) {
                                data.ender[bb] = parse.count + 1;
                            }
                            data.stack[bb] = "block";
                        }
                        bb = bb - 1;
                    } while (bb > aa);
                }
                parse.structure.push(["block", aa]);
                recordPush(data, record, "");
                return;
            }
            if ((/^(\/?cf)/i).test(tname) === true) {
                tname = tname
                    .toLowerCase()
                    .replace(/\/$/, "")
                    .replace(/^\//, "");
            }
            if (preserve === false && options.language !== "jsx") {
                element = element.replace(/\s+/g, " ");
            }
            //a quick hack to inject records for a type of template comments
            if (tname === "comment" && element.slice(0, 2) === "{%") {
                const lineFindStart = function lexer_markup_tag_lineFindStart(spaces) {
                    if (spaces === "") {
                        linesStart = 0;
                    }
                    else {
                        linesStart = spaces.split("\n").length;
                    }
                    return "";
                }, lineFindEnd = function lexer_markup_tag_lineFindEnd(spaces) {
                    if (spaces === "") {
                        linesEnd = 0;
                    }
                    else {
                        linesEnd = spaces.split("\n").length;
                    }
                    return "";
                };
                let linesStart = 0, linesEnd = 0;
                record.begin = parse.structure[parse.structure.length - 1][1];
                record.ender = parse.count + 3;
                record.stack = parse.structure[parse.structure.length - 1][0];
                record.types = "template_start";
                if (element.charAt(2) === "-") {
                    element = element
                        .replace(/^(\s*\{%-\s*comment\s*-%\})/, "")
                        .replace(/(\{%-\s*endcomment\s*-%\}\s*)$/, "");
                    record.token = "{%- comment -%}";
                    recordPush(data, record, "comment");
                    record.begin = parse.count;
                    element = element.replace(/^\s*/, lineFindStart);
                    element = element.replace(/\s*$/, lineFindEnd);
                    record.lines = linesStart;
                    record.stack = "comment";
                    record.token = element;
                    record.types = "comment";
                    recordPush(data, record, "");
                    record.token = "{%- endcomment -%}";
                }
                else {
                    element = element
                        .replace(/^(\s*\{%\s*comment\s*%\})/, "")
                        .replace(/(\{%\s*endcomment\s*%\}\s*)$/, "");
                    record.token = "{% comment %}";
                    recordPush(data, record, "comment");
                    record.begin = parse.count;
                    element = element.replace(/^\s*/, lineFindStart);
                    element = element.replace(/\s*$/, lineFindEnd);
                    record.lines = linesStart;
                    record.stack = "comment";
                    record.token = element;
                    record.types = "comment";
                    recordPush(data, record, "");
                    record.token = "{% endcomment %}";
                }
                record.lines = linesEnd;
                record.types = "template_end";
                recordPush(data, record, "");
                return;
            }
            // a type correction for template tags who have variable start tag names but a
            // consistent ending tag name
            if (element.indexOf("{{") === 0 && element.slice(element.length - 2) === "}}") {
                if (tname === "end") {
                    ltype = "template_end";
                }
                else if (tname === "else") {
                    ltype = "template_else";
                }
            }
            else if (element.slice(0, 2) === "<%" && element.slice(element.length - 2) === "%>") {
                if ((/^(<%\s+end\s+-?%>)$/).test(element) === true) {
                    ltype = "template_end";
                }
                else if (((/\sdo\s/).test(element) === true && (/\s-?%>$/).test(element) === true) || (/^(<%(%|-|=)?\s*if)/).test(element) === true) {
                    ltype = "template_start";
                }
            }
            record.types = ltype;
            //update a flag for subatomic parsing in SGML tags
            if (end !== "]>" && sgmlflag > 0 && element.charAt(element.length - 1) !== "[" && (element.slice(element.length - 2) === "]>" || (/^(<!((doctype)|(notation))\s)/i).test(element) === true)) {
                sgmlflag = sgmlflag - 1;
            }
            // cheat identifies HTML singleton elements as singletons even if formatted as
            // start tags, such as <br> (which is really <br/>)
            cheat = (function lexer_markup_tag_cheat() {
                let cfval = "", struc = [];
                const ender = (/(\/>)$/), htmlsings = {
                    area: "singleton",
                    base: "singleton",
                    basefont: "singleton",
                    br: "singleton",
                    col: "singleton",
                    embed: "singleton",
                    eventsource: "singleton",
                    frame: "singleton",
                    hr: "singleton",
                    image: "singleton",
                    img: "singleton",
                    input: "singleton",
                    isindex: "singleton",
                    keygen: "singleton",
                    link: "singleton",
                    meta: "singleton",
                    param: "singleton",
                    progress: "singleton",
                    source: "singleton",
                    wbr: "singleton"
                }, fixsingleton = function lexer_markup_tag_cheat_fixsingleton() {
                    let aa = parse.count, bb = 0;
                    const vname = tname.slice(1);
                    if (aa > -1) {
                        do {
                            if (data.types[aa] === "end") {
                                bb = bb + 1;
                            }
                            else if (data.types[aa] === "start") {
                                bb = bb - 1;
                                if (bb < 0) {
                                    return false;
                                }
                            }
                            if (bb === 0 && data.token[aa].toLowerCase().indexOf(vname) === 1) {
                                if (cftags[tname] === undefined) {
                                    data.types[aa] = "start";
                                }
                                else {
                                    data.types[aa] = "template_start";
                                }
                                count.start = count.start + 1;
                                data.token[aa] = data
                                    .token[aa]
                                    .replace(/(\s*\/>)$/, ">");
                                return false;
                            }
                            aa = aa - 1;
                        } while (aa > -1);
                    }
                    return false;
                }, peertest = function lexer_markup_tag_cheat_peertest(name, item) {
                    if (htmlblocks[name] === undefined) {
                        return false;
                    }
                    if (name === item) {
                        return true;
                    }
                    if (name === "dd" && item === "dt") {
                        return true;
                    }
                    if (name === "dt" && item === "dd") {
                        return true;
                    }
                    if (name === "td" && item === "th") {
                        return true;
                    }
                    if (name === "th" && item === "td") {
                        return true;
                    }
                    if (name === "colgroup" && (item === "tbody" || item === "tfoot" || item === "thead" || item === "tr")) {
                        return true;
                    }
                    if (name === "tbody" && (item === "colgroup" || item === "tfoot" || item === "thead")) {
                        return true;
                    }
                    if (name === "tfoot" && (item === "colgroup" || item === "tbody" || item === "thead")) {
                        return true;
                    }
                    if (name === "thead" && (item === "colgroup" || item === "tbody" || item === "tfoot")) {
                        return true;
                    }
                    if (name === "tr" && item === "colgroup") {
                        return true;
                    }
                    return false;
                }, addHtmlEnd = function (count) {
                    record.lines = (data.lines[parse.count] > 0) ? 1 : 0;
                    record.token = `</${parse.structure[parse.structure.length - 1][0]}>`;
                    record.types = "end";
                    recordPush(data, record, "");
                    if (count > 0) {
                        do {
                            record.begin = parse.structure[parse.structure.length - 1][1];
                            record.stack = parse.structure[parse.structure.length - 1][0];
                            record.token = `</${parse.structure[parse.structure.length - 1][0]}>`;
                            recordPush(data, record, "");
                            count = count - 1;
                        } while (count > 0);
                    }
                    record.begin = parse.structure[parse.structure.length - 1][1];
                    record.lines = parse.linesSpace;
                    record.stack = parse.structure[parse.structure.length - 1][0];
                    record.token = element;
                    record.types = "end";
                    data.lines[parse.count - 1] = 0;
                };
                //determine if the current end tag is actually part of an HTML singleton
                if (ltype === "end" && tname.slice(0, 3) !== "/cf") {
                    const lastToken = data.token[parse.count];
                    if (data.types[parse.count - 1] === "singleton" && lastToken.charAt(lastToken.length - 2) !== "/" && "/" + tagName(lastToken) === tname) {
                        data.types[parse.count - 1] = "start";
                    }
                    else if (tname !== "/span" &&
                        tname !== "/div" &&
                        tname !== "/script" &&
                        options.lexer_options.markup.tag_merge === true &&
                        (html !== "html" || (html === "html" && tname !== "/li"))) {
                        if (tname === "/" + tagName(data.token[parse.count]) && data.types[parse.count] === "start") {
                            parse.structure.pop();
                            data.token[parse.count] = data
                                .token[parse.count]
                                .replace(/>$/, "/>");
                            data.types[parse.count] = "singleton";
                            singleton = true;
                            count.start = count.start - 1;
                            return false;
                        }
                        if (tname === "/" + tagName(data.token[data.begin[parse.count]]) && data.types[parse.count].indexOf("attribute") > -1 && data.types[data.begin[parse.count]] === "start") {
                            parse.structure.pop();
                            data.token[data.begin[parse.count]] = data
                                .token[data.begin[parse.count]]
                                .replace(/>$/, "/>");
                            data.types[data.begin[parse.count]] = "singleton";
                            singleton = true;
                            count.start = count.start - 1;
                            return false;
                        }
                    }
                }
                //renames the types value for the following two template tags
                if (tname === "/#assign" || tname === "/#global") {
                    let dd = parse.count - 1, tcount = 1;
                    if (dd > -1) {
                        do {
                            if (data.types[dd] === "start" || data.types[dd] === "template_start") {
                                tcount = tcount - 1;
                            }
                            else if (data.types[dd] === "end" || data.types[dd] === "template_end") {
                                tcount = tcount + 1;
                            }
                            if (tcount === 1) {
                                if ((data.token[dd].indexOf("<#assign") === 0 && tname === "/#assign") || (data.token[dd].indexOf("<#global") === 0 && tname === "/#global")) {
                                    data.types[dd] = "template_start";
                                    count.start = count.start + 1;
                                    return false;
                                }
                            }
                            if (tcount === 0) {
                                return false;
                            }
                            dd = dd - 1;
                        } while (dd > -1);
                    }
                    return false;
                }
                //determines if custom coldfusion tags are singletons
                cfval = cftags[tname];
                if (data.types[parse.count] === "end" && tname.slice(0, 3) === "/cf" && cfval !== undefined) {
                    if (tname === "/cftransaction") {
                        cftransaction = false;
                    }
                    if (cfval !== undefined) {
                        data.types[parse.count] = "template_end";
                    }
                    if ((cfval === "optional" || cfval === "prohibited") && tname !== "/cftransaction") {
                        return fixsingleton();
                    }
                    return false;
                }
                //processes all other coldfusion tags
                if (tname.slice(0, 2) === "cf") {
                    if (tname === "cfelse" || tname === "cfelseif") {
                        record.token = element;
                        record.types = "template_else";
                        recordPush(data, record, tname);
                        singleton = true;
                        return false;
                    }
                    if (tname === "cftransaction" && cftransaction === true) {
                        if (element.charAt(1) === "/") {
                            record.types = "template_end";
                        }
                        else {
                            cfval = "prohibited";
                        }
                    }
                    else {
                        cfval = cftags[tname];
                    }
                    if (tname === "cfscript" && element.indexOf("</cfscript") !== 0) {
                        ext = true;
                    }
                    if (cfval === "optional" || cfval === "prohibited" || tname.slice(0, 3) === "cf_") {
                        if (options.correct === true && ender.test(element) === false) {
                            element = element.slice(0, element.length - 1) + "/>";
                        }
                        record.token = element.replace(/\s+/, " ");
                        record.types = "template";
                        // The following madness is required because cfmodule may be a singleton or a block.
                        // You don't know until you encounter the end tag
                        if (tname === "cfmodule" && element.charAt(1) === "/") {
                            let ss = parse.count, tt = 1;
                            do {
                                if (data.token[ss].toLowerCase() === "<cfmodule>") {
                                    tt = tt - 1;
                                    if (tt < 1) {
                                        break;
                                    }
                                }
                                else if (data.token[ss].toLowerCase() === "</cfmodule>") {
                                    tt = tt + 1;
                                }
                                ss = ss - 1;
                            } while (ss > -1);
                            data.types[ss] = "template_start";
                            count.start = count.start + 1;
                            tt = Math.min(ss + 1, parse.count);
                            struc = [["cfmodule", ss]];
                            ss = parse.count + 1;
                            do {
                                data.begin[tt] = struc[struc.length - 1][1];
                                data.stack[tt] = struc[struc.length - 1][0];
                                if (data.types[tt] === "end" || data.types[tt].indexOf("_end") > 0) {
                                    if (struc.length > 1) {
                                        struc.pop();
                                    }
                                }
                                else if (data.types[tt] === "start" || data.types[tt].indexOf("_start") > 0) {
                                    struc.push([tagName(data.token[tt]), tt]);
                                }
                                tt = tt + 1;
                            } while (tt < ss);
                            parse.structure.push(struc[0]);
                            record.begin = struc[0][1];
                            record.stack = "cfmodule";
                            record.types = "template_end";
                        }
                        recordPush(data, record, "");
                        singleton = true;
                        return false;
                    }
                    if (cfval === "required" && tname !== "cfquery") {
                        if (tname === "cftransaction" && cftransaction === false) {
                            cftransaction = true;
                        }
                        record.token = element;
                        record.types = (ltype === "end")
                            ? "template_end"
                            : "template_start";
                        recordPush(data, record, tname);
                        singleton = true;
                    }
                    return false;
                }
                if (html === "html") {
                    // html gets tag names in lowercase, if you want to preserve case sensitivity
                    // beautify as XML
                    if (element.charAt(0) === "<" && element.charAt(1) !== "!" && element.charAt(1) !== "?" && (parse.count < 0 || data.types[parse.count].indexOf("template") < 0) && cftags[tname] === undefined && tname.slice(0, 3) !== "cf_") {
                        element = element.toLowerCase();
                    }
                    if (htmlblocks[parse.structure[parse.structure.length - 1][0]] === "block" && peertest(tname.slice(1), parse.structure[parse.structure.length - 2][0]) === true) {
                        // looks for HTML tags missing an ending pair when encountering an ending tag for a parent node
                        addHtmlEnd(0);
                    }
                    else if (parse.structure.length > 3 &&
                        htmlblocks[parse.structure[parse.structure.length - 1][0]] === "block" &&
                        htmlblocks[parse.structure[parse.structure.length - 2][0]] === "block" &&
                        htmlblocks[parse.structure[parse.structure.length - 3][0]] === "block" &&
                        peertest(tname, parse.structure[parse.structure.length - 4][0]) === true) {
                        // looks for consecutive missing end tags
                        addHtmlEnd(3);
                    }
                    else if (parse.structure.length > 2 &&
                        htmlblocks[parse.structure[parse.structure.length - 1][0]] === "block" &&
                        htmlblocks[parse.structure[parse.structure.length - 2][0]] === "block" &&
                        peertest(tname, parse.structure[parse.structure.length - 3][0]) === true) {
                        // looks for consecutive missing end tags
                        addHtmlEnd(2);
                    }
                    else if (parse.structure.length > 1 &&
                        htmlblocks[parse.structure[parse.structure.length - 1][0]] === "block" &&
                        peertest(tname, parse.structure[parse.structure.length - 2][0]) === true) {
                        // looks for consecutive missing end tags
                        addHtmlEnd(1);
                    }
                    else if (peertest(tname, parse.structure[parse.structure.length - 1][0]) === true) {
                        // certain tags cannot contain other certain tags if such tags are peers
                        addHtmlEnd(0);
                    }
                    else if (tname.charAt(0) === "/" && htmlblocks[parse.structure[parse.structure.length - 1][0]] === "block" && parse.structure[parse.structure.length - 1][0] !== tname.slice(1)) {
                        // looks for consecutive missing end tags if the current element is an end tag
                        fixHtmlEnd(element, false);
                        record.begin = parse.structure[parse.structure.length - 1][1];
                        record.lines = parse.linesSpace;
                        record.stack = parse.structure[parse.structure.length - 1][0];
                        record.token = element;
                        record.types = "end";
                        data.lines[parse.count - 1] = 0;
                    }
                    // generalized corrections for the handling of singleton tags
                    if (data.types[parse.count] === "end" && htmlsings[tname.slice(1)] === "singleton" && element.toLowerCase().indexOf("/cftransaction") !== 1) {
                        return fixsingleton();
                    }
                    //inserts a trailing slash into singleton tags if they do not already have it
                    if (htmlsings[tname] === "singleton") {
                        if (options.correct === true && ender.test(element) === false) {
                            element = element.slice(0, element.length - 1) + " />";
                        }
                        return true;
                    }
                }
                return false;
            }());
            //This escape flag is set in the cheat function
            if (singleton === true) {
                attributeRecord();
                return;
            }
            //tags with the following names are singletons
            if (tname.charAt(0) === "#" && data.types[parse.count] === "start" && (tname === "#assign" || tname === "#break" || tname === "#case" || tname === "#default" || tname === "#fallback" || tname === "#flush" || tname === "#ftl" || tname === "#global" || tname === "#import" || tname === "#include" || tname === "#local" || tname === "#t" || tname === "#lt" || tname === "#rt" || tname === "#nested" || tname === "#nt" || tname === "#recover" || tname === "#recurse" || tname === "#return" || tname === "#sep" || tname === "#setting" || tname === "#stop" || tname === "#visit")) {
                simple = true;
            }
            //correction for dustjs tags to template singleton types
            if (options.language === "dustjs" && data.types[parse.count] === "template_start") {
                const first = element.charAt(1), ending = element.slice(element.length - 2);
                if ((ending === "/}" || ending.charAt(0) === first) && (first === "#" || first === "?" || first === "^" || first === "@" || first === "<" || first === "+")) {
                    data.types[parse.count] = "template";
                }
            }
            // determine if the markup tag potentially contains code interpreted by a
            // different lexer
            if ((tname === "script" || tname === "style" || tname === "cfscript") && element.slice(element.length - 2) !== "/>") {
                //get the attribute value for "type"
                let len = attstore.length - 1, attValue = "", attr = [];
                if (len > -1) {
                    do {
                        attr = arname(attstore[len][0]);
                        if (attr[0] === "type") {
                            attValue = attr[1];
                            if (attValue.charAt(0) === "\"" || attValue.charAt(0) === "'") {
                                attValue = attValue.slice(1, attValue.length - 1);
                            }
                            break;
                        }
                        len = len - 1;
                    } while (len > -1);
                }
                //ext is flag to send information between the tag lexer and the content lexer
                if (tname === "script" && (attValue === "" || attValue === "text/javascript" || attValue === "babel" || attValue === "module" || attValue === "application/javascript" || attValue === "application/x-javascript" || attValue === "text/ecmascript" || attValue === "application/ecmascript" || attValue === "text/jsx" || attValue === "application/jsx" || attValue === "text/cjs")) {
                    ext = true;
                }
                else if (tname === "style" && options.language !== "jsx" && (attValue === "" || attValue === "text/css")) {
                    ext = true;
                }
                else if (tname === "cfscript") {
                    ext = true;
                }
                if (ext === true) {
                    len = a + 1;
                    if (len < c) {
                        do {
                            if ((/\s/).test(b[len]) === false) {
                                if (b[len] === "<") {
                                    if (b.slice(len + 1, len + 4).join("") === "!--") {
                                        len = len + 4;
                                        if (len < c) {
                                            do {
                                                if ((/\s/).test(b[len]) === false) {
                                                    ext = false;
                                                    break;
                                                }
                                                if (b[len] === "\n" || b[len] === "\r") {
                                                    break;
                                                }
                                                len = len + 1;
                                            } while (len < c);
                                        }
                                    }
                                    else {
                                        ext = false;
                                    }
                                }
                                break;
                            }
                            len = len + 1;
                        } while (len < c);
                    }
                }
            }
            //am I a singleton or a start type?
            if (simple === true && ignoreme === false && ltype !== "xml" && ltype !== "sgml") {
                if (cheat === true || element.slice(element.length - 2) === "/>") {
                    ltype = "singleton";
                }
                else {
                    ltype = "start";
                }
                record.types = ltype;
            }
            // additional logic is required to find the end of a tag with the attribute
            // data-parse-ignore
            if (simple === true && preserve === false && ignoreme && end === ">" && element.slice(element.length - 2) !== "/>") {
                let tags = [], atstring = [];
                if (cheat === true) {
                    ltype = "singleton";
                }
                else {
                    attstore.forEach(function lexer_markup_tag_atstore(value) {
                        atstring.push(value[0]);
                    });
                    preserve = true;
                    ltype = "ignore";
                    a = a + 1;
                    if (a < c) {
                        let delim = "", ee = 0, ff = 0, endtag = false;
                        do {
                            if (b[a] === "\n") {
                                parse.lineNumber = parse.lineNumber + 1;
                            }
                            tags.push(b[a]);
                            if (delim === "") {
                                if (b[a] === "\"") {
                                    delim = "\"";
                                }
                                else if (b[a] === "'") {
                                    delim = "'";
                                }
                                else if (tags[0] !== "{" && b[a] === "{" && (options.language === "dustjs" || b[a + 1] === "{" || b[a + 1] === "%" || b[a + 1] === "@" || b[a + 1] === "#")) {
                                    if (b[a + 1] === "{") {
                                        if (b[a + 2] === "{") {
                                            delim = "}}}";
                                        }
                                        else {
                                            delim = "}}";
                                        }
                                    }
                                    else if (options.language === "dustjs") {
                                        delim = "}";
                                    }
                                    else {
                                        delim = b[a + 1] + "}";
                                    }
                                }
                                else if (b[a] === "<" && simple === true) {
                                    if (b[a + 1] === "/") {
                                        endtag = true;
                                    }
                                    else {
                                        endtag = false;
                                    }
                                }
                                else if (b[a] === lastchar && b[a - 1] !== "/") {
                                    if (endtag === true) {
                                        igcount = igcount - 1;
                                        if (igcount < 0) {
                                            break;
                                        }
                                    }
                                    else {
                                        igcount = igcount + 1;
                                    }
                                }
                            }
                            else if (b[a] === delim.charAt(delim.length - 1)) {
                                ff = 0;
                                ee = delim.length - 1;
                                if (ee > -1) {
                                    do {
                                        if (b[a - ff] !== delim.charAt(ee)) {
                                            break;
                                        }
                                        ff = ff + 1;
                                        ee = ee - 1;
                                    } while (ee > -1);
                                }
                                if (ee < 0) {
                                    delim = "";
                                }
                            }
                            a = a + 1;
                        } while (a < c);
                    }
                }
                element = element + tags.join("");
                element = element.replace(">", ` ${atstring.join(" ")}>`);
                record.token = element;
                record.types = "content-ignore";
                attstore = [];
            }
            // some template tags can be evaluated as a block start/end based on syntax
            // alone
            if (record.types.indexOf("template") > -1) {
                if (element.slice(0, 2) === "{%") {
                    let names = [
                        "autoescape",
                        "case",
                        "capture",
                        "comment",
                        "embed",
                        "filter",
                        "for",
                        "form",
                        "if",
                        "macro",
                        "paginate",
                        "raw",
                        "sandbox",
                        "spaceless",
                        "switch",
                        "tablerow",
                        "unless",
                        "verbatim"
                    ];
                    if ((tname === "case" || tname === "default") && (parse.structure[parse.structure.length - 1][0] === "switch" || parse.structure[parse.structure.length - 1][0] === "case")) {
                        record.types = "template_else";
                    }
                    else if (tname === "else" || tname === "elseif" || tname === "when" || tname === "elif" || tname === "elsif") {
                        record.types = "template_else";
                    }
                    else {
                        let namelen = names.length - 1;
                        do {
                            if (tname === names[namelen]) {
                                record.types = "template_start";
                                break;
                            }
                            if (tname === "end" + names[namelen]) {
                                record.types = "template_end";
                                break;
                            }
                            namelen = namelen - 1;
                        } while (namelen > -1);
                    }
                }
                else if (element.slice(0, 2) === "<%" && options.language === "silverstripe") {
                    if (tname === "if" || tname === "loop" || tname === "with" || tname === "control" || tname === "cached" || tname === "uncached") {
                        record.types = "template_start";
                    }
                    else if (tname === "else" || tname === "else_if") {
                        record.types = "template_else";
                    }
                    else if (tname === "end_if" || tname === "end_loop" || tname === "end_with" || tname === "end_control" || tname === "end_cached" || tname === "end_uncached") {
                        record.types = "template_end";
                    }
                }
                else if (element.slice(0, 2) === "{{" && element.charAt(3) !== "{") {
                    if ((/^(\{\{\s*-?\s*end\s*-?\s*\}\})$/).test(element) === true) {
                        record.types = "template_end";
                    }
                    else if (tname === "define" || tname === "form" || tname === "if" || tname === "range" || tname === "with") {
                        record.types = "template_start";
                    }
                }
                else if (record.types === "template") {
                    if (element.indexOf("else") > 2) {
                        record.types = "template_else";
                    }
                    else if ((/^(<%\s*\})/).test(element) === true || (/^(\[%\s*\})/).test(element) === true || (/^(\{@\s*\})/).test(element) === true) {
                        record.types = "template_end";
                    }
                    else if ((/(\{\s*%>)$/).test(element) === true || (/(\{\s*%\])$/).test(element) === true || (/(\{\s*@\})$/).test(element) === true) {
                        record.types = "template_start";
                    }
                    else if ((/\{\s*\?>$/).test(element) === true) {
                        record.types = "template_start";
                    }
                    else if ((/^<\?(=|(php))\s*\}/).test(element) === true) {
                        record.types = "template_end";
                    }
                }
                if (record.types === "template_start" || record.types === "template_else") {
                    if ((/^<\?(=|(php))\s*/).test(element) === true) {
                        tname = element;
                    }
                    else if (tname === "" || tname === "@" || tname === "#" || tname === "%") {
                        tname = tname + element.slice(1).replace(tname, "").replace(/^\s+/, "");
                        tname = tname.slice(0, tname.indexOf("(")).replace(/\s+/, "");
                    }
                }
            }
            // identify script and style hidden within a CDATA escape
            if (ltype === "cdata" && (record.stack === "script" || record.stack === "style")) {
                let counta = parse.count, countb = parse.count, stack = record.stack;
                if (data.types[countb] === "attribute") {
                    do {
                        counta = counta - 1;
                        countb = countb - 1;
                    } while (data.types[countb] === "attribute" && countb > -1);
                }
                record.begin = counta;
                element = element
                    .replace(/^(\s*<!\[cdata\[)/i, "")
                    .replace(/(\]\]>\s*)$/, "");
                record.token = "<![CDATA[";
                record.types = "cdata_start";
                recordPush(data, record, "");
                parse.structure.push(["cdata", parse.count]);
                if (stack === "script") {
                    sparser.lexers.script(element);
                }
                else {
                    sparser.lexers.style(element);
                }
                record.begin = parse.structure[parse.structure.length - 1][1];
                record.token = "]]>";
                record.types = "cdata_end";
                recordPush(data, record, "");
                parse.structure.pop();
            }
            else {
                recordPush(data, record, tname);
            }
            attributeRecord();
            // inserts a script space in anticipation of word wrap since JSX has unique white space rules
            if (options.wrap > 0 && options.language === "jsx") {
                let current_length = 0, bb = parse.count, cc = 0;
                if (data.types[bb].indexOf("attribute") > -1) {
                    do {
                        current_length = current_length + data.token[bb].length + 1;
                        bb = bb - 1;
                    } while (data.lexer[bb] !== "markup" || data.types[bb].indexOf("attribute") > -1);
                    if (data.lines[bb] === 1) {
                        current_length = current_length + data.token[bb].length + 1;
                    }
                }
                else if (data.lines[bb] === 1) {
                    current_length = data.token[bb].length + 1;
                }
                cc = bb - 1;
                if (current_length > 0 && data.types[cc] !== "script_end") {
                    if (data.types[cc].indexOf("attribute") > -1) {
                        do {
                            current_length = current_length + data.token[cc].length + 1;
                            cc = cc - 1;
                        } while (data.lexer[cc] !== "markup" || data.types[cc].indexOf("attribute") > -1);
                        if (data.lines[cc] === 1) {
                            current_length = current_length + data.token[cc].length + 1;
                        }
                    }
                    else if (data.lines[cc] === 1) {
                        current_length = data.token[cc].length + 1;
                    }
                    if (current_length > options.wrap && data.lines[bb] === 1) {
                        record.begin = data.begin[bb];
                        record.ender = bb + 2;
                        record.lexer = data.lexer[bb];
                        record.lines = 1;
                        record.stack = data.stack[bb];
                        record.token = "{";
                        record.types = "script_start";
                        parse.splice({
                            data: data,
                            howmany: 0,
                            index: bb,
                            record: record
                        });
                        record.begin = bb;
                        record.lexer = "script";
                        record.lines = 0;
                        record.stack = "script";
                        if (options.quote_convert === "single") {
                            record.token = "' '";
                        }
                        else {
                            record.token = "\" \"";
                        }
                        record.types = "string";
                        parse.splice({
                            data: data,
                            howmany: 0,
                            index: bb + 1,
                            record: record
                        });
                        record.lexer = "markup";
                        record.token = "}";
                        record.types = "script_end";
                        parse.splice({
                            data: data,
                            howmany: 0,
                            index: bb + 2,
                            record: record
                        });
                        data.ender[bb + 3] = data.ender[bb + 3] + 3;
                        bb = bb + 4;
                        do {
                            data.begin[bb] = data.begin[bb] + 3;
                            data.ender[bb] = data.ender[bb] + 3;
                            bb = bb + 1;
                        } while (bb < parse.count);
                    }
                }
            }
            //sorts child elements
            if (options.lexer_options.markup.tag_sort === true && data.types[parse.count] === "end" && data.types[parse.count - 1] !== "start" && tname !== "/script" && tname !== "/style" && tname !== "/cfscript") {
                let bb = 0, d = 0, startStore = 0, jsxatt = false, endData;
                const children = [], store = {
                    begin: [],
                    ender: [],
                    lexer: [],
                    lines: [],
                    stack: [],
                    token: [],
                    types: []
                }, storeRecord = function lexer_markup_tag_sorttag_storeRecord(index) {
                    const output = {
                        begin: data.begin[index],
                        ender: data.ender[index],
                        lexer: data.lexer[index],
                        lines: data.lines[index],
                        stack: data.stack[index],
                        token: data.token[index],
                        types: data.types[index]
                    };
                    return output;
                }, childsort = function lexer_markup_tag_sorttag_childsort(a, b) {
                    if (data.token[a[0]] > data.token[b[0]]) {
                        return -1;
                    }
                    return 1;
                };
                bb = parse.count - 1;
                if (bb > -1) {
                    let endStore = 0;
                    do {
                        if (data.types[bb] === "start") {
                            d = d - 1;
                            if (d < 0) {
                                startStore = bb + 1;
                                if (data.types[startStore] === "attribute" || data.types[startStore] === "jsx_attribute_start") {
                                    jsxatt = false;
                                    do {
                                        startStore = startStore + 1;
                                        if (jsxatt === false && data.types[startStore] !== "attribute") {
                                            break;
                                        }
                                        if (data.types[startStore] === "jsx_attribute_start") {
                                            jsxatt = true;
                                        }
                                        else if (data.types[startStore] === "jsx_attribute_end") {
                                            jsxatt = false;
                                        }
                                    } while (startStore < c);
                                }
                                break;
                            }
                        }
                        else if (data.types[bb] === "end") {
                            d = d + 1;
                            if (d === 1) {
                                endStore = bb;
                            }
                        }
                        if (d === 0) {
                            if (data.types[bb] === "start") {
                                children.push([bb, endStore]);
                            }
                            else {
                                if (data.types[bb] === "singleton" && (data.types[bb + 1] === "attribute" || data.types[bb + 1] === "jsx_attribute_start")) {
                                    let cc = bb + 1;
                                    jsxatt = false;
                                    do {
                                        if (data.types[cc] === "jsx_attribute_start") {
                                            jsxatt = true;
                                        }
                                        else if (data.types[cc] === "jsx_attribute_end") {
                                            jsxatt = false;
                                        }
                                        if (jsxatt === false && data.types[cc + 1] !== "attribute" && data.types[cc + 1] !== "jsx_attribute_start") {
                                            break;
                                        }
                                        cc = cc + 1;
                                    } while (cc < parse.count);
                                    children.push([bb, cc]);
                                }
                                else if (data.types[bb] !== "attribute" && data.types[bb] !== "jsx_attribute_start") {
                                    children.push([bb, bb]);
                                }
                            }
                        }
                        bb = bb - 1;
                    } while (bb > -1);
                }
                if (children.length < 2) {
                    return;
                }
                children.sort(childsort);
                bb = children.length - 1;
                if (bb > -1) {
                    do {
                        recordPush(store, storeRecord(children[bb][0]), "");
                        if (children[bb][0] !== children[bb][1]) {
                            d = children[bb][0] + 1;
                            if (d < children[bb][1]) {
                                do {
                                    recordPush(store, storeRecord(d), "");
                                    d = d + 1;
                                } while (d < children[bb][1]);
                            }
                            recordPush(store, storeRecord(children[bb][1]), "");
                        }
                        bb = bb - 1;
                    } while (bb > -1);
                }
                endData = {
                    begin: data.begin.pop(),
                    ender: data.ender.pop(),
                    lexer: data.lexer.pop(),
                    lines: data.lines.pop(),
                    stack: data.stack.pop(),
                    token: data.token.pop(),
                    types: data.types.pop()
                };
                (function lexer_markup_tag_sorttag_slice() {
                    parse.datanames.forEach(function lexer_markup_tag_sorttag_slice_datanames(value) {
                        data[value] = data[value].slice(0, startStore);
                    });
                }());
                parse.concat(data, store);
                count.end = count.end - 1;
                recordPush(data, endData, "");
            }
            parse.linesSpace = 0;
        }, 
        // parses everything other than markup tags
        content = function lexer_markup_content() {
            let lex = [], ltoke = "", jsxbrace = (data.token[parse.count] === "{"), liner = parse.linesSpace, now = a;
            const name = (ext === true)
                ? (jsxbrace === true)
                    ? "script"
                    : (parse.structure[parse.structure.length - 1][1] > -1)
                        ? tagName(data.token[parse.structure[parse.structure.length - 1][1]].toLowerCase())
                        : tagName(data.token[data.begin[parse.count]].toLowerCase())
                : "", square = (data.types[parse.count] === "template_start" && data.token[parse.count].indexOf("<!") === 0 && data.token[parse.count].indexOf("<![") < 0 && data.token[parse.count].charAt(data.token[parse.count].length - 1) === "["), record = {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markup",
                lines: liner,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "",
                types: "content"
            }, esctest = function lexer_markup_content_esctest() {
                let aa = a - 1, bb = 0;
                if (b[a - 1] !== "\\") {
                    return false;
                }
                if (aa > -1) {
                    do {
                        if (b[aa] !== "\\") {
                            break;
                        }
                        bb = bb + 1;
                        aa = aa - 1;
                    } while (aa > -1);
                }
                if (bb % 2 === 1) {
                    return true;
                }
                return false;
            };
            if (a < c) {
                let end = "", quote = "", quotes = 0;
                do {
                    if (b[a] === "\n") {
                        parse.lineNumber = parse.lineNumber + 1;
                    }
                    // external code requires additional parsing to look for the appropriate end
                    // tag, but that end tag cannot be quoted or commented
                    if (ext === true) {
                        if (quote === "") {
                            if (b[a] === "/") {
                                if (b[a + 1] === "*") {
                                    quote = "*";
                                }
                                else if (b[a + 1] === "/") {
                                    quote = "/";
                                }
                                else if (name === "script" && "([{!=,;.?:&<>".indexOf(b[a - 1]) > -1) {
                                    if (options.language !== "jsx" || b[a - 1] !== "<") {
                                        quote = "reg";
                                    }
                                }
                            }
                            else if ((b[a] === "\"" || b[a] === "'" || b[a] === "`") && esctest() === false) {
                                quote = b[a];
                            }
                            else if (b[a] === "{" && jsxbrace === true) {
                                quotes = quotes + 1;
                            }
                            else if (b[a] === "}" && jsxbrace === true) {
                                if (quotes === 0) {
                                    sparser.lexers.script(lex.join("").replace(/^(\s+)/, "").replace(/(\s+)$/, ""));
                                    parse.structure[parse.structure.length - 1][1] + 1;
                                    if (data.types[parse.count] === "end" && data.lexer[data.begin[parse.count] - 1] === "script") {
                                        record.lexer = "script";
                                        record.token = (options.correct === true) ? ";" : "x;";
                                        record.types = "separator";
                                        recordPush(data, record, "");
                                        record.lexer = "markup";
                                    }
                                    record.token = "}";
                                    record.types = "script_end";
                                    recordPush(data, record, "");
                                    parse.structure.pop();
                                    break;
                                }
                                quotes = quotes - 1;
                            }
                            end = b
                                .slice(a, a + 10)
                                .join("")
                                .toLowerCase();
                            //cfscript requires use of the script lexer
                            if (name === "cfscript" && end === "</cfscript") {
                                a = a - 1;
                                if (lex.length < 1) {
                                    break;
                                }
                                sparser.lexers.script(lex.join("").replace(/^(\s+)/, "").replace(/(\s+)$/, ""));
                                break;
                            }
                            //script requires use of the script lexer
                            if (name === "script") {
                                if (a === c - 9) {
                                    end = end.slice(0, end.length - 1);
                                }
                                else {
                                    end = end.slice(0, end.length - 2);
                                }
                                if (end === "</script") {
                                    let outside = lex.join("").replace(/^(\s+)/, "").replace(/(\s+)$/, "");
                                    a = a - 1;
                                    if (lex.length < 1) {
                                        break;
                                    }
                                    if ((/^(<!--+)/).test(outside) === true && (/(--+>)$/).test(outside) === true) {
                                        record.token = "<!--";
                                        record.types = "comment";
                                        recordPush(data, record, "");
                                        outside = outside.replace(/^(<!--+)/, "").replace(/(--+>)$/, "");
                                        sparser.lexers.script(outside);
                                        record.token = "-->";
                                        recordPush(data, record, "");
                                    }
                                    else {
                                        sparser.lexers.script(outside);
                                    }
                                    break;
                                }
                            }
                            //style requires use of the style lexer
                            if (name === "style") {
                                if (a === c - 8) {
                                    end = end.slice(0, end.length - 1);
                                }
                                else if (a === c - 9) {
                                    end = end.slice(0, end.length - 2);
                                }
                                else {
                                    end = end.slice(0, end.length - 3);
                                }
                                if (end === "</style") {
                                    let outside = lex.join("").replace(/^(\s+)/, "").replace(/(\s+)$/, "");
                                    a = a - 1;
                                    if (lex.length < 1) {
                                        break;
                                    }
                                    if ((/^(<!--+)/).test(outside) === true && (/(--+>)$/).test(outside) === true) {
                                        record.token = "<!--";
                                        record.types = "comment";
                                        recordPush(data, record, "");
                                        outside = outside.replace(/^(<!--+)/, "").replace(/(--+>)$/, "");
                                        sparser.lexers.style(outside);
                                        record.token = "-->";
                                        recordPush(data, record, "");
                                    }
                                    else {
                                        sparser.lexers.style(outside);
                                    }
                                    break;
                                }
                            }
                        }
                        else if (quote === b[a] && (quote === "\"" || quote === "'" || quote === "`" || (quote === "*" && b[a + 1] === "/")) && esctest() === false) {
                            quote = "";
                        }
                        else if (quote === "`" && b[a] === "$" && b[a + 1] === "{" && esctest() === false) {
                            quote = "}";
                        }
                        else if (quote === "}" && b[a] === "}" && esctest() === false) {
                            quote = "`";
                        }
                        else if (quote === "/" && (b[a] === "\n" || b[a] === "\r")) {
                            quote = "";
                        }
                        else if (quote === "reg" && b[a] === "/" && esctest() === false) {
                            quote = "";
                        }
                        else if (quote === "/" && b[a] === ">" && b[a - 1] === "-" && b[a - 2] === "-") {
                            end = b
                                .slice(a + 1, a + 11)
                                .join("")
                                .toLowerCase();
                            if (name === "cfscript" && end === "</cfscript") {
                                quote = "";
                            }
                            end = end.slice(0, end.length - 2);
                            if (name === "script" && end === "</script") {
                                quote = "";
                            }
                            end = end.slice(0, end.length - 1);
                            if (name === "style" && end === "</style") {
                                quote = "";
                            }
                        }
                    }
                    //typically this logic is for artifacts nested within an SGML tag
                    if (square === true && b[a] === "]") {
                        a = a - 1;
                        ltoke = lex.join("");
                        if (options.lexer_options.markup.parse_space === false) {
                            ltoke = ltoke.replace(/\s+$/, "");
                        }
                        liner = 0;
                        record.token = ltoke;
                        recordPush(data, record, "");
                        break;
                    }
                    //general content processing
                    if (ext === false && lex.length > 0 && ((b[a] === "<" && b[a + 1] !== "=" && (/\s|\d/).test(b[a + 1]) === false) || (b[a] === "[" && b[a + 1] === "%") || (b[a] === "{" && (options.language === "jsx" || options.language === "dustjs" || b[a + 1] === "{" || b[a + 1] === "%" || b[a + 1] === "@" || b[a + 1] === "#")))) {
                        //dustjs template handling
                        if (options.language === "dustjs" && b[a] === "{" && b[a + 1] === ":" && b[a + 2] === "e" && b[a + 3] === "l" && b[a + 4] === "s" && b[a + 5] === "e" && b[a + 6] === "}") {
                            a = a + 6;
                            ltoke = lex.join("");
                            if (options.lexer_options.markup.parse_space === false) {
                                ltoke = ltoke.replace(/\s+$/, "");
                            }
                            liner = 0;
                            record.token = ltoke;
                            recordPush(data, record, "");
                            record.token = "{:else}";
                            record.types = "template_else";
                            recordPush(data, record, "");
                            break;
                        }
                        //regular content
                        a = a - 1;
                        if (options.lexer_options.markup.parse_space === true || parse.structure[parse.structure.length - 1][0] === "comment") {
                            ltoke = lex.join("");
                        }
                        else {
                            ltoke = lex.join("").replace(/\s+$/, "");
                        }
                        ltoke = bracketSpace(ltoke);
                        liner = 0;
                        record.token = ltoke;
                        if (options.wrap > 0 && options.lexer_options.markup.preserve_text !== true) {
                            let aa = options.wrap, len = ltoke.length, startSpace = "", endSpace = "";
                            const wrap = options.wrap, store = [], wrapper = function beautify_markup_apply_content_wrapper() {
                                if (ltoke.charAt(aa) === " ") {
                                    store.push(ltoke.slice(0, aa));
                                    ltoke = ltoke.slice(aa + 1);
                                    len = ltoke.length;
                                    aa = wrap;
                                    return;
                                }
                                do {
                                    aa = aa - 1;
                                } while (aa > 0 && ltoke.charAt(aa) !== " ");
                                if (aa > 0) {
                                    store.push(ltoke.slice(0, aa));
                                    ltoke = ltoke.slice(aa + 1);
                                    len = ltoke.length;
                                    aa = wrap;
                                }
                                else {
                                    aa = wrap;
                                    do {
                                        aa = aa + 1;
                                    } while (aa < len && ltoke.charAt(aa) !== " ");
                                    store.push(ltoke.slice(0, aa));
                                    ltoke = ltoke.slice(aa + 1);
                                    len = ltoke.length;
                                    aa = wrap;
                                }
                            };
                            // HTML anchor lists do not get wrapping unless the content itself exceeds the wrapping limit
                            if (data.token[data.begin[parse.count]] === "<a>" &&
                                data.token[data.begin[data.begin[parse.count]]] === "<li>" &&
                                data.lines[data.begin[parse.count]] === 0 &&
                                parse.linesSpace === 0 &&
                                ltoke.length < options.wrap) {
                                recordPush(data, record, "");
                                break;
                            }
                            if (len < wrap) {
                                recordPush(data, record, "");
                                break;
                            }
                            if (parse.linesSpace < 1) {
                                let bb = parse.count;
                                do {
                                    aa = aa - data.token[bb].length;
                                    if (data.types[bb].indexOf("attribute") > -1) {
                                        aa = aa - 1;
                                    }
                                    if (data.lines[bb] > 0 && data.types[bb].indexOf("attribute") < 0) {
                                        break;
                                    }
                                    bb = bb - 1;
                                } while (bb > 0 && aa > 0);
                                if (aa < 1) {
                                    aa = ltoke.indexOf(" ");
                                }
                            }
                            ltoke = lex.join("");
                            if (options.lexer_options.markup.parse_space === true) {
                                startSpace = ((/\s/).test(ltoke.charAt(0)) === true)
                                    ? (/\s+/).exec(ltoke)[0]
                                    : "";
                                endSpace = ((/\s/).test(ltoke.charAt(ltoke.length - 1)) === true)
                                    ? (/\s+$/).exec(ltoke)[0]
                                    : "";
                            }
                            ltoke = ltoke.replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ");
                            do {
                                wrapper();
                            } while (aa < len);
                            if (ltoke !== "" && ltoke !== " ") {
                                store.push(ltoke);
                            }
                            if (options.crlf === true) {
                                ltoke = store.join("\r\n");
                            }
                            else {
                                ltoke = store.join("\n");
                            }
                            ltoke = startSpace + ltoke + endSpace;
                        }
                        liner = 0;
                        record.token = ltoke;
                        recordPush(data, record, "");
                        break;
                    }
                    lex.push(b[a]);
                    a = a + 1;
                } while (a < c);
            }
            if (options.lexer_options.markup.parse_space === false) {
                if (a > now && a < c) {
                    if ((/\s/).test(b[a]) === true) {
                        let x = a;
                        parse.linesSpace = 1;
                        do {
                            if (b[x] === "\n") {
                                parse.linesSpace = parse.linesSpace + 1;
                            }
                            x = x - 1;
                        } while (x > now && (/\s/).test(b[x]) === true);
                    }
                    else {
                        parse.linesSpace = 0;
                    }
                }
                else if (a !== now || (a === now && ext === false)) {
                    //regular content at the end of the supplied source
                    ltoke = lex.join("").replace(/\s+$/, "");
                    liner = 0;
                    //this condition prevents adding content that was just added in the loop above
                    if (record.token !== ltoke) {
                        record.token = ltoke;
                        recordPush(data, record, "");
                        parse.linesSpace = 0;
                    }
                }
            }
            ext = false;
        };
        // trim the attribute_sort_list values
        if (asl > 0) {
            do {
                attribute_sort_list[a] = attribute_sort_list[a].replace(/^\s+/, "").replace(/\s+$/, "");
                a = a + 1;
            } while (a < asl);
            a = 0;
        }
        if (options.language === "html") {
            html = "html";
        }
        else if (options.language === "xml" || options.language === "sgml") {
            html = "xml";
        }
        do {
            if ((/\s/).test(b[a]) === true) {
                if (options.lexer_options.markup.parse_space === true || (data.types[parse.count] === "template_start" && parse.structure[parse.structure.length - 1][0] === "comment")) {
                    content();
                }
                else {
                    a = parse.spacer({ array: b, end: c, index: a });
                }
            }
            else if (ext) {
                content();
            }
            else if (b[a] === "<") {
                tag("");
            }
            else if (b[a] === "[" && b[a + 1] === "%") {
                tag("%]");
            }
            else if (b[a] === "{" && (options.language === "jsx" || options.language === "dustjs" || b[a + 1] === "{" || b[a + 1] === "%" || b[a + 1] === "@" || b[a + 1] === "#")) {
                tag("");
            }
            else if (b[a] === "]" && sgmlflag > 0) {
                tag("]>");
            }
            else if (options.language === "vapor") {
                if (b[a] === "#") {
                    tag(")");
                }
                else if (b[a] === "{" && data.token[parse.count].charAt(0) === "#") {
                    vaporStart();
                }
                else if (b[a] === "}") {
                    vaporEnd();
                }
                else {
                    content();
                }
            }
            else if (options.language === "jekyll" && b[a] === "-" && b[a + 1] === "-" && b[a + 2] === "-") {
                tag("---");
            }
            else if (options.language === "apacheVelocity" && (/\d/).test(b[a + 1]) === false && (/\s/).test(b[a + 1]) === false) {
                if (b[a] === "#" && ((/\w/).test(b[a + 1]) === true || b[a + 1] === "*" || b[a + 1] === "#" || (b[a + 1] === "[" && b[a + 2] === "["))) {
                    tag("");
                }
                else if (b[a] === "$" && b[a + 1] !== "$" && b[a + 1] !== "=" && b[a + 1] !== "[") {
                    tag("");
                }
                else {
                    content();
                }
            }
            else {
                content();
            }
            a = a + 1;
        } while (a < c);
        if (data.token[parse.count].charAt(0) !== "/" && htmlblocks[parse.structure[parse.structure.length - 1][0]] === "block") {
            fixHtmlEnd(data.token[parse.count], true);
        }
        if (count.end !== count.start && sparser.parseerror === "") {
            if (count.end > count.start) {
                let x = count.end - count.start, plural = (x === 1)
                    ? ""
                    : "s";
                sparser.parseerror = `${x} more end type${plural} than start types.`;
            }
            else {
                let x = count.start - count.end, plural = (x === 1)
                    ? ""
                    : "s";
                sparser.parseerror = `${x} more start type${plural} than end types.`;
            }
        }
        return data;
    };
    sparser.lexers.markup = markup;
}());

(function minify_style_init() {
    const style = function minify_style(options) {
        const data = options.parsed, lf = (options.crlf === true)
            ? "\r\n"
            : "\n", len = (prettydiff.end < 1 || prettydiff.end > data.token.length)
            ? data.token.length
            : prettydiff.end + 1, build = [];
        let a = prettydiff.start, b = 0, c = 0, list = [], count = 0, countx = 0;
        //beautification loop
        if (options.top_comments === true && options.minify_keep_comments === false && data.types[a] === "comment" && prettydiff.start === 0) {
            if (a > 0) {
                build.push(lf);
            }
            do {
                build.push(data.token[a]);
                build.push(lf);
                a = a + 1;
            } while (a < len && data.types[a] === "comment");
        }
        if (a < len) {
            do {
                if (data.types[a] === "comment" && options.minify_keep_comments === true) {
                    if (data.types[a - 1] !== "comment" && a > 0) {
                        build.push(lf);
                        build.push(lf);
                    }
                    build.push(data.token[a]);
                    if (data.types[a + 1] !== "comment") {
                        build.push(lf);
                    }
                    build.push(lf);
                }
                else if (data.types[a] !== "comment") {
                    build.push(data.token[a]);
                    if (options.wrap > 0 && options.minify_wrap === true) {
                        count = count + data.token[a].length;
                        if (a < len - 1) {
                            if (count + data.token[a + 1].length > options.wrap) {
                                countx = count;
                                count = 0;
                                if (data.types[a] === "property") {
                                    build.pop();
                                    a = a - 1;
                                }
                                else if (data.token[a] === ":") {
                                    build.pop();
                                    build.pop();
                                    a = a - 2;
                                }
                                build.push(lf);
                            }
                            b = data.token[a + 1].indexOf(",");
                            if ((data.token[a + 1].length > options.wrap || (b > 0 && countx + b < options.wrap)) && data.types[a + 1] === "selector") {
                                list = data.token[a + 1].split(",");
                                b = 0;
                                c = list.length;
                                if (countx + list[0].length + 1 < options.wrap) {
                                    build.pop();
                                    do {
                                        countx = countx + list[b].length + 1;
                                        if (countx > options.wrap) {
                                            break;
                                        }
                                        build.push(list[b]);
                                        build.push(",");
                                        b = b + 1;
                                    } while (b < c);
                                }
                                else {
                                    countx = 0;
                                }
                                if (b < c) {
                                    do {
                                        countx = countx + list[b].length + 1;
                                        if (countx > options.wrap) {
                                            countx = list[b].length + 1;
                                            build.push(lf);
                                        }
                                        build.push(list[b]);
                                        build.push(",");
                                        b = b + 1;
                                    } while (b < c);
                                    build.pop();
                                }
                                count = countx;
                                countx = 0;
                                a = a + 1;
                            }
                        }
                    }
                }
                a = a + 1;
            } while (a < len);
            prettydiff.iterator = len - 1;
        }
        if (options.new_line === true && a === data.token.length && build[build.length - 1].indexOf(lf) < 0) {
            build.push(lf);
        }
        return build.join("");
    };
    prettydiff.minify.style = style;
}());

(function minify_script_init() {
    const script = function minify_script(options) {
        (function minify_script_options() {
            if (options.language === "json") {
                options.wrap = 0;
            }
            else if (options.language === "titanium") {
                options.correct = false;
            }
        }());
        const data = options.parsed, lf = (options.crlf === true)
            ? "\r\n"
            : "\n", lexer = "script", invisibles = ["x;", "x}", "x{", "x(", "x)"], end = (prettydiff.end < 1 || prettydiff.end > data.token.length)
            ? data.token.length
            : prettydiff.end + 1, build = [], lastsemi = function minify_script_lastsemi() {
            let aa = a, bb = 0;
            do {
                if (data.types[aa] === "end") {
                    bb = bb + 1;
                }
                else if (data.types[aa] === "start") {
                    bb = bb - 1;
                }
                if (bb < 0) {
                    if (data.token[aa - 1] === "for") {
                        build.push(";");
                        count = count + 1;
                    }
                    return;
                }
                aa = aa - 1;
            } while (aa > -1);
        };
        let a = prettydiff.start, count = 0, external = "";
        if (options.top_comments === true && options.minify_keep_comments === false && data.types[a] === "comment" && prettydiff.start === 0) {
            if (a > 0) {
                build.push(lf);
            }
            do {
                build.push(data.token[a]);
                build.push(lf);
                a = a + 1;
            } while (a < end && data.types[a] === "comment");
        }
        do {
            if (data.lexer[a] === lexer || prettydiff.minify[data.lexer[a]] === undefined) {
                if (data.types[a] === "comment" && options.minify_keep_comments === true) {
                    if (data.types[a - 1] !== "comment" && a > 0) {
                        build.push(lf);
                        build.push(lf);
                    }
                    build.push(data.token[a]);
                    if (data.types[a + 1] !== "comment") {
                        build.push(lf);
                    }
                    build.push(lf);
                }
                else if (data.types[a] !== "comment") {
                    if (data.types[a - 1] === "operator" && data.types[a] === "operator" && data.token[a] !== "!") {
                        build.push(" ");
                        count = count + 1;
                    }
                    if ((data.types[a] === "word" || data.types[a] === "references") && (data.types[a + 1] === "word" ||
                        data.types[a + 1] === "reference" ||
                        data.types[a + 1] === "literal" ||
                        data.types[a + 1] === "number" ||
                        data.token[a + 1] === "x{")) {
                        if (data.types[a - 1] === "literal" &&
                            data.token[a - 1].charAt(0) !== "\"" &&
                            data.token[a - 1].charAt(0) !== "'") {
                            build.push(" ");
                            count = count + 1;
                        }
                        build.push(data.token[a]);
                        build.push(" ");
                        count = count + data.token[a].length + 1;
                    }
                    else if (data.token[a] === "x;" && data.token[a + 1] !== "}") {
                        build.push(";");
                        count = count + 1;
                    }
                    else if (data.token[a] === ";" && data.token[a + 1] === "}") {
                        lastsemi();
                    }
                    else if (invisibles.indexOf(data.token[a]) < 0) {
                        build.push(data.token[a]);
                        count = count + data.token[a].length;
                    }
                }
                if (a < end - 1 && count + data.token[a + 1].length > options.wrap && options.wrap > 0 && options.minify_wrap === true) {
                    if (build[build.length - 1] === " ") {
                        build.pop();
                    }
                    if (data.token[a + 1] === ";") {
                        build.pop();
                        build.push(lf);
                        build.push(data.token[a]);
                    }
                    else {
                        build.push(lf);
                    }
                    count = 0;
                }
            }
            else {
                let skip = a, quit = false;
                do {
                    if (data.lexer[a + 1] === lexer && data.begin[a + 1] < skip) {
                        break;
                    }
                    if (data.token[skip - 1] === "return" && data.types[a] === "end" && data.begin[a] === skip) {
                        break;
                    }
                    a = a + 1;
                } while (a < end);
                prettydiff.start = skip;
                prettydiff.end = a;
                if (a > end - 1) {
                    a = skip;
                    quit = true;
                    prettydiff.end = end - 2;
                }
                external = prettydiff.minify[data.lexer[a]](options).replace(/\s+$/, "");
                if (options.wrap > 0 && options.minify_wrap === true && data.token[skip - 1] !== "return") {
                    build.push(lf);
                }
                build.push(external);
                if (quit === true) {
                    break;
                }
                if (options.wrap > 0 && options.minify_wrap === true) {
                    build.push(lf);
                    count = 0;
                }
            }
            a = a + 1;
        } while (a < end);
        prettydiff.iterator = end - 1;
        if (options.new_line === true && a === data.token.length && build[build.length - 1].indexOf(lf) < 0) {
            build.push(lf);
        }
        return build.join("");
    };
    prettydiff.minify.script = script;
}());

(function beautify_style_init() {
    const style = function beautify_style(options) {
        const data = options.parsed, lf = (options.crlf === true)
            ? "\r\n"
            : "\n", len = (prettydiff.end > 0)
            ? prettydiff.end + 1
            : data.token.length, build = [], 
        //a single unit of indentation
        tab = (function beautify_style_tab() {
            let aa = 0, bb = [];
            do {
                bb.push(options.indent_char);
                aa = aa + 1;
            } while (aa < options.indent_size);
            return bb.join("");
        }()), pres = options.preserve + 1, 
        //new lines plus indentation
        nl = function beautify_style_nl(tabs) {
            const linesout = [], total = (function beautify_style_nl_total() {
                if (a === len - 1) {
                    return 1;
                }
                if (data.lines[a + 1] - 1 > pres) {
                    return pres;
                }
                if (data.lines[a + 1] > 1) {
                    return data.lines[a + 1] - 1;
                }
                return 1;
            }());
            let index = 0;
            if (tabs < 0) {
                tabs = 0;
            }
            do {
                linesout.push(lf);
                index = index + 1;
            } while (index < total);
            if (tabs > 0) {
                index = 0;
                do {
                    linesout.push(tab);
                    index = index + 1;
                } while (index < tabs);
            }
            build.push(linesout.join(""));
        }, vertical = function beautify_style_vertical() {
            const start = data.begin[a], startChar = data.token[start], endChar = data.token[a], store = [];
            let b = a, c = 0, item, longest = 0;
            if (start < 0 || b <= start) {
                return;
            }
            do {
                b = b - 1;
                if (data.begin[b] === start) {
                    if (data.token[b] === ":") {
                        item = [b - 1, 0];
                        do {
                            b = b - 1;
                            if ((((data.token[b] === ";" && startChar === "{") || (data.token[b] === "," && startChar === "(")) && data.begin[b] === start) || (data.token[b] === endChar && data.begin[data.begin[b]] === start)) {
                                break;
                            }
                            if (data.types[b] !== "comment" && data.types[b] !== "selector" && data.token[b] !== startChar && data.begin[b] === start) {
                                item[1] = data.token[b].length + item[1];
                            }
                        } while (b > start + 1);
                        if (item[1] > longest) {
                            longest = item[1];
                        }
                        store.push(item);
                    }
                }
                else if (data.types[b] === "end") {
                    if (b < data.begin[b]) {
                        break;
                    }
                    b = data.begin[b];
                }
            } while (b > start);
            b = store.length;
            if (b < 2) {
                return;
            }
            do {
                b = b - 1;
                if (store[b][1] < longest) {
                    c = store[b][1];
                    do {
                        data.token[store[b][0]] = data.token[store[b][0]] + " ";
                        c = c + 1;
                    } while (c < longest);
                }
            } while (b > 0);
        };
        let indent = options.indent_level, a = prettydiff.start, when = ["", ""];
        if (options.vertical === true && options.compressed_css === false) {
            a = len;
            do {
                a = a - 1;
                if (data.token[a] === "}" || data.token[a] === ")") {
                    vertical();
                }
            } while (a > 0);
            a = prettydiff.start;
        }
        //beautification loop
        do {
            if (data.types[a + 1] === "end" || data.types[a + 1] === "template_end" || data.types[a + 1] === "template_else") {
                indent = indent - 1;
            }
            if (data.types[a] === "template" && data.lines[a] > 0) {
                build.push(data.token[a]);
                nl(indent);
            }
            else if (data.types[a] === "template_else") {
                build.push(data.token[a]);
                indent = indent + 1;
                nl(indent);
            }
            else if (data.types[a] === "start" || data.types[a] === "template_start") {
                indent = indent + 1;
                build.push(data.token[a]);
                if (data.types[a + 1] !== "end" && data.types[a + 1] !== "template_end" && (options.compressed_css === false || (options.compressed_css === true && data.types[a + 1] === "selector"))) {
                    nl(indent);
                }
            }
            else if ((data.token[a] === ";" && (options.compressed_css === false || (options.compressed_css === true && data.types[a + 1] === "selector"))) || data.types[a] === "end" || data.types[a] === "template_end" || data.types[a] === "comment") {
                build.push(data.token[a]);
                if (data.types[a + 1] === "value") {
                    if (data.lines[a + 1] === 1) {
                        build.push(" ");
                    }
                    else if (data.lines[a + 1] > 1) {
                        nl(indent);
                    }
                }
                else if (data.types[a + 1] !== "separator") {
                    if (data.types[a + 1] !== "comment" || (data.types[a + 1] === "comment" && data.lines[a + 1] > 1)) {
                        nl(indent);
                    }
                    else {
                        build.push(" ");
                    }
                }
            }
            else if (data.token[a] === ":") {
                build.push(data.token[a]);
                if (options.compressed_css === false) {
                    build.push(" ");
                }
            }
            else if (data.types[a] === "selector") {
                if (options.css_insert_lines === true && data.types[a - 1] === "end" && data.lines[a] < 3) {
                    build.push(lf);
                }
                if (data.token[a].indexOf("when(") > 0) {
                    when = data.token[a].split("when(");
                    build.push(when[0].replace(/\s+$/, ""));
                    nl(indent + 1);
                    build.push(`when (${when[1]}`);
                }
                else {
                    build.push(data.token[a]);
                }
                if (data.types[a + 1] === "start") {
                    if (options.braces === true) {
                        nl(indent);
                    }
                    else if (options.compressed_css === false) {
                        build.push(" ");
                    }
                }
            }
            else if (data.token[a] === ",") {
                build.push(data.token[a]);
                if (data.types[a + 1] === "selector" || data.types[a + 1] === "property") {
                    nl(indent);
                }
                else if (options.compressed_css === false) {
                    build.push(" ");
                }
            }
            else if (data.stack[a] === "map" && data.token[a + 1] === ")" && a - data.begin[a] > 5) {
                build.push(data.token[a]);
                nl(indent);
            }
            else if (data.token[a] === "x;") {
                nl(indent);
            }
            else if ((data.types[a] === "variable" || data.types[a] === "function") && options.css_insert_lines === true && data.types[a - 1] === "end" && data.lines[a] < 3) {
                build.push(lf);
                build.push(data.token[a]);
            }
            else if (data.token[a] !== ";" || (data.token[a] === ";" && (options.compressed_css === false || (options.compressed_css === true && data.token[a + 1] !== "}")))) {
                build.push(data.token[a]);
            }
            a = a + 1;
        } while (a < len);
        prettydiff.iterator = len - 1;
        return build.join("");
    };
    prettydiff.beautify.style = style;
}());

(function minify_markup_init() {
    const markup = function minify_markup(options) {
        const data = options.parsed, lexer = "markup", c = (prettydiff.end < 1 || prettydiff.end > data.token.length)
            ? data.token.length
            : prettydiff.end + 1, lf = (options.crlf === true)
            ? "\r\n"
            : "\n", externalIndex = {}, levels = (function minify_markup_levels() {
            const level = (prettydiff.start > 0)
                ? Array(prettydiff.start).fill(0, 0, prettydiff.start)
                : [], nextIndex = function minify_markup_levels_next() {
                let x = a + 1, y = 0;
                if (data.types[x] === "comment" || data.types[x] === "attribute" || data.types[x] === "jsx_attribute_start") {
                    do {
                        if (data.types[x] === "jsx_attribute_start") {
                            y = x;
                            do {
                                if (data.types[x] === "jsx_attribute_end" && data.begin[x] === y) {
                                    break;
                                }
                                x = x + 1;
                            } while (x < c);
                        }
                        else if (data.types[x] !== "comment" && data.types[x] !== "attribute") {
                            return x;
                        }
                        x = x + 1;
                    } while (x < c);
                }
                return x;
            }, external = function minify_markup_levels_external() {
                let skip = a;
                do {
                    if (data.lexer[a + 1] === lexer && data.begin[a + 1] < skip && data.types[a + 1] !== "start" && data.types[a + 1] !== "singleton") {
                        break;
                    }
                    level.push(-20);
                    a = a + 1;
                } while (a < c);
                externalIndex[skip] = a;
                level.push(-20);
                next = nextIndex();
            }, comment = function minify_markup_levels_comment() {
                let x = a, test = false;
                if (data.lines[a + 1] === 0) {
                    do {
                        if (data.lines[x] > 0) {
                            test = true;
                            break;
                        }
                        x = x - 1;
                    } while (x > comstart);
                    x = a;
                }
                else {
                    test = true;
                }
                do {
                    level.push(-20);
                    x = x - 1;
                } while (x > comstart);
                if (test === true) {
                    if (data.types[x] === "attribute" || data.types[x] === "jsx_attribute_start") {
                        level[data.begin[x]] = -10;
                    }
                    else {
                        level[x] = -10;
                    }
                }
                else {
                    level[x] = -20;
                }
                comstart = -1;
            };
            let a = prettydiff.start, next = 0, comstart = -1;
            // data.lines -> space before token
            // level -> space after token
            do {
                if (data.lexer[a] === lexer) {
                    if (data.types[a].indexOf("attribute") > -1) {
                        if (data.types[a] === "attribute") {
                            data.token[a] = data.token[a].replace(/\s+/g, " ");
                        }
                        if (data.types[a - 1].indexOf("attribute") < 0) {
                            level[a - 1] = -10;
                        }
                        if (data.types[a] === "comment_attribute" && data.token[a].slice(0, 2) === "//") {
                            level.push(-10);
                        }
                        else if (data.types[a] === "jsx_attribute_start") {
                            level.push(-20);
                        }
                        else if (data.types[a] === "jsx_attribute_end") {
                            level.push(-10);
                        }
                        else if (a < c - 1 && data.types[a + 1].indexOf("attribute") < 0) {
                            if (data.lines[a + 1] > 0 && data.lexer[a + 1] === lexer && data.types[a + 1] !== "start" && data.types[a + 1] !== "xml" && data.types[a + 1] !== "sgml") {
                                level.push(-10);
                            }
                            else {
                                level.push(-20);
                            }
                        }
                        else {
                            level.push(-10);
                        }
                    }
                    else if (data.types[a] === "comment") {
                        if (options.minify_keep_comments === true) {
                            level.push(0);
                        }
                        else {
                            if (comstart < 0) {
                                comstart = a;
                            }
                            if (data.types[a + 1] !== "comment") {
                                comment();
                            }
                        }
                    }
                    else if (data.types[a] !== "comment") {
                        if (data.types[a] === "content") {
                            data.token[a] = data.token[a].replace(/\s+/g, " ");
                        }
                        next = nextIndex();
                        if (data.lines[next] > 0 && (data.types[a] === "content" ||
                            data.types[a] === "singleton" ||
                            data.types[next] === "content" ||
                            data.types[next] === "singleton" ||
                            (data.types[next] !== undefined && data.types[next].indexOf("attribute") > 0))) {
                            level.push(-10);
                        }
                        else {
                            level.push(-20);
                        }
                    }
                }
                else {
                    external();
                }
                a = a + 1;
            } while (a < c);
            return level;
        }());
        return (function minify_markup_apply() {
            const build = [], 
            // a new line character plus the correct amount of identation for the given line
            // of code
            attributeEnd = function minify_markup_apply_attributeEnd() {
                const parent = data.token[a], regend = (/(\/|\?)?>$/), end = regend.exec(parent);
                let y = a + 1, x = 0, jsx = false;
                if (end === null) {
                    return;
                }
                data.token[a] = parent.replace(regend, "");
                do {
                    if (data.types[y] === "jsx_attribute_end" && data.begin[data.begin[y]] === a) {
                        jsx = false;
                    }
                    else if (data.begin[y] === a) {
                        if (data.types[y] === "jsx_attribute_start") {
                            jsx = true;
                        }
                        else if (data.types[y].indexOf("attribute") < 0 && jsx === false) {
                            break;
                        }
                    }
                    else if (jsx === false && (data.begin[y] < a || data.types[y].indexOf("attribute") < 0)) {
                        break;
                    }
                    y = y + 1;
                } while (y < c);
                if (data.types[y - 1] === "comment_attribute") {
                    x = y;
                    do {
                        y = y - 1;
                    } while (y > a && data.types[y - 1] === "comment_attribute");
                    if (data.lines[x] < 1) {
                        levels[y - 1] = -20;
                    }
                }
                data.token[y - 1] = data.token[y - 1] + end[0];
            };
            let a = prettydiff.start, b = 0, next = 0, external = "", lastLevel = 0, count = 0, linelen = 0, lines = [];
            if (options.top_comments === true && data.types[a] === "comment" && prettydiff.start === 0) {
                if (a > 0) {
                    build.push(lf);
                }
                do {
                    build.push(data.token[a]);
                    build.push(lf);
                    a = a + 1;
                } while (a < c && data.types[a] === "comment");
            }
            do {
                if (data.lexer[a] === lexer || prettydiff.minify[data.lexer[a]] === undefined) {
                    if ((data.types[a] === "start" || data.types[a] === "singleton" || data.types[a] === "xml" || data.types[a] === "sgml") && data.types[a].indexOf("attribute") < 0 && a < c - 1 && data.types[a + 1] !== undefined && data.types[a + 1].indexOf("attribute") > -1) {
                        attributeEnd();
                    }
                    if (options.minify_keep_comments === true || (data.types[a] !== "comment" && data.types[a] !== "comment_attribute")) {
                        if (data.types[a] === "comment") {
                            if (data.types[a - 1] !== "comment") {
                                build.push(lf);
                                build.push(lf);
                            }
                            build.push(data.token[a]);
                            if (data.types[a + 1] !== "comment") {
                                build.push(lf);
                            }
                            build.push(lf);
                        }
                        else {
                            build.push(data.token[a]);
                        }
                        count = count + data.token[a].length;
                        if ((data.types[a] === "template" || data.types[a] === "template_start") && data.types[a - 1] === "content" && options.mode === "minify" && levels[a] === -20) {
                            build.push(" ");
                            count = count + 1;
                        }
                        if (levels[a] > -1) {
                            lastLevel = levels[a];
                        }
                        else if (levels[a] === -10 && data.types[a] !== "jsx_attribute_start") {
                            build.push(" ");
                            count = count + 1;
                        }
                    }
                    next = a + 1;
                    if (next < c - 1 && data.types[next].indexOf("comment") > -1 && options.minify_keep_comments === false) {
                        do {
                            next = next + 1;
                        } while (next < c - 1 && data.types[next].indexOf("comment") > -1);
                    }
                    if (next < c - 1 && count + data.token[next].length > options.wrap && options.wrap > 0 && options.minify_wrap === true) {
                        if (build[build.length - 1] === " ") {
                            build.pop();
                        }
                        if ((data.types[next] === "content" || data.types[next] === "attribute") && data.token[next].indexOf(" ") > 0) {
                            lines = data.token[next].split(" ");
                            b = 0;
                            linelen = lines.length;
                            if (count + lines[0] + 1 > options.wrap) {
                                build.push(lf);
                                count = 0;
                            }
                            do {
                                count = count + lines[b].length + 1;
                                if (count > options.wrap) {
                                    count = lines[b].length + 1;
                                    build.push(lf);
                                }
                                build.push(lines[b]);
                                build.push(" ");
                                b = b + 1;
                            } while (b < linelen);
                            if (next < c - 2 && count + data.token[next + 1].length > options.wrap) {
                                if (build[build.length - 1] === " ") {
                                    build.pop();
                                }
                                build.push(lf);
                                count = 0;
                            }
                            a = next;
                        }
                        else {
                            build.push(lf);
                            count = 0;
                        }
                    }
                }
                else {
                    if (externalIndex[a] === a && data.types[a] !== "reference") {
                        if (data.types[a] !== "comment") {
                            build.push(data.token[a]);
                            count = count + data.token[a].length;
                        }
                    }
                    else {
                        prettydiff.end = externalIndex[a];
                        options.indent_level = lastLevel;
                        prettydiff.start = a;
                        external = prettydiff.minify[data.lexer[a]](options).replace(/\s+$/, "");
                        if (options.wrap > 0 && options.minify_wrap === true) {
                            build.push(lf);
                        }
                        build.push(external);
                        if (levels[prettydiff.iterator] > -1 && externalIndex[a] > a) {
                            build.push(lf);
                        }
                        else if (options.wrap > 0 && options.minify_wrap === true) {
                            build.push(lf);
                        }
                        a = prettydiff.iterator;
                    }
                }
                a = a + 1;
            } while (a < c);
            prettydiff.iterator = c - 1;
            if (build[0] === lf || build[0] === " ") {
                build[0] = "";
            }
            if (options.new_line === true && a === data.token.length && build[build.length - 1].indexOf(lf) < 0) {
                build.push(lf);
            }
            return build.join("");
        }());
    };
    prettydiff.minify.markup = markup;
}());
(function options_init() {
    const optionDef = {
        attribute_sort: {
            api: "any",
            default: false,
            definition: "Alphanumerically sort markup attributes. Attribute sorting is ignored on tags that contain attributes template attributes.",
            label: "Sort Attributes",
            lexer: "markup",
            mode: "any",
            type: "boolean"
        },
        attribute_sort_list: {
            api: "any",
            default: "",
            definition: "A comma separated list of attribute names. Attributes will be sorted according to this list and then alphanumerically. This option requires 'attribute_sort' have a value of true.",
            label: "Sort Attribute List",
            lexer: "markup",
            mode: "any",
            type: "string"
        },
        brace_line: {
            api: "any",
            default: false,
            definition: "If true an empty line will be inserted after opening curly braces and before clo" +
                "sing curly braces.",
            label: "Brace Lines",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        brace_padding: {
            api: "any",
            default: false,
            definition: "Inserts a space after the start of a container and before the end of the contain" +
                "er if the contents of that container are not indented; such as: conditions, func" +
                "tion arguments, and escaped sequences of template strings.",
            label: "Brace Padding",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        brace_style: {
            api: "any",
            default: "none",
            definition: "Emulates JSBeautify's brace_style option using existing Pretty Diff options.",
            label: "Brace Style",
            lexer: "script",
            mode: "beautify",
            type: "string",
            values: {
                "collapse": "Sets options.format_object to 'indent' and options.neverflatten to true.",
                "collapse-preserve-inline": "Sets options.bracepadding to true and options.format_object to 'inline'.",
                "expand": "Sets options.braces to true, options.format_object to 'indent', and options.never" +
                    "flatten to true.",
                "none": "Ignores this option"
            }
        },
        braces: {
            api: "any",
            default: false,
            definition: "Determines if opening curly braces will exist on the same line as their conditio" +
                "n or be forced onto a new line. (Allman style indentation).",
            label: "Style of Indent",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        case_space: {
            api: "any",
            default: false,
            definition: "If the colon separating a case's expression (of a switch/case block) from its statement should be followed by a space instead of indentation, thereby keeping the case on a single line of code.",
            label: "Space Following Case",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        color: {
            api: "any",
            default: "white",
            definition: "The color scheme of the reports.",
            label: "Color",
            lexer: "any",
            mode: "any",
            type: "string",
            values: {
                "canvas": "A light brown color scheme",
                "shadow": "A black and ashen color scheme",
                "white": "A white and pale grey color scheme"
            }
        },
        comment_line: {
            api: "any",
            default: false,
            definition: "If a blank new line should be forced above comments.",
            label: "Force an Empty Line Above Comments",
            lexer: "markup",
            mode: "beautify",
            type: "boolean"
        },
        comments: {
            api: "any",
            default: false,
            definition: "This will determine whether comments should always start at position 0 of each l" +
                "ine or if comments should be indented according to the code.",
            label: "Indent Comments",
            lexer: "any",
            mode: "beautify",
            type: "boolean"
        },
        complete_document: {
            api: "any",
            default: false,
            definition: "Allows a preference for generating a complete HTML document instead of only gene" +
                "rating content.",
            label: "Generate A Complete HTML File",
            lexer: "markup",
            mode: "any",
            type: "boolean"
        },
        compressed_css: {
            api: "any",
            default: false,
            definition: "If CSS should be beautified in a style where the properties and values are minif" +
                "ed for faster reading of selectors.",
            label: "Compressed CSS",
            lexer: "style",
            mode: "beautify",
            type: "boolean"
        },
        conditional: {
            api: "any",
            default: false,
            definition: "If true then conditional comments used by Internet Explorer are preserved at min" +
                "ification of markup.",
            label: "IE Comments (HTML Only)",
            lexer: "markup",
            mode: "minify",
            type: "boolean"
        },
        config: {
            api: "node",
            default: "",
            definition: "By default Pretty Diff will look into the directory structure contain the value of option 'source' for a file named `.prettydiffrc` for saved option settings. This option allows a user to specify any file at any location in the local file system for configuration settings. A value of 'none' tells the application to bypass reading any configuration file.",
            label: "Custom Config File Location",
            lexer: "any",
            mode: "any",
            type: "string"
        },
        content: {
            api: "any",
            default: false,
            definition: "This will normalize all string content to 'text' so as to eliminate some differe" +
                "nces from the output.",
            label: "Ignore Content",
            lexer: "any",
            mode: "diff",
            type: "boolean"
        },
        correct: {
            api: "any",
            default: false,
            definition: "Automatically correct some sloppiness in code.",
            label: "Fix Sloppy Code",
            lexer: "any",
            mode: "any",
            type: "boolean"
        },
        crlf: {
            api: "any",
            default: false,
            definition: "If line termination should be Windows (CRLF) format.  Unix (LF) format is the de" +
                "fault.",
            label: "Line Termination",
            lexer: "any",
            mode: "any",
            type: "boolean"
        },
        css_insert_lines: {
            api: "any",
            default: false,
            definition: "Inserts new line characters between every CSS code block.",
            label: "Insert Empty Lines",
            lexer: "style",
            mode: "beautify",
            type: "boolean"
        },
        diff: {
            api: "any",
            default: "",
            definition: "The code sample to be compared to 'source' option.  This is required if mode is " +
                "'" + "diff'.",
            label: "Code to Compare",
            lexer: "any",
            mode: "diff",
            type: "string"
        },
        diff_comments: {
            api: "any",
            default: false,
            definition: "If true then comments will be preserved so that both code and comments are compa" +
                "red by the diff engine.",
            label: "Code Comments",
            lexer: "any",
            mode: "diff",
            type: "boolean"
        },
        diff_context: {
            api: "any",
            default: -1,
            definition: "This shortens the diff output by allowing a specified number of equivalent lines" +
                " between each line of difference.  This option is only used with diff_format:htm" +
                "l.",
            label: "Context Size",
            lexer: "any",
            mode: "diff",
            type: "number"
        },
        diff_format: {
            api: "any",
            default: "text",
            definition: "The format of the output.  The command line output format is text, similar to Un" +
                "ix 'diff'.",
            label: "Diff Format",
            lexer: "any",
            mode: "diff",
            type: "string",
            values: {
                "html": "An HTML format for embedding in web pages, or as a complete web page if document" +
                    "_complete is true.",
                "json": "A JSON format.",
                "text": "Formatted similar to the Unix 'diff' command line utility."
            }
        },
        diff_label: {
            api: "any",
            default: "New Sample",
            definition: "This allows for a descriptive label for the diff file code of the diff HTML outp" +
                "ut.",
            label: "Label for Diff Sample",
            lexer: "any",
            mode: "diff",
            type: "string"
        },
        diff_rendered_html: {
            api: "any",
            default: false,
            definition: "Compares complete HTML documents and injects custom CSS so that the differences display not in the code, but in the rendered page in a browser.  This option is currently confined only to markup languages, read_method file, and mode diff.  Option diff_format is ignored.",
            label: "Compare Rendered HTML",
            lexer: "markup",
            mode: "diff",
            type: "boolean"
        },
        diff_space_ignore: {
            api: "any",
            default: false,
            definition: "If white space only differences should be ignored by the diff tool.",
            label: "Remove White Space",
            lexer: "any",
            mode: "diff",
            type: "boolean"
        },
        diff_view: {
            api: "any",
            default: "sidebyside",
            definition: "This determines whether the diff HTML output should display as a side-by-side co" +
                "mparison or if the differences should display in a single table column.",
            label: "Diff View Type",
            lexer: "any",
            mode: "diff",
            type: "string",
            values: {
                "inline": "A single column where insertions and deletions are vertically adjacent.",
                "sidebyside": "Two column comparison of changes."
            }
        },
        else_line: {
            api: "any",
            default: false,
            definition: "If else_line is true then the keyword 'else' is forced onto a new line.",
            label: "Else On New Line",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        end_comma: {
            api: "any",
            default: "never",
            definition: "If there should be a trailing comma in arrays and objects. Value \"multiline\" o" +
                "nly applies to modes beautify and diff.",
            label: "Trailing Comma",
            lexer: "script",
            mode: "beautify",
            type: "string",
            values: {
                "always": "Always ensure there is a tailing comma",
                "never": "Remove trailing commas",
                "none": "Ignore this option"
            }
        },
        end_quietly: {
            api: "node",
            default: "default",
            definition: "A node only option to determine if terminal summary data should be logged to the" +
                " console.",
            label: "Log Summary to Console",
            lexer: "any",
            mode: "any",
            type: "string",
            values: {
                "default": "Default minimal summary",
                "log": "Verbose logging",
                "quiet": "No extraneous logging"
            }
        },
        force_attribute: {
            api: "any",
            default: false,
            definition: "If all markup attributes should be indented each onto their own line.",
            label: "Force Indentation of All Attributes",
            lexer: "markup",
            mode: "beautify",
            type: "boolean"
        },
        force_indent: {
            api: "any",
            default: false,
            definition: "Will force indentation upon all content and tags without regard for the creation" +
                " of new text nodes.",
            label: "Force Indentation of All Content",
            lexer: "markup",
            mode: "beautify",
            type: "boolean"
        },
        format_array: {
            api: "any",
            default: "default",
            definition: "Determines if all array indexes should be indented, never indented, or left to t" +
                "he default.",
            label: "Formatting Arrays",
            lexer: "script",
            mode: "beautify",
            type: "string",
            values: {
                "default": "Default formatting",
                "indent": "Always indent each index of an array",
                "inline": "Ensure all array indexes appear on a single line"
            }
        },
        format_object: {
            api: "any",
            default: "default",
            definition: "Determines if all object keys should be indented, never indented, or left to the" +
                " default.",
            label: "Formatting Objects",
            lexer: "script",
            mode: "beautify",
            type: "string",
            values: {
                "default": "Default formatting",
                "indent": "Always indent each key/value pair",
                "inline": "Ensure all key/value pairs appear on the same single line"
            }
        },
        function_name: {
            api: "any",
            default: false,
            definition: "If a space should follow a JavaScript function name.",
            label: "Space After Function Name",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        help: {
            api: "node",
            default: 80,
            definition: "A node only option to print documentation to the console. The value determines w" +
                "here to wrap text.",
            label: "Help Wrapping Limit",
            lexer: "any",
            mode: "any",
            type: "number"
        },
        indent_char: {
            api: "any",
            default: " ",
            definition: "The string characters to comprise a single indentation. Any string combination i" +
                "s accepted.",
            label: "Indentation Characters",
            lexer: "any",
            mode: "beautify",
            type: "string"
        },
        indent_level: {
            api: "any",
            default: 0,
            definition: "How much indentation padding should be applied to beautification? This option is" +
                " internally used for code that requires switching between libraries.",
            label: "Indentation Padding",
            lexer: "any",
            mode: "beautify",
            type: "number"
        },
        indent_size: {
            api: "any",
            default: 4,
            definition: "The number of 'indent_char' values to comprise a single indentation.",
            label: "Indent Size",
            lexer: "any",
            mode: "beautify",
            type: "number"
        },
        jsscope: {
            api: "any",
            default: "none",
            definition: "An educational tool to generate HTML output of JavaScript code to identify scope" +
                " regions and declared references by color.  This option is ignored unless the code language is JavaScript or TypeScript.",
            label: "JavaScript Scope Identification",
            lexer: "script",
            mode: "beautify",
            type: "string",
            values: {
                html: "generates HTML output with escaped angle braces and ampersands for embedding as " +
                    "code, which is handy in code producing tools",
                none: "prevents use of this option",
                report: "generates HTML output that renders in web browsers"
            }
        },
        language: {
            api: "any",
            default: "auto",
            definition: "The lowercase single word common name of the source code's programming language. The value 'auto' imposes language and lexer auto-detection, which ignores deliberately specified lexer values. The value 'text' is converted to 'auto' if options 'mode' is not 'diff'. Value 'text' allows literal comparisons.",
            label: "Language",
            lexer: "any",
            mode: "any",
            type: "string"
        },
        language_default: {
            api: "any",
            default: "text",
            definition: "The fallback option if option 'lang' is set to 'auto' and a language cannot be d" +
                "etected.",
            label: "Language Auto-Detection Default",
            lexer: "any",
            mode: "any",
            type: "string"
        },
        language_name: {
            api: "any",
            default: "JavaScript",
            definition: "The formatted proper name of the code sample's language for use in reports read " +
                "by people.",
            label: "Formatted Name of the Code's Language",
            lexer: "any",
            mode: "any",
            type: "string"
        },
        lexer: {
            api: "any",
            default: "auto",
            definition: "This option determines which sets of rules to use in the language parser. If opt" +
                "ion 'language' has a value of 'auto', which is the default value, this option is" +
                " ignored. The value 'text' is converted to 'auto' if options 'mode' is not 'diff'. Value 'text' allows literal comparisons.",
            label: "Parsing Lexer",
            lexer: "any",
            mode: "any",
            type: "string",
            values: {
                auto: "The value 'auto' imposes language and lexer auto-detection, which ignores deliberately specified language values.",
                markup: "parses languages like XML and HTML",
                script: "parses languages with a C style syntax, such as JavaScript",
                style: "parses CSS like languages"
            }
        },
        list_options: {
            api: "node",
            default: false,
            definition: "A Node.js only option that writes current option settings to the console.",
            label: "Options List",
            lexer: "any",
            mode: "any",
            type: "boolean"
        },
        method_chain: {
            api: "any",
            default: 3,
            definition: "When to break consecutively chained methods and properties onto separate lines. " +
                "A negative value disables this option. A value of 0 ensures method chains are ne" +
                "ver broken.",
            label: "Method Chains",
            lexer: "script",
            mode: "beautify",
            type: "number"
        },
        minify_keep_comments: {
            api: "any",
            default: false,
            definition: "Prevents minification from stripping out comments.",
            label: "Keep Comments",
            lexer: "any",
            mode: "minify",
            type: "boolean"
        },
        minify_wrap: {
            api: "any",
            default: false,
            definition: "Whether minified script should wrap after a specified character width.  This opt" +
                "ion requires a value from option 'wrap'.",
            label: "Minification Wrapping",
            lexer: "script",
            mode: "minify",
            type: "boolean"
        },
        mode: {
            api: "any",
            default: "diff",
            definition: "The operation to be performed.",
            label: "Mode",
            lexer: "any",
            mode: "any",
            type: "string",
            values: {
                beautify: "beautifies code and returns a string",
                diff: "returns either command line list of differences or an HTML report",
                minify: "minifies code and returns a string",
                parse: "using option 'parseFormat' returns an object with shallow arrays, a multidimensi" +
                    "onal array, or an HTML report"
            }
        },
        never_flatten: {
            api: "any",
            default: false,
            definition: "If destructured lists in script should never be flattend.",
            label: "Never Flatten Destructured Lists",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        new_line: {
            api: "any",
            default: false,
            definition: "Insert an empty line at the end of output.",
            label: "New Line at End of Code",
            lexer: "any",
            mode: "any",
            type: "boolean"
        },
        no_case_indent: {
            api: "any",
            default: false,
            definition: "If a case statement should receive the same indentation as the containing switch" +
                " block.",
            label: "Case Indentation",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        no_lead_zero: {
            api: "any",
            default: false,
            definition: "Whether leading 0s in CSS values immediately preceding a decimal should be remo" +
                "ved or prevented.",
            label: "Leading 0s",
            lexer: "style",
            mode: "any",
            type: "boolean"
        },
        no_semicolon: {
            api: "any",
            default: false,
            definition: "Removes semicolons that would be inserted by ASI. This option is in conflict with option 'correct' and takes precedence over conflicting features. Use of this option is a possible security/stability risk.",
            label: "No Semicolons",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        node_error: {
            api: "node",
            default: false,
            definition: "A Node.js only option if parse errors should be written to the console.",
            label: "Write Parse Errors in Node",
            lexer: "any",
            mode: "any",
            type: "boolean"
        },
        object_sort: {
            api: "any",
            default: false,
            definition: "Sorts markup attributes and properties by key name in script and style.",
            label: "Object/Attribute Sort",
            lexer: "any",
            mode: "beautify",
            type: "boolean"
        },
        output: {
            api: "node",
            default: "",
            definition: "A file path for which to write output. If this option is not specified output will be printed to the shell.",
            label: "Output Location",
            lexer: "any",
            mode: "any",
            type: "string"
        },
        parse_format: {
            api: "any",
            default: "parallel",
            definition: "Determines the output format for 'parse' mode.",
            label: "Parse Format",
            lexer: "any",
            mode: "parse",
            type: "string",
            values: {
                htmltable: "generates the 'table' type output for the DOM but escapes the HTML tags for rend" +
                    "ering as HTML code in a HTML tool",
                parallel: "returns an object containing series of parallel arrays",
                sequential: "returns an array where each index is a child object containing the parsed token" +
                    " and all descriptive data",
                table: "generates a colorful grid of output for either the dom or command line interface"
            }
        },
        parse_space: {
            api: "any",
            default: false,
            definition: "Whether whitespace tokens should be included in markup parse output.",
            label: "Retain White Space Tokens in Parse Output",
            lexer: "markup",
            mode: "parse",
            type: "boolean"
        },
        preserve: {
            api: "any",
            default: 0,
            definition: "The maximum number of consecutive empty lines to retain.",
            label: "Preserve Consecutive New Lines",
            lexer: "any",
            mode: "beautify",
            type: "number"
        },
        preserve_comment: {
            api: "any",
            default: false,
            definition: "Prevent comment reformatting due to option wrap.",
            label: "Eliminate Word Wrap Upon Comments",
            lexer: "any",
            mode: "beautify",
            type: "boolean"
        },
        preserve_text: {
            api: "any",
            default: false,
            definition: "If text in the provided markup code should be preserved exactly as provided. Thi" +
                "s option eliminates beautification and wrapping of text content.",
            label: "Preserve Markup Text White Space",
            lexer: "markup",
            mode: "any",
            type: "boolean"
        },
        quote: {
            api: "any",
            default: false,
            definition: "If true and mode is 'diff' then all single quote characters will be replaced by " +
                "double quote characters in both the source and diff file input so as to eliminat" +
                "e some differences from the diff report HTML output.",
            label: "Normalize Quotes",
            lexer: "any",
            mode: "diff",
            type: "boolean"
        },
        quote_convert: {
            api: "any",
            default: "none",
            definition: "If the quotes of script strings or markup attributes should be converted to sing" +
                "le quotes or double quotes.",
            label: "Indent Size",
            lexer: "any",
            mode: "any",
            type: "string",
            values: {
                "double": "Converts single quotes to double quotes",
                "none": "Ignores this option",
                "single": "Converts double quotes to single quotes"
            }
        },
        read_method: {
            api: "node",
            default: "auto",
            definition: "The option determines how Node.js should receive input.  All output will be prin" +
                "ted to the shell unless the option 'output' is specified, which will write outpu" +
                "t to a file.",
            label: "Read Method",
            lexer: "any",
            mode: "any",
            type: "string",
            values: {
                auto: "changes to value subdirectory, file, or screen depending on source resolution",
                directory: "process all files in the specified directory only",
                file: "reads a file and outputs to a file.  file requires option 'output'",
                screen: "reads from screen and outputs to screen",
                subdirectory: "process all files in a directory and its subdirectories"
            }
        },
        selector_list: {
            api: "any",
            default: false,
            definition: "If comma separated CSS selectors should present on a single line of code.",
            label: "Indent Size",
            lexer: "style",
            mode: "beautify",
            type: "boolean"
        },
        semicolon: {
            api: "any",
            default: false,
            definition: "If true and mode is 'diff' and lang is 'javascript' all semicolon characters tha" +
                "t immediately precede any white space containing a new line character will be re" +
                "moved so as to eliminate some differences from the code comparison.",
            label: "Indent Size",
            lexer: "script",
            mode: "diff",
            type: "boolean"
        },
        source: {
            api: "any",
            default: "",
            definition: "The source code or location for interpretation. This option is required for all " +
                "modes.",
            label: "Source Sample",
            lexer: "any",
            mode: "any",
            type: "string"
        },
        source_label: {
            api: "any",
            default: "Source Sample",
            definition: "This allows for a descriptive label of the source file code for the diff HTML o" +
                "utput.",
            label: "Label for Source Sample",
            lexer: "any",
            mode: "diff",
            type: "string"
        },
        space: {
            api: "any",
            default: true,
            definition: "Inserts a space following the function keyword for anonymous functions.",
            label: "Function Space",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        space_close: {
            api: "any",
            default: false,
            definition: "Markup self-closing tags end will end with ' />' instead of '/>'.",
            label: "Close Markup Self-Closing Tags with a Space",
            lexer: "markup",
            mode: "beautify",
            type: "boolean"
        },
        styleguide: {
            api: "any",
            default: "none",
            definition: "Provides a collection of option presets to easily conform to popular JavaScript " +
                "style guides.",
            label: "Script Styleguide",
            lexer: "script",
            mode: "beautify",
            type: "string",
            values: {
                "airbnb": "https://github.com/airbnb/javascript",
                "crockford": "http://jslint.com/",
                "google": "https://google.github.io/styleguide/jsguide.html",
                "jquery": "https://contribute.jquery.org/style-guide/js/",
                "jslint": "http://jslint.com/",
                "mediawiki": "https://www.mediawiki.org/wiki/Manual:Coding_conventions/JavaScript",
                "mrdoob": "https://github.com/mrdoob/three.js/wiki/Mr.doob's-Code-Style%E2%84%A2",
                "none": "Ignores this option",
                "semistandard": "https://github.com/Flet/semistandard",
                "standard": "https://standardjs.com/",
                "yandex": "https://github.com/ymaps/codestyle/blob/master/javascript.md"
            }
        },
        summary_only: {
            api: "node",
            default: false,
            definition: "Node only option to output only number of differences.",
            label: "Output Diff Only Without A Summary",
            lexer: "any",
            mode: "diff",
            type: "boolean"
        },
        tag_merge: {
            api: "any",
            default: false,
            definition: "Allows immediately adjacement start and end markup tags of the same name to be c" +
                "ombined into a single self-closing tag.",
            label: "Merge Adjacent Start and End tags",
            lexer: "markup",
            mode: "any",
            type: "boolean"
        },
        tag_sort: {
            api: "any",
            default: false,
            definition: "Sort child items of each respective markup parent element.",
            label: "Sort Markup Child Items",
            lexer: "markup",
            mode: "any",
            type: "boolean"
        },
        ternary_line: {
            api: "any",
            default: false,
            definition: "If ternary operators in JavaScript ? and : should remain on the same line.",
            label: "Keep Ternary Statements On One Line",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        top_comments: {
            api: "any",
            default: false,
            definition: "If mode is 'minify' this determines whether comments above the first line of cod" +
                "e should be kept.",
            label: "Retain Comment At Code Start",
            lexer: "any",
            mode: "minify",
            type: "boolean"
        },
        unformatted: {
            api: "any",
            default: false,
            definition: "If markup tags should have their insides preserved. This option is only available to markup and does not support child tokens that require a different lexer.",
            label: "Markup Tag Preservation",
            lexer: "markup",
            mode: "any",
            type: "boolean"
        },
        variable_list: {
            api: "any",
            default: "none",
            definition: "If consecutive JavaScript variables should be merged into a comma separated list" +
                " or if variables in a list should be separated.",
            label: "Variable Declaration Lists",
            lexer: "script",
            mode: "any",
            type: "string",
            values: {
                "each": "Ensurce each reference is a single declaration statement.",
                "list": "Ensure consecutive declarations are a comma separated list.",
                "none": "Ignores this option."
            }
        },
        version: {
            api: "node",
            default: false,
            definition: "A Node.js only option to write the version information to the console.",
            label: "Version",
            lexer: "any",
            mode: "any",
            type: "boolean"
        },
        vertical: {
            api: "any",
            default: false,
            definition: "If lists of assignments and properties should be vertically aligned. This option" +
                " is not used with the markup lexer.",
            label: "Vertical Alignment",
            lexer: "any",
            mode: "beautify",
            type: "boolean"
        },
        wrap: {
            api: "any",
            default: 0,
            definition: "Character width limit before applying word wrap. A 0 value disables this option." +
                " A negative value concatenates script strings.",
            label: "Wrap",
            lexer: "any",
            mode: "any",
            type: "number"
        }
    };
    prettydiff.api
        .optionDef = optionDef;
}());

(function beautify_markup_init() {
    const markup = function beautify_markup(options) {
        const data = options.parsed, lexer = "markup", c = (prettydiff.end < 1 || prettydiff.end > data.token.length)
            ? data.token.length
            : prettydiff.end + 1, lf = (options.crlf === true)
            ? "\r\n"
            : "\n", externalIndex = {}, levels = (function beautify_markup_levels() {
            const level = (prettydiff.start > 0)
                ? Array(prettydiff.start).fill(0, 0, prettydiff.start)
                : [], nextIndex = function beautify_markup_levels_next() {
                let x = a + 1, y = 0;
                if (data.types[x] === undefined) {
                    return x - 1;
                }
                if (data.types[x] === "comment" || (a < c - 1 && data.types[x].indexOf("attribute") > -1)) {
                    do {
                        if (data.types[x] === "jsx_attribute_start") {
                            y = x;
                            do {
                                if (data.types[x] === "jsx_attribute_end" && data.begin[x] === y) {
                                    break;
                                }
                                x = x + 1;
                            } while (x < c);
                        }
                        else if (data.types[x] !== "comment" && data.types[x].indexOf("attribute") < 0) {
                            return x;
                        }
                        x = x + 1;
                    } while (x < c);
                }
                return x;
            }, anchorList = function beautify_markup_levels_anchorList() {
                let aa = a;
                const stop = data.begin[a];
                // verify list is only a link list before making changes
                do {
                    aa = aa - 1;
                    if (data.token[aa] === "</li>" && data.begin[data.begin[aa]] === stop && data.token[aa - 1] === "</a>" && data.begin[aa - 1] === data.begin[aa] + 1) {
                        aa = data.begin[aa];
                    }
                    else {
                        return;
                    }
                } while (aa > stop + 1);
                // now make the changes
                aa = a;
                do {
                    aa = aa - 1;
                    if (data.types[aa + 1] === "attribute") {
                        level[aa] = -10;
                    }
                    else if (data.token[aa] !== "</li>") {
                        level[aa] = -20;
                    }
                } while (aa > stop + 1);
            }, comment = function beautify_markup_levels_comment() {
                let x = a, test = false;
                if (data.lines[a + 1] === 0 && options.force_indent === false) {
                    do {
                        if (data.lines[x] > 0) {
                            test = true;
                            break;
                        }
                        x = x - 1;
                    } while (x > comstart);
                    x = a;
                }
                else {
                    test = true;
                }
                // the first condition applies indentation while the else block does not
                if (test === true) {
                    let ind = (data.types[next] === "end" || data.types[next] === "template_end")
                        ? indent + 1
                        : indent;
                    do {
                        level.push(ind);
                        x = x - 1;
                    } while (x > comstart);
                    // correction so that a following end tag is not indented 1 too much
                    if (ind === indent + 1) {
                        level[a] = indent;
                    }
                    // indentation must be applied to the tag preceeding the comment
                    if (data.types[x] === "attribute" || data.types[x] === "template_attribute" || data.types[x] === "jsx_attribute_start") {
                        level[data.begin[x]] = ind;
                    }
                    else {
                        level[x] = ind;
                    }
                }
                else {
                    do {
                        level.push(-20);
                        x = x - 1;
                    } while (x > comstart);
                    level[x] = -20;
                }
                comstart = -1;
            }, content = function beautify_markup_levels_content() {
                let ind = indent;
                if (options.force_indent === true || options.force_attribute === true) {
                    level.push(indent);
                    return;
                }
                if (next < c && (data.types[next].indexOf("end") > -1 || data.types[next].indexOf("start") > -1) && data.lines[next] > 0) {
                    level.push(indent);
                    ind = ind + 1;
                    if (data.types[a] === "singleton" && a > 0 && data.types[a - 1].indexOf("attribute") > -1 && data.types[data.begin[a - 1]] === "singleton") {
                        if (data.begin[a] < 0 || (data.types[data.begin[a - 1]] === "singleton" && data.begin[data.ender[a] - 1] !== a)) {
                            level[a - 1] = indent;
                        }
                        else {
                            level[a - 1] = indent + 1;
                        }
                    }
                }
                else if (data.types[a] === "singleton" && a > 0 && data.types[a - 1].indexOf("attribute") > -1) {
                    level[a - 1] = indent;
                    count = data.token[a].length;
                    level.push(-10);
                }
                else if (data.lines[next] === 0) {
                    level.push(-20);
                }
                else if (
                // wrap if
                // * options.wrap is 0
                // * next token is singleton with an attribute and exceeds wrap
                // * next token is template or singleton and exceeds wrap
                (options.wrap === 0 ||
                    (a < c - 2 && data.token[a].length + data.token[a + 1].length + data.token[a + 2].length + 1 > options.wrap && data.types[a + 2].indexOf("attribute") > -1) ||
                    (data.token[a].length + data.token[a + 1].length > options.wrap)) &&
                    (data.types[a + 1] === "singleton" || data.types[a + 1] === "template")) {
                    level.push(indent);
                }
                else {
                    count = count + 1;
                    level.push(-10);
                }
                if (a > 0 && data.types[a - 1].indexOf("attribute") > -1 && data.lines[a] < 1) {
                    level[a - 1] = -20;
                }
                if (count > options.wrap) {
                    let d = a, e = Math.max(data.begin[a], 0);
                    if (data.types[a] === "content" && options.preserve_text === false) {
                        let countx = 0, chars = data.token[a].replace(/\s+/g, " ").split(" ");
                        do {
                            d = d - 1;
                            if (level[d] < 0) {
                                countx = countx + data.token[d].length;
                                if (level[d] === -10) {
                                    countx = countx + 1;
                                }
                            }
                            else {
                                break;
                            }
                        } while (d > 0);
                        d = 0;
                        e = chars.length;
                        do {
                            if (chars[d].length + countx > options.wrap) {
                                chars[d] = lf + chars[d];
                                countx = chars[d].length;
                            }
                            else {
                                chars[d] = ` ${chars[d]}`;
                                countx = countx + chars[d].length;
                            }
                            d = d + 1;
                        } while (d < e);
                        if (chars[0].charAt(0) === " ") {
                            data.token[a] = chars.join("").slice(1);
                        }
                        else {
                            level[a - 1] = ind;
                            data.token[a] = chars.join("").replace(lf, "");
                        }
                        if (data.token[a].indexOf(lf) > 0) {
                            count = data.token[a].length - data.token[a].lastIndexOf(lf);
                        }
                    }
                    else {
                        do {
                            d = d - 1;
                            if (level[d] > -1) {
                                count = data.token[a].length;
                                if (data.lines[a + 1] > 0) {
                                    count = count + 1;
                                }
                                return;
                            }
                            if (data.types[d].indexOf("start") > -1) {
                                count = 0;
                                return;
                            }
                            if ((data.types[d] !== "attribute" || (data.types[d] === "attribute" && data.types[d + 1] !== "attribute")) && data.lines[d + 1] > 0) {
                                if (data.types[d] !== "singleton" || (data.types[d] === "singleton" && data.types[d + 1] !== "attribute")) {
                                    count = data.token[a].length;
                                    if (data.lines[a + 1] > 0) {
                                        count = count + 1;
                                    }
                                    break;
                                }
                            }
                        } while (d > e);
                        level[d] = ind;
                    }
                }
            }, external = function beautify_markup_levels_external() {
                let skip = a;
                do {
                    if (data.lexer[a + 1] === lexer && data.begin[a + 1] < skip && data.types[a + 1] !== "start" && data.types[a + 1] !== "singleton") {
                        break;
                    }
                    level.push(0);
                    a = a + 1;
                } while (a < c);
                externalIndex[skip] = a;
                level.push(indent - 1);
                next = nextIndex();
                if (data.lexer[next] === lexer && data.stack[a].indexOf("attribute") < 0 && (data.types[next] === "end" || data.types[next] === "template_end")) {
                    indent = indent - 1;
                }
            }, attribute = function beautify_markup_levels_attribute() {
                const parent = a - 1, wrap = function beautify_markup_levels_attribute_wrap(index) {
                    const item = data.token[index].replace(/\s+/g, " ").split(" "), ilen = item.length;
                    let bb = 1, acount = item[0].length;
                    if ((/=("|')?(<|(\{(\{|%|#|@|!|\?|^))|(\[%))/).test(data.token[index]) === true) {
                        return;
                    }
                    do {
                        if (acount + item[bb].length > options.wrap) {
                            acount = item[bb].length;
                            item[bb] = lf + item[bb];
                        }
                        else {
                            item[bb] = ` ${item[bb]}`;
                            acount = acount + item[bb].length;
                        }
                        bb = bb + 1;
                    } while (bb < ilen);
                    data.token[index] = item.join("");
                };
                let y = a, len = data.token[parent].length + 1, plural = false, lev = (function beautify_markup_levels_attribute_level() {
                    if (data.types[a].indexOf("start") > 0) {
                        let x = a;
                        do {
                            if (data.types[x].indexOf("end") > 0 && data.begin[x] === a) {
                                if (x < c - 1 && data.types[x + 1].indexOf("attribute") > -1) {
                                    plural = true;
                                    break;
                                }
                            }
                            x = x + 1;
                        } while (x < c);
                    }
                    else if (a < c - 1 && data.types[a + 1].indexOf("attribute") > -1) {
                        plural = true;
                    }
                    if (data.types[next] === "end" || data.types[next] === "template_end") {
                        if (data.types[parent] === "singleton") {
                            return indent + 2;
                        }
                        return indent + 1;
                    }
                    if (data.types[parent] === "singleton") {
                        return indent + 1;
                    }
                    return indent;
                }()), earlyexit = false, attStart = false;
                if (plural === false && data.types[a] === "comment_attribute") {
                    // lev must be indent unless the "next" type is end then its indent + 1
                    level.push(indent);
                    if (data.types[parent] === "singleton") {
                        level[parent] = indent + 1;
                    }
                    else {
                        level[parent] = indent;
                    }
                    return;
                }
                if (lev < 1) {
                    lev = 1;
                }
                // first, set levels and determine if there are template attributes
                do {
                    count = count + data.token[a].length + 1;
                    if (data.types[a].indexOf("attribute") > 0) {
                        if (data.types[a] === "template_attribute") {
                            level.push(-10);
                        }
                        else if (data.types[a] === "comment_attribute") {
                            level.push(lev);
                        }
                        else if (data.types[a].indexOf("start") > 0) {
                            attStart = true;
                            if (a < c - 2 && data.types[a + 2].indexOf("attribute") > 0) {
                                level.push(-20);
                                a = a + 1;
                                externalIndex[a] = a;
                            }
                            else {
                                if (parent === a - 1 && plural === false) {
                                    level.push(lev);
                                }
                                else {
                                    level.push(lev + 1);
                                }
                                if (data.lexer[a + 1] !== lexer) {
                                    a = a + 1;
                                    external();
                                }
                            }
                        }
                        else if (data.types[a].indexOf("end") > 0) {
                            if (level[a - 1] !== -20) {
                                level[a - 1] = level[data.begin[a]] - 1;
                            }
                            if (data.lexer[a + 1] !== lexer) {
                                level.push(-20);
                            }
                            else {
                                level.push(lev);
                            }
                        }
                        else {
                            level.push(lev);
                        }
                        earlyexit = true;
                    }
                    else if (data.types[a] === "attribute") {
                        len = len + data.token[a].length + 1;
                        if (options.unformatted === true) {
                            level.push(-10);
                        }
                        else if (options.force_attribute === true || attStart === true || (a < c - 1 && data.types[a + 1] !== "template_attribute" && data.types[a + 1].indexOf("attribute") > 0)) {
                            level.push(lev);
                        }
                        else {
                            level.push(-10);
                        }
                    }
                    else if (data.begin[a] < parent + 1) {
                        break;
                    }
                    a = a + 1;
                } while (a < c);
                a = a - 1;
                if (level[a - 1] > 0 && data.types[a].indexOf("end") > 0 && data.types[a].indexOf("attribute") > 0 && data.types[parent] !== "singleton" && plural === true) {
                    level[a - 1] = level[a - 1] - 1;
                }
                if (level[a] !== -20) {
                    if (options.language === "jsx" && data.types[parent].indexOf("start") > -1 && data.types[a + 1] === "script_start") {
                        level[a] = lev;
                    }
                    else {
                        level[a] = level[parent];
                    }
                }
                if (options.force_attribute === true) {
                    count = 0;
                    level[parent] = lev;
                }
                else {
                    level[parent] = -10;
                }
                if (earlyexit === true || options.unformatted === true || data.token[parent] === "<%xml%>" || data.token[parent] === "<?xml?>") {
                    count = 0;
                    return;
                }
                y = a;
                // second, ensure tag contains more than one attribute
                if (y > parent + 1) {
                    // finally, indent attributes if tag length exceeds the wrap limit
                    if (options.space_close === false) {
                        len = len - 1;
                    }
                    if (len > options.wrap && options.wrap > 0 && options.force_attribute === false) {
                        count = data.token[a].length;
                        do {
                            if (data.token[y].length > options.wrap && (/\s/).test(data.token[y]) === true) {
                                wrap(y);
                            }
                            y = y - 1;
                            level[y] = lev;
                        } while (y > parent);
                    }
                }
                else if (options.wrap > 0 && data.types[a] === "attribute" && data.token[a].length > options.wrap && (/\s/).test(data.token[a]) === true) {
                    wrap(a);
                }
            };
            let a = prettydiff.start, comstart = -1, next = 0, count = 0, indent = (isNaN(options.indent_level) === true)
                ? 0
                : Number(options.indent_level);
            // data.lines -> space before token
            // level -> space after token
            do {
                if (data.lexer[a] === lexer) {
                    if (data.token[a].toLowerCase().indexOf("<!doctype") === 0) {
                        level[a - 1] = indent;
                    }
                    if (data.types[a].indexOf("attribute") > -1) {
                        attribute();
                    }
                    else if (data.types[a] === "comment") {
                        if (comstart < 0) {
                            comstart = a;
                        }
                        if (data.types[a + 1] !== "comment" || (a > 0 && data.types[a - 1].indexOf("end") > -1)) {
                            comment();
                        }
                    }
                    else if (data.types[a] !== "comment") {
                        next = nextIndex();
                        if (data.types[next] === "end" || data.types[next] === "template_end") {
                            indent = indent - 1;
                            if (data.types[next] === "template_end" && data.types[data.begin[next] + 1] === "template_else") {
                                indent = indent - 1;
                            }
                            if (data.token[a] === "</ol>" || data.token[a] === "</ul>") {
                                anchorList();
                            }
                        }
                        if (data.types[a] === "script_end" && data.types[a + 1] === "end") {
                            if (data.lines[a + 1] < 1) {
                                level.push(-20);
                            }
                            else {
                                level.push(-10);
                            }
                        }
                        else if ((options.force_indent === false || (options.force_indent === true && data.types[next] === "script_start")) && (data.types[a] === "content" || data.types[a] === "singleton" || data.types[a] === "template")) {
                            count = count + data.token[a].length;
                            if (data.lines[next] > 0 && data.types[next] === "script_start") {
                                level.push(-10);
                            }
                            else if (options.wrap > 0 && (data.types[a].indexOf("template") < 0 || (next < c && data.types[a].indexOf("template") > -1 && data.types[next].indexOf("template") < 0))) {
                                content();
                            }
                            else if (next < c && (data.types[next].indexOf("end") > -1 || data.types[next].indexOf("start") > -1) && (data.lines[next] > 0 || data.types[next].indexOf("template_") > -1)) {
                                level.push(indent);
                            }
                            else if (data.lines[next] === 0) {
                                level.push(-20);
                            }
                            else {
                                level.push(indent);
                            }
                        }
                        else if (data.types[a] === "start" || data.types[a] === "template_start") {
                            indent = indent + 1;
                            if (data.types[a] === "template_start" && data.types[a + 1] === "template_else") {
                                indent = indent + 1;
                            }
                            if (options.language === "jsx" && data.token[a + 1] === "{") {
                                if (data.lines[a + 1] === 0) {
                                    level.push(-20);
                                }
                                else {
                                    level.push(-10);
                                }
                            }
                            else if (data.types[a] === "start" && data.types[next] === "end") {
                                level.push(-20);
                            }
                            else if (data.types[a] === "start" && data.types[next] === "script_start") {
                                level.push(-10);
                            }
                            else if (options.force_indent === true) {
                                level.push(indent);
                            }
                            else if (data.types[a] === "template_start" && data.types[next] === "template_end") {
                                level.push(-20);
                            }
                            else if (data.lines[next] === 0 && (data.types[next] === "content" || data.types[next] === "singleton" || (data.types[a] === "start" && data.types[next] === "template"))) {
                                level.push(-20);
                            }
                            else {
                                level.push(indent);
                            }
                        }
                        else if (options.force_indent === false && data.lines[next] === 0 && (data.types[next] === "content" || data.types[next] === "singleton")) {
                            level.push(-20);
                        }
                        else if (data.types[a + 2] === "script_end") {
                            level.push(-20);
                        }
                        else if (data.types[a] === "template_else") {
                            if (data.types[next] === "template_end") {
                                level[a - 1] = indent + 1;
                            }
                            else {
                                level[a - 1] = indent - 1;
                            }
                            level.push(indent);
                        }
                        else {
                            level.push(indent);
                        }
                    }
                    if (data.types[a] !== "content" && data.types[a] !== "singleton" && data.types[a] !== "template" && data.types[a] !== "attribute") {
                        count = 0;
                    }
                }
                else {
                    count = 0;
                    external();
                }
                a = a + 1;
            } while (a < c);
            return level;
        }());
        return (function beautify_markup_apply() {
            const build = [], ind = (function beautify_markup_apply_tab() {
                const indy = [options.indent_char], size = options.indent_size - 1;
                let aa = 0;
                if (aa < size) {
                    do {
                        indy.push(options.indent_char);
                        aa = aa + 1;
                    } while (aa < size);
                }
                return indy.join("");
            }()), 
            // a new line character plus the correct amount of identation for the given line
            // of code
            nl = function beautify_markup_apply_nl(tabs) {
                const linesout = [], pres = options.preserve + 1, total = Math.min(data.lines[a + 1] - 1, pres);
                let index = 0;
                if (tabs < 0) {
                    tabs = 0;
                }
                do {
                    linesout.push(lf);
                    index = index + 1;
                } while (index < total);
                if (tabs > 0) {
                    index = 0;
                    do {
                        linesout.push(ind);
                        index = index + 1;
                    } while (index < tabs);
                }
                return linesout.join("");
            }, multiline = function beautify_markup_apply_multiline() {
                const lines = data.token[a].split(lf), line = data.lines[a + 1], lev = (levels[a - 1] > -1)
                    ? (data.types[a] === "attribute")
                        ? levels[a - 1] + 1
                        : levels[a - 1]
                    : (function beautify_markup_apply_multiline_lev() {
                        let bb = a - 1, start = (bb > -1 && data.types[bb].indexOf("start") > -1);
                        if (levels[a] > -1 && data.types[a] === "attribute") {
                            return levels[a] + 1;
                        }
                        do {
                            bb = bb - 1;
                            if (levels[bb] > -1) {
                                if (data.types[a] === "content" && start === false) {
                                    return levels[bb];
                                }
                                return levels[bb] + 1;
                            }
                            if (data.types[bb].indexOf("start") > -1) {
                                start = true;
                            }
                        } while (bb > 0);
                        return 1;
                    }());
                let aa = 0, len = lines.length - 1;
                data.lines[a + 1] = 0;
                do {
                    build.push(lines[aa]);
                    build.push(nl(lev));
                    aa = aa + 1;
                } while (aa < len);
                data.lines[a + 1] = line;
                build.push(lines[len]);
                if (levels[a] === -10) {
                    build.push(" ");
                }
                else if (levels[a] > -1) {
                    build.push(nl(levels[a]));
                }
            }, attributeEnd = function beautify_markup_apply_attributeEnd() {
                const parent = data.token[a], regend = (/(\/|\?)?>$/), end = regend.exec(parent);
                let y = a + 1, space = (options.space_close === true && end !== null && end[0] === "/>")
                    ? " "
                    : "", jsx = false;
                if (end === null) {
                    return;
                }
                data.token[a] = parent.replace(regend, "");
                do {
                    if (data.types[y] === "jsx_attribute_end" && data.begin[data.begin[y]] === a) {
                        jsx = false;
                    }
                    else if (data.begin[y] === a) {
                        if (data.types[y] === "jsx_attribute_start") {
                            jsx = true;
                        }
                        else if (data.types[y].indexOf("attribute") < 0 && jsx === false) {
                            break;
                        }
                    }
                    else if (jsx === false && (data.begin[y] < a || data.types[y].indexOf("attribute") < 0)) {
                        break;
                    }
                    y = y + 1;
                } while (y < c);
                if (data.types[y - 1] === "comment_attribute") {
                    space = nl(levels[y - 2] - 1);
                }
                data.token[y - 1] = data.token[y - 1] + space + end[0];
            };
            let a = prettydiff.start, external = "", lastLevel = options.indent_level;
            do {
                if (data.lexer[a] === lexer || prettydiff.beautify[data.lexer[a]] === undefined) {
                    if ((data.types[a] === "start" || data.types[a] === "singleton" || data.types[a] === "xml" || data.types[a] === "sgml") && data.types[a].indexOf("attribute") < 0 && a < c - 1 && data.types[a + 1] !== undefined && data.types[a + 1].indexOf("attribute") > -1) {
                        attributeEnd();
                    }
                    if (data.token[a] !== undefined && data.token[a].indexOf(lf) > 0 && ((data.types[a] === "content" && options.preserve_text === false) || data.types[a] === "comment" || data.types[a] === "attribute")) {
                        multiline();
                    }
                    else {
                        build.push(data.token[a]);
                        if (levels[a] === -10 && a < c - 1) {
                            build.push(" ");
                        }
                        else if (levels[a] > -1) {
                            lastLevel = levels[a];
                            build.push(nl(levels[a]));
                        }
                    }
                }
                else {
                    if (externalIndex[a] === a && data.types[a] !== "reference") {
                        build.push(data.token[a]);
                    }
                    else {
                        prettydiff.end = externalIndex[a];
                        options.indent_level = lastLevel;
                        prettydiff.start = a;
                        external = prettydiff.beautify[data.lexer[a]](options).replace(/\s+$/, "");
                        build.push(external);
                        if (levels[prettydiff.iterator] > -1 && externalIndex[a] > a) {
                            build.push(nl(levels[prettydiff.iterator]));
                        }
                        a = prettydiff.iterator;
                    }
                }
                a = a + 1;
            } while (a < c);
            prettydiff.iterator = c - 1;
            if (build[0] === lf || build[0] === " ") {
                build[0] = "";
            }
            return build.join("");
        }());
    };
    prettydiff.beautify.markup = markup;
}());
(function diffview_init() {
    const diffview = function diffview_(options) {
        const tab = (function diffview_tab() {
            let a = 0;
            const output = [];
            if (options.indent_char === "" || options.indent_size < 1) {
                return "";
            }
            do {
                output.push(options.indent_char);
                a = a + 1;
            } while (a < options.indent_size);
            return output.join("");
        }()), 
        // translates source code from a string to an array by splitting on line breaks
        stringAsLines = function diffview_stringAsLines(str) {
            const lines = (options.diff_format === "text")
                ? str
                : str
                    .replace(/&/g, "&amp;")
                    .replace(/&#lt;/g, "$#lt;")
                    .replace(/&#gt;/g, "$#gt;")
                    .replace(/</g, "$#lt;")
                    .replace(/>/g, "$#gt;");
            if (options.crlf === true) {
                return lines.split("\r\n");
            }
            return lines.split("\n");
        }, 
        // array representation of base source
        baseTextArray = (typeof options.source === "string")
            ? stringAsLines(options.source)
            : options.source, 
        // array representation of new source
        newTextArray = (typeof options.diff === "string")
            ? stringAsLines(options.diff)
            : options.diff, codeBuild = function diffview_opcodes() {
            const table = {}, one = baseTextArray, two = newTextArray;
            let lena = one.length, lenb = two.length, a = 0, b = 0, c = 0, d = 0, codes = [], clean = function diffview_opcodes_clean(ln) {
                if (ln === undefined) {
                    return;
                }
                return options.diff_space_ignore === true ? ln.replace(/\s+/g, '') : ln;
            }, fix = function diffview_opcodes_fix(code) {
                let len = codes.length - 1, prior = codes[len];
                if (prior !== undefined) {
                    if (prior[0] === code[0]) {
                        if (code[0] === "replace" || code[0] === "equal") {
                            prior[2] = code[2];
                            prior[4] = code[4];
                        }
                        else if (code[0] === "delete") {
                            prior[2] = code[2];
                        }
                        else if (code[0] === "insert") {
                            prior[4] = code[4];
                        }
                        if (codes.length > 1 && prior[2] === code[2] && prior[4] === code[4]) {
                            if (prior[0] === "insert" && clean(two[codes[codes.length - 2][4] - (prior[4] - prior[3])]) === clean(one[codes[codes.length - 2][1]])) {
                                codes.pop();
                                len = len - 1;
                                codes[len] = ["insert", -1, -1, codes[len][3], codes[len][4] - (prior[4] - prior[3])];
                                if (codes[len][4] < 0) {
                                    codes[len][4] = prior[4] - prior[3];
                                }
                                do {
                                    // one-sided replacement undo, more like undelete
                                    table[one[c]][0] = table[one[c]][0] + 1;
                                    c = c - 1;
                                } while (c > codes[codes.length - 2][2]);
                                d = codes[len][4] - 1;
                            }
                        }
                        return;
                    }
                    if (prior[0] === "insert" && prior[4] - prior[3] === 1) {
                        if (code[2] - code[1] === 1) {
                            if (code[0] === "replace") {
                                codes[len] = ["replace", code[1], code[2], prior[3], prior[4]];
                                prior = codes[len];
                                code = ["insert", -1, -2, code[3], code[4]];
                            }
                            else if (code[0] === "delete") {
                                code = ["replace", code[1], code[2], prior[3], prior[4]];
                                codes.pop();
                                len = len - 1;
                                prior = codes[len];
                                if (codes[len][0] === "replace") {
                                    prior[2] = code[2];
                                    prior[4] = code[4];
                                    return;
                                }
                            }
                        }
                        else if (code[0] === "delete") {
                            codes[len] = ["replace", code[1], code[1] + 1, prior[3], prior[4]];
                            prior = codes[len];
                            code[1] = code[1] + 1;
                        }
                        else if (code[0] === "replace") {
                            codes[len] = ["replace", code[1], code[1] + 1, prior[3], prior[4]];
                            prior = codes[len];
                            c = (prior[2] > 0)
                                ? prior[2]
                                : 0;
                            d = (prior[4] > 0)
                                ? prior[4]
                                : 0;
                            return;
                        }
                    }
                    else if (prior[0] === "insert" && code[0] === "delete" && code[2] - code[1] === 1) {
                        prior[4] = prior[4] - 1;
                        code = ["replace", code[1], code[2], prior[4], prior[4] + 1];
                    }
                    else if (prior[0] === "delete" && prior[2] - prior[1] === 1) {
                        if (code[4] - code[3] === 1) {
                            if (code[0] === "replace") {
                                codes[len] = ["replace", prior[1], prior[2], code[3], code[4]];
                                prior = codes[len];
                                code = ["delete", code[1], code[2], -1, -1];
                            }
                            else if (code[0] === "insert") {
                                code = ["replace", prior[1], prior[2], code[3], code[4]];
                                codes.pop();
                                len = len - 1;
                                prior = codes[len];
                                if (codes[len][0] === "replace") {
                                    prior[2] = code[2];
                                    prior[4] = code[4];
                                    return;
                                }
                            }
                        }
                        else if (code[0] === "insert") {
                            codes[len] = ['replace', prior[1], prior[2], code[3], code[3] + 1];
                            prior = codes[len];
                            code[3] = code[3] + 1;
                        }
                        else if (code[0] === "replace") {
                            codes[len] = ["replace", prior[1], prior[2], code[3], code[4] + 1];
                            c = (prior[2] > 0)
                                ? prior[2]
                                : 0;
                            d = (prior[4] > 0)
                                ? prior[4]
                                : 0;
                            return;
                        }
                    }
                    else if (prior[0] === "delete" && code[0] === "insert" && code[4] - code[3] === 1) {
                        prior[2] = prior[2] - 1;
                        code = ["replace", prior[2], prior[2] + 1, code[3], code[4]];
                    }
                    else if (prior[0] === "replace") {
                        if (code[0] === "delete" && code[2] - 1 > a) {
                            c = (code[2] - 1 > 0)
                                ? code[2] - 1
                                : 0;
                            d = (prior[3] > 0)
                                ? prior[3]
                                : 0;
                            codes[len] = ["delete", prior[1], code[2] - 1, -1, -1];
                            return;
                        }
                        if (code[0] === "insert" && code[4] - 1 > b) {
                            c = (prior[1] > 0)
                                ? prior[1]
                                : 0;
                            d = (code[4] - 1 > 0)
                                ? code[4] - 1
                                : 0;
                            codes[len] = ["insert", -1, -1, prior[3], code[4] - 1];
                            return;
                        }
                    }
                }
                if (codes.length > 1 && codes[codes.length - 2][0] === codes[len][0]) {
                    codes[codes.length - 2][2] = codes[len][2];
                    codes[codes.length - 2][4] = codes[len][4];
                    codes.pop();
                    diffview_opcodes_fix(code);
                }
                else {
                    codes.push(code);
                }
            }, equality = function diffview_opcodes_equality() {
                do {
                    table[one[c]][0] = table[one[c]][0] - 1;
                    table[one[c]][1] = table[one[c]][1] - 1;
                    c = c + 1;
                    d = d + 1;
                } while (c < lena && d < lenb && clean(one[c]) === clean(two[d]));
                fix(["equal", a, c, b, d]);
                b = d - 1;
                a = c - 1;
            }, deletion = function diffview_opcodes_deletion() {
                do {
                    table[one[c]][0] = table[one[c]][0] - 1;
                    c = c + 1;
                } while (c < lena && table[one[c]][1] < 1);
                fix(["delete", a, c, -1, -1]);
                a = c - 1;
                b = d - 1;
            }, deletionStatic = function diffview_opcodes_deletionStatic() {
                table[one[a]][0] = table[one[a]][0] - 1;
                fix([
                    "delete", a, a + 1,
                    -1,
                    -1
                ]);
                a = c;
                b = d - 1;
            }, insertion = function diffview_opcodes_insertion() {
                do {
                    table[two[d]][1] = table[two[d]][1] - 1;
                    d = d + 1;
                } while (d < lenb && table[two[d]][0] < 1);
                fix(["insert", -1, -1, b, d]);
                a = c - 1;
                b = d - 1;
            }, insertionStatic = function diffview_opcodes_insertionStatic() {
                table[two[b]][1] = table[two[b]][1] - 1;
                fix([
                    "insert", -1, -1, b, b + 1
                ]);
                a = c - 1;
                b = d;
            }, replacement = function diffview_opcodes_replacement() {
                do {
                    table[one[c]][0] = table[one[c]][0] - 1;
                    table[two[d]][1] = table[two[d]][1] - 1;
                    c = c + 1;
                    d = d + 1;
                } while (c < lena && d < lenb && table[one[c]][1] > 0 && table[two[d]][0] > 0);
                fix(["replace", a, c, b, d]);
                a = c - 1;
                b = d - 1;
            }, replaceUniques = function diffview_opcodes_replaceUniques() {
                do {
                    table[one[c]][0] = table[one[c]][0] - 1;
                    c = c + 1;
                    d = d + 1;
                } while (c < lena && d < lenb && table[one[c]][1] < 1 && table[two[d]][0] < 1);
                fix(["replace", a, c, b, d]);
                a = c - 1;
                b = d - 1;
            };
            // * First Pass, account for lines from first file
            // * build the table from the second file
            do {
                if (table[two[b]] === undefined) {
                    table[two[b]] = [0, 1];
                }
                else {
                    table[two[b]][1] = table[two[b]][1] + 1;
                }
                b = b + 1;
            } while (b < lenb);
            // * Second Pass, account for lines from second file
            // * build the table from the first file
            lena = one.length;
            a = 0;
            do {
                if (table[one[a]] === undefined) {
                    table[one[a]] = [1, 0];
                }
                else {
                    table[one[a]][0] = table[one[a]][0] + 1;
                }
                a = a + 1;
            } while (a < lena);
            a = 0;
            b = 0;
            // find all equality... differences are what's left over solve only for the
            // second set test removing reverse test removing undefined checks for table
            // refs
            do {
                c = a;
                d = b;
                if (clean(one[a]) === clean(two[b])) {
                    equality();
                }
                else if (table[one[a]][1] < 1 && table[two[b]][0] < 1) {
                    replaceUniques();
                }
                else if (table[one[a]][1] < 1 && clean(one[a + 1]) !== clean(two[b + 2])) {
                    deletion();
                }
                else if (table[two[b]][0] < 1 && clean(one[a + 2]) !== clean(two[b + 1])) {
                    insertion();
                }
                else if (table[one[a]][0] - table[one[a]][1] === 1 && clean(one[a + 1]) !== clean(two[b + 2])) {
                    deletionStatic();
                }
                else if (table[two[b]][1] - table[two[b]][0] === 1 && clean(one[a + 2]) !== clean(two[b + 1])) {
                    insertionStatic();
                }
                else if (clean(one[a + 1]) === clean(two[b])) {
                    deletion();
                }
                else if (clean(one[a]) === clean(two[b + 1])) {
                    insertion();
                }
                else {
                    replacement();
                }
                a = a + 1;
                b = b + 1;
            } while (a < lena && b < lenb);
            if (lena - a === lenb - b) {
                if (clean(one[a]) === clean(two[b])) {
                    fix(["equal", a, lena, b, lenb]);
                }
                else {
                    fix(["replace", a, lena, b, lenb]);
                }
            }
            else if (a < lena) {
                fix(["delete", a, lena, -1, -1]);
            }
            else if (b < lenb) {
                fix(["insert", -1, -1, b, lenb]);
            }
            return codes;
        };
        let errorout = 0, 
        // diffline is a count of lines that are not equal
        diffline = 0, 
        // tab is a construct of a standard indentation for code
        opcodes = [];
        if (Array.isArray(options.source) === false && typeof options.source !== "string") {
            return ["Error: source value is not a string or array!", 0, 0];
        }
        if (Array.isArray(options.diff) === false && typeof options.diff !== "string") {
            return ["Error: diff value is not a string or array!", 0, 0];
        }
        opcodes = codeBuild();
        // diffview application contains three primary parts
        // 1.  opcodes - performs the 'largest common subsequence'    calculation to
        // determine which lines are different.  I    did not write this logic.  I have
        // rewritten it for    performance, but original logic is still intact.
        // 2.  charcomp - performs the 'largest common subsequence' upon    characters
        // of two compared lines.
        // 3.  The construction of the output into the 'node' array errorout is a count
        // of differences after the opcodes generate the other two core pieces of logic
        // are quaranteened into an anonymous function.
        return (function diffview_report() {
            let a = 0, i = 0, node = ["<div class='diff'>"], diffplural = "s", linesplural = "s", baseStart = 0, baseEnd = 0, newStart = 0, newEnd = 0, rowcnt = 0, rowItem = -1, rcount = 0, foldcount = 0, foldstart = -1, jump = 0, change = "", btest = false, ntest = false, repeat = false, ctest = true, code, baseItem = "", newItem = "", charcompOutput, finaldoc = "";
            const data = [
                [], [], [], []
            ], json = [], clidata = [], tabFix = new RegExp(`^((${tab.replace(/\\/g, "\\")})+)`), noTab = function diffview_report_noTab(str) {
                let b = 0;
                const strLen = str.length, output = [];
                if (strLen < 1) {
                    return output;
                }
                do {
                    output.push(str[b].replace(tabFix, ""));
                    b = b + 1;
                } while (b < strLen);
                return output;
            }, htmlfix = function diffview_report_htmlfix(item) {
                if (item === undefined) {
                    return "";
                }
                return item
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");
            }, baseTab = (tab === "")
                ? []
                : noTab(baseTextArray), newTab = (tab === "")
                ? []
                : noTab(newTextArray), opcodesLength = opcodes.length, 
            // this is the character comparison logic that performs the 'largest common
            // subsequence' between two lines of code
            charcomp = function diffview_report_charcomp(lineA, lineB) {
                let b = 0, currentdiff = [], dataMinLength = 0, dataA = [], dataB = [];
                const cleanedA = (options.diff_format === "text")
                    ? lineA
                    : lineA
                        .replace(/&#160;/g, " ")
                        .replace(/&nbsp;/g, " ")
                        .replace(/&lt;/g, "<")
                        .replace(/&gt;/g, ">")
                        .replace(/\$#lt;/g, "<")
                        .replace(/\$#gt;/g, ">")
                        .replace(/&amp;/g, "&"), cleanedB = (options.diff_format === "text")
                    ? lineB
                    : lineB
                        .replace(/&#160;/g, " ")
                        .replace(/&nbsp;/g, " ")
                        .replace(/&lt;/g, "<")
                        .replace(/&gt;/g, ">")
                        .replace(/\$#lt;/g, "<")
                        .replace(/\$#gt;/g, ">")
                        .replace(/&amp;/g, "&"), regStart = (/_pdiffdiff\u005f/g), regEnd = (/_epdiffdiff\u005f/g), strStart = "_pdiffdiff\u005f", strEnd = "_epdiffdiff\u005f", tabdiff = (function diffview_report_charcomp_tabdiff() {
                    let tabMatchA = "", tabMatchB = "", splitA = "", splitB = "", matchListA = cleanedA.match(tabFix), matchListB = cleanedB.match(tabFix);
                    if (matchListA === null || matchListB === null || (matchListA[0] === "" && matchListA.length === 1) || (matchListB[0] === "" && matchListB.length === 1)) {
                        return ["", "", cleanedA, cleanedB];
                    }
                    tabMatchA = matchListA[0];
                    tabMatchB = matchListB[0];
                    splitA = cleanedA.split(tabMatchA)[1];
                    splitB = cleanedB.split(tabMatchB)[1];
                    if (tabMatchA.length > tabMatchB.length) {
                        tabMatchA = tabMatchA.slice(0, tabMatchB.length) + strStart + tabMatchA.slice(tabMatchB.length) + strEnd;
                    }
                    else {
                        tabMatchB = tabMatchB.slice(0, tabMatchA.length) + strStart + tabMatchB.slice(tabMatchA.length) + strEnd;
                    }
                    return [tabMatchA, tabMatchB, splitA, splitB];
                }()), whiteout = function diffview_report_charcomp_whiteout(whitediff) {
                    const spacetest = (/<((em)|(pd))>\u0020+<\/((em)|(pd))>/), crtest = (/<((em)|(pd))>\r+<\/((em)|(pd))>/);
                    if (spacetest.test(whitediff) === true) {
                        return whitediff;
                    }
                    if (crtest.test(whitediff) === true) {
                        return whitediff.replace(/\s+/, "(carriage return)");
                    }
                    return whitediff.replace(/\s+/, "(white space differences)");
                }, 
                // compare is the fuzzy string comparison algorithm
                compare = function diffview_report_charcomp_compare(start) {
                    let x = 0, y = 0, whitespace = false, wordtest = false, store = [];
                    const max = Math.max(dataA.length, dataB.length), sorta = function diffview_report_charcomp_compare_sorta(a, b) {
                        if (a[1] - a[0] < b[1] - b[0]) {
                            return 1;
                        }
                        return -1;
                    }, sortb = function diffview_report_charcomp_compare_sortb(a, b) {
                        if (a[0] + a[1] > b[0] + b[1]) {
                            return 1;
                        }
                        return -1;
                    }, whitetest = (/^(\s+)$/);
                    // first gather a list of all matching indexes into an array
                    x = start;
                    do {
                        y = start;
                        do {
                            if (dataA[x] === dataB[y] || dataB[x] === dataA[y]) {
                                store.push([x, y]);
                                if (dataA[y] === dataB[x] && dataA[y + 1] === dataB[x + 1] && whitetest.test(dataB[x - 1]) === true) {
                                    wordtest = true;
                                    store = [[x, y]];
                                }
                                if (dataA[x] === dataB[y] && dataA[x + 1] === dataB[y + 1] && whitetest.test(dataB[y - 1]) === true) {
                                    wordtest = true;
                                    store = [[x, y]];
                                }
                                break;
                            }
                            y = y + 1;
                        } while (y < max);
                        if (wordtest === true) {
                            break;
                        }
                        x = x + 1;
                    } while (x < dataMinLength);
                    // if there are no character matches then quit out
                    if (store.length === 0) {
                        return [dataMinLength, max, 0, whitespace];
                    }
                    // take the list of matches and sort it first sort by size of change with
                    // shortest up front second sort by sum of change start and end the second sort
                    // results in the smallest change from the earliest point
                    store.sort(sorta);
                    if (dataMinLength - start < 5000) {
                        store.sort(sortb);
                    }
                    // x should always be the shorter index (change start)
                    if (store[0][0] < store[0][1]) {
                        x = store[0][0];
                        y = store[0][1];
                    }
                    else {
                        y = store[0][0];
                        x = store[0][1];
                    }
                    // package the output
                    if (dataA[y] === dataB[x]) {
                        if (dataA[y - 1] === dataB[x - 1] && x !== start) {
                            x = x - 1;
                            y = y - 1;
                        }
                        if (options.diff_space_ignore === true && ((whitetest.test(dataA[y - 1]) === true && y - start > 0) || (whitetest.test(dataB[x - 1]) === true && x - start > 0))) {
                            whitespace = true;
                        }
                        return [x, y, 0, whitespace];
                    }
                    if (dataA[x] === dataB[y]) {
                        if (dataA[x - 1] === dataB[y - 1] && x !== start) {
                            x = x - 1;
                            y = y - 1;
                        }
                        if (options.diff_space_ignore === true && ((whitetest.test(dataA[x - 1]) === true && x - start > 0) || (whitetest.test(dataB[y - 1]) === true && y - start > 0))) {
                            whitespace = true;
                        }
                        return [x, y, 1, whitespace];
                    }
                };
                // if same after accounting for character entities then exit
                if (cleanedA === cleanedB) {
                    return [lineA, lineB];
                }
                // prevent extra error counting that occurred before entering this function
                errorout = errorout - 1;
                // diff for tabs
                if (tab !== "" && cleanedA
                    .length !== cleanedB
                    .length && cleanedA
                    .replace(tabFix, "") === cleanedB
                    .replace(tabFix, "") && options
                    .diff_space_ignore === false) {
                    errorout = errorout + 1;
                    if (options.diff_format === "text") {
                        tabdiff[0] = tabdiff[0] + tabdiff[2];
                        tabdiff[0] = tabdiff[0].replace(regStart, "<pd>").replace(regEnd, "</pd>");
                        tabdiff[1] = tabdiff[1] + tabdiff[3];
                        tabdiff[1] = tabdiff[1].replace(regStart, "<pd>").replace(regEnd, "</pd>");
                        return [
                            tabdiff[0], tabdiff[1]
                        ];
                    }
                    tabdiff[0] = tabdiff[0] + tabdiff[2];
                    tabdiff[0] = tabdiff[0]
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;")
                        .replace(regStart, "<em>")
                        .replace(regEnd, "</em>");
                    tabdiff[1] = tabdiff[1] + tabdiff[3];
                    tabdiff[1] = tabdiff[1]
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;")
                        .replace(regStart, "<em>")
                        .replace(regEnd, "</em>");
                    return [
                        tabdiff[0], tabdiff[1]
                    ];
                }
                // turn the pruned input into arrays
                dataA = cleanedA.split("");
                dataB = cleanedB.split("");
                // the length of the shortest array
                dataMinLength = Math.min(dataA.length, dataB.length);
                do { // if undefined break the loop
                    if (dataA[b] === undefined || dataB[b] === undefined) {
                        break;
                    }
                    // iterate until the arrays are not the same
                    if (dataA[b] !== dataB[b]) {
                        // fuzzy string comparison returns an array with these indexes 0 - shorter
                        // ending index of difference 1 - longer ending index of difference 2 - 0 if
                        // index 2 is for dataA or 1 for dataB 3 - whether the difference is only
                        // whitespace
                        currentdiff = compare(b);
                        // supply the difference start indicator
                        if (currentdiff[3] === false) { // count each difference
                            errorout = errorout + 1;
                            if (b > 0) {
                                dataA[b - 1] = dataA[b - 1] + strStart;
                                dataB[b - 1] = dataB[b - 1] + strStart;
                            }
                            else {
                                dataA[b] = strStart + dataA[b];
                                dataB[b] = strStart + dataB[b];
                            }
                            // complex decision tree on how to supply difference end indicator
                            if (currentdiff[2] === 1) {
                                if (currentdiff[0] === 0) {
                                    dataA[0] = dataA[0].replace(regStart, strStart + strEnd);
                                }
                                else if (currentdiff[0] === dataMinLength) {
                                    if (dataB.length === dataMinLength) {
                                        dataA[dataA.length - 1] = dataA[dataA.length - 1] + strEnd;
                                    }
                                    else {
                                        dataA[currentdiff[0] - 1] = dataA[currentdiff[0] - 1] + strEnd;
                                    }
                                }
                                else {
                                    if (currentdiff[1] - currentdiff[0] === currentdiff[0]) {
                                        if (dataA[b].indexOf(strStart) > -1) {
                                            dataA[b] = dataA[b] + strEnd;
                                        }
                                        else {
                                            dataA[b] = strEnd + dataA[b];
                                        }
                                    }
                                    else {
                                        if (dataA[currentdiff[0]].indexOf(strStart) > -1) {
                                            dataA[currentdiff[0]] = dataA[currentdiff[0]] + strEnd;
                                        }
                                        else {
                                            dataA[currentdiff[0]] = strEnd + dataA[currentdiff[0]];
                                        }
                                    }
                                }
                                if (currentdiff[1] > dataB.length - 1 || currentdiff[0] === dataMinLength) {
                                    dataB[dataB.length - 1] = dataB[dataB.length - 1] + strEnd;
                                }
                                else if (currentdiff[1] - currentdiff[0] === currentdiff[0]) {
                                    dataB[b + (currentdiff[1] - currentdiff[0])] = dataB[b + (currentdiff[1] - currentdiff[0])] + strEnd;
                                }
                                else {
                                    dataB[currentdiff[1]] = strEnd + dataB[currentdiff[1]];
                                }
                            }
                            else {
                                if (currentdiff[0] === 0) {
                                    dataB[0] = dataB[0].replace(regStart, strStart + strEnd);
                                }
                                else if (currentdiff[0] === dataMinLength) {
                                    if (dataA.length === dataMinLength) {
                                        dataB[dataB.length - 1] = dataB[dataB.length - 1] + strEnd;
                                    }
                                    else {
                                        dataB[currentdiff[0] - 1] = dataB[currentdiff[0] - 1] + strEnd;
                                    }
                                }
                                else {
                                    if (currentdiff[1] - currentdiff[0] === currentdiff[0]) {
                                        if (dataB[b].indexOf(strStart) > -1) {
                                            dataB[b] = dataB[b] + strEnd;
                                        }
                                        else {
                                            dataB[b] = strEnd + dataB[b];
                                        }
                                    }
                                    else {
                                        if (dataB[currentdiff[0]].indexOf(strStart) > -1) {
                                            dataB[currentdiff[0]] = dataB[currentdiff[0]] + strEnd;
                                        }
                                        else {
                                            dataB[currentdiff[0]] = strEnd + dataB[currentdiff[0]];
                                        }
                                    }
                                }
                                if (currentdiff[1] > dataA.length - 1 || currentdiff[0] === dataMinLength) {
                                    dataA[dataA.length - 1] = dataA[dataA.length - 1] + strEnd;
                                }
                                else if (currentdiff[0] - currentdiff[1] === currentdiff[1]) {
                                    dataA[b + (currentdiff[0] - currentdiff[1])] = dataA[b + (currentdiff[0] - currentdiff[1])] + strEnd;
                                }
                                else {
                                    dataA[currentdiff[1]] = strEnd + dataA[currentdiff[1]];
                                }
                            }
                        }
                        // we must rebase the array with the shorter difference so that the end of the
                        // current difference is on the same index.  This provides a common baseline by
                        // which to find the next unmatching index
                        if (currentdiff[1] > currentdiff[0] && currentdiff[1] - currentdiff[0] < 1000) {
                            if (currentdiff[2] === 1) {
                                do {
                                    dataA.unshift("");
                                    currentdiff[0] = currentdiff[0] + 1;
                                } while (currentdiff[1] > currentdiff[0]);
                            }
                            else {
                                do {
                                    dataB.unshift("");
                                    currentdiff[0] = currentdiff[0] + 1;
                                } while (currentdiff[1] > currentdiff[0]);
                            }
                        }
                        // since the previous logic will grow the shorter array we have to redefine the
                        // shortest length
                        dataMinLength = Math.min(dataA.length, dataB.length);
                        // assign the incrementer to the end of the longer difference
                        b = currentdiff[1];
                    }
                    b = b + 1;
                } while (b < dataMinLength);
                // if one array is longer than the other and not identified as different then
                // identify this difference in length
                if (dataA
                    .length > dataB
                    .length && dataB[dataB.length - 1] !== undefined && dataB[dataB.length - 1]
                    .indexOf(strEnd) < 1) {
                    dataB.push(strStart + strEnd);
                    dataA[dataB.length - 1] = strStart + dataA[dataB.length - 1];
                    dataA[dataA.length - 1] = dataA[dataA.length - 1] + strEnd;
                    errorout = errorout + 1;
                }
                if (dataB
                    .length > dataA
                    .length && dataA[dataA.length - 1] !== undefined && dataA[dataA.length - 1]
                    .indexOf(strEnd) < 1) {
                    dataA.push(strStart + strEnd);
                    dataB[dataA.length - 1] = strStart + dataB[dataA.length - 1];
                    dataB[dataB.length - 1] = dataB[dataB.length - 1] + strEnd;
                    errorout = errorout + 1;
                }
                // options.diff_format output doesn't need XML protected characters to be escaped
                // when its value is 'text'
                if (options.diff_format === "text") {
                    return [
                        dataA
                            .join("")
                            .replace(regStart, "<pd>")
                            .replace(regEnd, "</pd>")
                            .replace(/<pd>\s+<\/pd>/g, whiteout)
                            .replace(/\r<\/pd>/g, "(carriage return)</pd>"),
                        dataB
                            .join("")
                            .replace(regStart, "<pd>")
                            .replace(regEnd, "</pd>")
                            .replace(/<pd>\s+<\/pd>/g, whiteout)
                            .replace(/\r<\/pd>/g, "(carriage return)</pd>")
                    ];
                }
                return [
                    dataA
                        .join("")
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;")
                        .replace(regStart, "<em>")
                        .replace(regEnd, "</em>")
                        .replace(/<em>\s+<\/em>/g, whiteout)
                        .replace(/\r<\/em>/g, "(carriage return)</em>"),
                    dataB
                        .join("")
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;")
                        .replace(regStart, "<em>")
                        .replace(regEnd, "</em>")
                        .replace(/<em>\s+<\/em>/g, whiteout)
                        .replace(/\r<\/em>/g, "(carriage return)</em>"),
                ];
            };
            if (options.diff_format === "html") {
                if (options.diff_view === "inline") {
                    node.push("<h3 class='texttitle'>");
                    node.push(options.source_label);
                    node.push(" vs. ");
                    node.push(options.diff_label);
                    node.push("</h3><ol class='count'>");
                }
                else {
                    data[0].push("<div class='diff-left'><h3 class='texttitle'>");
                    data[0].push(options.source_label);
                    data[0].push("</h3><ol class='count'>");
                    data[2].push("<div class='diff-right'><h3 class='texttitle'>");
                    data[2].push(options.diff_label);
                    data[2].push("</h3><ol class='count' style='cursor:w-resize'>");
                }
            }
            else {
                foldstart = 0;
            }
            do {
                code = opcodes[a];
                change = code[0];
                baseStart = code[1];
                baseEnd = code[2];
                newStart = code[3];
                newEnd = code[4];
                rowcnt = Math.max(baseEnd - baseStart, newEnd - newStart);
                ctest = true;
                if (options.diff_format === "json") {
                    i = 0;
                    do {
                        if (change === "insert" && newTextArray[newStart + i] === undefined) {
                            break;
                        }
                        if (change !== "insert" && baseTextArray[baseStart + i] === undefined) {
                            break;
                        }
                        if (change !== "equal") {
                            errorout = errorout + 1;
                        }
                        if (change === "equal") {
                            json.push([
                                "=",
                                baseTextArray[baseStart + i]
                            ]);
                        }
                        else if (change === "replace") {
                            json.push([
                                "r",
                                baseTextArray[baseStart + i],
                                newTextArray[newStart + i]
                            ]);
                        }
                        else if (change === "insert") {
                            json.push([
                                "+",
                                newTextArray[newStart + i]
                            ]);
                        }
                        else {
                            json.push([
                                "-",
                                baseTextArray[baseStart + i]
                            ]);
                        }
                        i = i + 1;
                    } while (i < rowcnt);
                }
                else if (options.diff_format === "text") {
                    const text = {
                        angry: "\u001b[1m\u001b[4m",
                        clear: "\u001b[24m\u001b[22m",
                        cyan: "\u001b[36m",
                        green: "\u001b[32m",
                        none: "\u001b[0m",
                        red: "\u001b[31m"
                    };
                    if (foldstart > 49 && change === "equal") {
                        break;
                    }
                    // this is a check against false positives incurred by increasing or reducing of
                    // nesting.  At this time it only checks one level deep.
                    if (tab !== "") {
                        if (btest === false && baseTextArray[baseEnd] !== newTextArray[newEnd] && typeof baseTextArray[baseStart + 1] === "string" && typeof newTextArray[newStart] === "string" && baseTab[baseStart + 1] === newTab[newStart] && baseTab[baseStart] !== newTab[newStart] && (typeof newTextArray[newStart - 1] !== "string" || baseTab[baseStart] !== newTab[newStart - 1])) {
                            btest = true;
                        }
                        else if (ntest === false && baseTextArray[baseEnd] !== newTextArray[newEnd] && typeof newTextArray[newStart + 1] === "string" && typeof baseTextArray[baseStart] === "string" && newTab[newStart + 1] === baseTab[baseStart] && newTab[newStart] !== baseTab[baseStart] && (typeof baseTextArray[baseStart - 1] !== "string" || newTab[newStart] !== baseTab[baseStart - 1])) {
                            ntest = true;
                        }
                    }
                    if (options
                        .diff_space_ignore === true && change === "replace" && baseTextArray[baseStart] !== undefined && newTextArray[newStart] !== undefined && baseTextArray[baseStart]
                        .replace(/\s+/g, "") === newTextArray[newStart]
                        .replace(/\s+/g, "")) {
                        change = "equal";
                    }
                    else if (change !== "equal") {
                        diffline = diffline + 1;
                        if (a > 0 && opcodes[a - 1][0] === "equal") {
                            foldcount = options.diff_context;
                            if ((ntest === true || change === "insert") && (options.diff_space_ignore === false || (/^(\s+)$/g).test(newTextArray[newStart]) === false)) {
                                foldstart = foldstart + 1;
                                if (options.api === "dom") {
                                    clidata.push("</li><li><h3>Line: ");
                                    clidata.push(String(opcodes[a - 1][2] + 1));
                                    clidata.push("</h3>");
                                }
                                else {
                                    clidata.push("");
                                    clidata.push(`${text.cyan}Line: ${(opcodes[a - 1][2] + 1) + text.none}`);
                                }
                                if (foldcount > 0) {
                                    do {
                                        if (newStart - foldcount > -1) {
                                            if (options.api === "dom") {
                                                clidata.push("<p>");
                                                clidata.push(htmlfix(newTextArray[newStart - foldcount]));
                                                clidata.push("</p>");
                                            }
                                            else {
                                                clidata.push(newTextArray[newStart - foldcount]);
                                            }
                                        }
                                        foldcount = foldcount - 1;
                                    } while (foldcount > 0);
                                }
                            }
                            else {
                                foldstart = foldstart + 1;
                                if (options.api === "dom") {
                                    clidata.push("</li><li><h3>Line: ");
                                    clidata.push(String(baseStart + 1));
                                    clidata.push("</h3>");
                                }
                                else {
                                    clidata.push("");
                                    clidata.push(`${text.cyan}Line: ${(baseStart + 1) + text.none}`);
                                }
                                if (foldcount > 0) {
                                    do {
                                        if (baseStart - foldcount > -1) {
                                            if (options.api === "dom") {
                                                clidata.push("<p>");
                                                clidata.push(htmlfix(baseTextArray[baseStart - foldcount]));
                                                clidata.push("</p>");
                                            }
                                            else {
                                                clidata.push(baseTextArray[baseStart - foldcount]);
                                            }
                                        }
                                        foldcount = foldcount - 1;
                                    } while (foldcount > 0);
                                }
                            }
                        }
                        else if (a < 1) {
                            if (options.api === "dom") {
                                clidata.push("</li><li><h3>Line: 1</h3>");
                            }
                            else {
                                clidata.push("");
                                clidata.push(`${text.cyan}Line: 1${text.none}`);
                            }
                            foldstart = foldstart + 1;
                        }
                        foldcount = 0;
                        if ((ntest === true || change === "insert") && (options.diff_space_ignore === false || (/^(\s+)$/g).test(newTextArray[newStart]) === false)) {
                            do {
                                if (options.api === "dom") {
                                    clidata.push("<ins>");
                                    clidata.push(htmlfix(newTextArray[newStart + foldcount]));
                                    clidata.push("</ins>");
                                }
                                else {
                                    if (newTextArray[newStart + foldcount] === "") {
                                        clidata.push(`${text.green}(empty line)${text.none}`);
                                    }
                                    else {
                                        clidata.push(text.green + newTextArray[newStart + foldcount] + text.none);
                                    }
                                }
                                foldcount = foldcount + 1;
                            } while (foldcount < 7 && foldcount + newStart < newEnd);
                        }
                        else if (change === "delete" && (options.diff_space_ignore === false || (/^(\s+)$/g).test(baseTextArray[baseStart]) === false)) {
                            do {
                                if (options.api === "dom") {
                                    clidata.push("<del>");
                                    clidata.push(htmlfix(baseTextArray[baseStart + foldcount]));
                                    clidata.push("</del>");
                                }
                                else {
                                    if (baseTextArray[baseStart + foldcount] === "") {
                                        clidata.push(`${text.red}(empty line)${text.none}`);
                                    }
                                    else {
                                        clidata.push(text.red + baseTextArray[baseStart + foldcount] + text.none);
                                    }
                                }
                                foldcount = foldcount + 1;
                            } while (foldcount < 7 && foldcount + baseStart < baseEnd);
                        }
                        else if (change === "replace" && (options
                            .diff_space_ignore === false || baseTextArray[baseStart]
                            .replace(/\s+/g, "") !== newTextArray[newStart]
                            .replace(/\s+/g, ""))) {
                            do {
                                charcompOutput = charcomp(baseTextArray[baseStart + foldcount], newTextArray[newStart + foldcount]);
                                if (options.api === "dom") {
                                    clidata.push("<del>");
                                    clidata.push(htmlfix(charcompOutput[0]).replace(/&lt;pd&gt;/g, "<em>").replace(/&lt;\/pd&gt;/g, "</em>"));
                                    clidata.push("</del><ins>");
                                    clidata.push(htmlfix(charcompOutput[1]).replace(/&lt;pd&gt;/g, "<em>").replace(/&lt;\/pd&gt;/g, "</em>"));
                                    clidata.push("</ins>");
                                }
                                else {
                                    if (charcompOutput[0] === "") {
                                        clidata.push(`${text.red}(empty line)${text.none}`);
                                    }
                                    else if ((/^\s+$/).test(charcompOutput[0]) === true) {
                                        clidata.push(`${text.red}(white space)${text.none}`);
                                    }
                                    else {
                                        clidata.push(text
                                            .red + charcompOutput[0]
                                            .replace(/<pd><\/pd>/g, "")
                                            .replace(/<pd>/g, text.angry)
                                            .replace(/<\/pd>/g, text.clear)
                                            .replace(/\s+$/, "") + text
                                            .none);
                                    }
                                    if (charcompOutput[1] === "") {
                                        clidata.push(`${text.green}(empty line)${text.none}`);
                                    }
                                    else if ((/^\s+$/).test(charcompOutput[1]) === true) {
                                        clidata.push(`${text.green}(white space)${text.none}`);
                                    }
                                    else {
                                        clidata.push(text
                                            .green + charcompOutput[1]
                                            .replace(/<pd><\/pd>/g, "")
                                            .replace(/<pd>/g, text.angry)
                                            .replace(/<\/pd>/g, text.clear)
                                            .replace(/\s+$/, "") + text
                                            .none);
                                    }
                                }
                                foldcount = foldcount + 1;
                            } while (foldcount < 7 && foldcount + baseStart < baseEnd);
                        }
                        if (((change === "insert" && foldcount + newStart === newEnd) || (change !== "insert" && foldcount + baseStart === baseEnd)) && baseTextArray[baseStart + foldcount] !== undefined && options.diff_context > 0 && a < opcodesLength - 1 && opcodes[a + 1][0] === "equal") {
                            foldcount = 0;
                            baseStart = opcodes[a + 1][1];
                            baseEnd = opcodes[a + 1][2] - baseStart;
                            do {
                                if (options.api === "dom") {
                                    clidata.push("<p>");
                                    clidata.push(htmlfix(baseTextArray[baseStart + foldcount]));
                                    clidata.push("</p>");
                                }
                                else {
                                    clidata.push(baseTextArray[baseStart + foldcount]);
                                }
                                foldcount = foldcount + 1;
                            } while (foldcount < options.diff_context && foldcount < baseEnd);
                        }
                        if (btest === true) {
                            baseStart = baseStart + 1;
                            btest = false;
                        }
                        else if (ntest === true) {
                            newStart = newStart + 1;
                            ntest = false;
                        }
                        else {
                            baseStart = baseStart + 1;
                            newStart = newStart + 1;
                        }
                    }
                }
                else {
                    if (foldstart > -1) {
                        data[0][foldstart] = data[0][foldstart].replace("xxx", String(foldcount));
                    }
                    i = 0;
                    do { // apply options.diff_context collapsing for the output, if needed
                        if (options.diff_context > -1 && opcodes.length > 1 && ((a > 0 && i === options.diff_context) || (a === 0 && i === 0)) && change === "equal") {
                            ctest = false;
                            jump = rowcnt - ((a === 0
                                ? 1
                                : 2) * options.diff_context);
                            if (jump > 1) {
                                baseStart = baseStart + jump;
                                newStart = newStart + jump;
                                i = i + (jump - 1);
                                data[0].push("<li>...</li>");
                                if (options.diff_view !== "inline") {
                                    data[1].push("<li class=\"skip\">&#10;</li>");
                                }
                                data[2].push("<li>...</li>");
                                data[3].push("<li class=\"skip\">&#10;</li>");
                                if (a + 1 === opcodes.length) {
                                    break;
                                }
                            }
                        }
                        else if (change !== "equal") {
                            diffline = diffline + 1;
                        }
                        if (options.api === "dom" && baseTextArray[baseStart] !== undefined) {
                            baseItem = baseTextArray[baseStart].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        }
                        else {
                            baseItem = baseTextArray[baseStart];
                        }
                        if (options.api === "dom" && newTextArray[newStart] !== undefined) {
                            newItem = newTextArray[newStart].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        }
                        else {
                            newItem = newTextArray[newStart];
                        }
                        // this is a check against false positives incurred by increasing or reducing of
                        // nesting.  At this time it only checks one level deep.
                        if (tab !== "") {
                            if (btest === false && baseTextArray[baseEnd] !== newTextArray[newEnd] && typeof baseTextArray[baseStart + 1] === "string" && typeof newItem === "string" && baseTab[baseStart + 1] === newTab[newStart] && baseTab[baseStart] !== newTab[newStart] && (typeof newTextArray[newStart - 1] !== "string" || baseTab[baseStart] !== newTab[newStart - 1])) {
                                btest = true;
                            }
                            else if (ntest === false && baseTextArray[baseEnd] !== newTextArray[newEnd] && typeof newTextArray[newStart + 1] === "string" && typeof baseItem === "string" && newTab[newStart + 1] === baseTab[baseStart] && newTab[newStart] !== baseTab[baseStart] && (typeof baseTextArray[baseStart - 1] !== "string" || newTab[newStart] !== baseTab[baseStart - 1])) {
                                ntest = true;
                            }
                        }
                        foldcount = foldcount + 1;
                        if (options.diff_view === "inline") {
                            if (options
                                .diff_space_ignore === true && change === "replace" && baseItem
                                .replace(/\s+/g, "") === newItem
                                .replace(/\s+/g, "")) {
                                change = "equal";
                                errorout = errorout - 1;
                            }
                            if (options.diff_context < 0 && rowItem < a) {
                                rowItem = a;
                                if (foldstart > -1) {
                                    if (data[0][foldstart + 1] === String(foldcount - 1)) {
                                        data[0][foldstart] = `<li class="${data[0][foldstart].slice(data[0][foldstart].indexOf("line xxx\">- ") + 12)}`;
                                    }
                                    else {
                                        data[0][foldstart] = data[0][foldstart].replace("xxx", String(foldcount - 1 + rcount));
                                    }
                                }
                                if (change !== "replace") {
                                    if (baseEnd - baseStart > 1 || newEnd - newStart > 1) {
                                        data[0].push(`<li class="fold" title="folds from line ${foldcount + rcount} to line xxx">- `);
                                        foldstart = data[0].length - 1;
                                    }
                                    else {
                                        data[0].push("<li>");
                                    }
                                    if (ntest === true || change === "insert") {
                                        data[0].push("&#10;");
                                    }
                                    else {
                                        data[0].push(String(baseStart + 1));
                                    }
                                    data[0].push("</li>");
                                }
                                else {
                                    rcount = rcount + 1;
                                }
                            }
                            else if (change !== "replace") {
                                data[0].push("<li>");
                                if (ntest === true || change === "insert") {
                                    data[0].push("&#10;");
                                }
                                else {
                                    data[0].push(String(baseStart + 1));
                                }
                                data[0].push("</li>");
                            }
                            else if (change === "replace") {
                                rcount = rcount + 1;
                            }
                            if (ntest === true || change === "insert") {
                                data[2].push("<li>");
                                data[2].push(String(newStart + 1));
                                data[2].push("&#10;</li>");
                                if (options.diff_space_ignore === true && newItem.replace(/\s+/g, "") === "") {
                                    data[3].push("<li class=\"equal\">");
                                    diffline = diffline - 1;
                                }
                                else {
                                    data[3].push("<li class=\"insert\">");
                                }
                                data[3].push(newItem);
                                data[3].push("&#10;</li>");
                            }
                            else if (btest === true || change === "delete") {
                                data[2].push("<li class=\"empty\">&#10;</li>");
                                if (options.diff_space_ignore === true && baseItem.replace(/\s+/g, "") === "") {
                                    data[3].push("<li class=\"equal\">");
                                    diffline = diffline - 1;
                                }
                                else {
                                    data[3].push("<li class=\"delete\">");
                                }
                                data[3].push(baseItem);
                                data[3].push("&#10;</li>");
                            }
                            else if (change === "replace") {
                                if (baseItem !== newItem) {
                                    if (baseItem === "") {
                                        charcompOutput = [
                                            "", newItem
                                        ];
                                    }
                                    else if (newItem === "") {
                                        charcompOutput = [baseItem, ""];
                                    }
                                    else if (baseStart < baseEnd && newStart < newEnd) {
                                        charcompOutput = charcomp(baseTextArray[baseStart], newTextArray[newStart]);
                                    }
                                }
                                if (baseStart < baseEnd) {
                                    data[0].push(`<li>${baseStart + 1}</li>`);
                                    data[2].push("<li class=\"empty\">&#10;</li>");
                                    if (options.diff_space_ignore === true && baseItem.replace(/\s+/g, "") === "") {
                                        data[3].push("<li class=\"equal\">");
                                        diffline = diffline - 1;
                                    }
                                    else {
                                        data[3].push("<li class=\"delete\">");
                                    }
                                    if (newStart < newEnd) {
                                        data[3].push(charcompOutput[0]);
                                    }
                                    else {
                                        data[3].push(baseItem);
                                    }
                                    data[3].push("&#10;</li>");
                                }
                                if (newStart < newEnd) {
                                    data[0].push("<li class=\"empty\">&#10;</li>");
                                    data[2].push("<li>");
                                    data[2].push(String(newStart + 1));
                                    data[2].push("</li>");
                                    if (options.diff_space_ignore === true && newItem.replace(/\s+/g, "") === "") {
                                        data[3].push("<li class=\"equal\">");
                                        diffline = diffline - 1;
                                    }
                                    else {
                                        data[3].push("<li class=\"insert\">");
                                    }
                                    if (baseStart < baseEnd) {
                                        data[3].push(charcompOutput[1]);
                                    }
                                    else {
                                        data[3].push(newItem);
                                    }
                                    data[3].push("&#10;</li>");
                                }
                            }
                            else if (baseStart < baseEnd || newStart < newEnd) {
                                data[2].push("<li>");
                                data[2].push(String(newStart + 1));
                                data[2].push("</li>");
                                data[3].push("<li class=\"");
                                data[3].push(change);
                                data[3].push("\">");
                                data[3].push(baseItem);
                                data[3].push("&#10;</li>");
                            }
                            if (btest === true) {
                                baseStart = baseStart + 1;
                                btest = false;
                            }
                            else if (ntest === true) {
                                newStart = newStart + 1;
                                ntest = false;
                            }
                            else {
                                baseStart = baseStart + 1;
                                newStart = newStart + 1;
                            }
                        }
                        else {
                            if (btest === false && ntest === false && typeof baseItem === "string" && typeof newItem === "string") {
                                if (change === "replace" && baseStart < baseEnd && newStart < newEnd && baseItem !== newItem) {
                                    charcompOutput = charcomp(baseTextArray[baseStart], newTextArray[newStart]);
                                }
                                else if (options.api === "dom") {
                                    charcompOutput = [
                                        baseTextArray[baseStart].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"),
                                        newTextArray[newStart].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
                                    ];
                                }
                                else {
                                    charcompOutput = [
                                        baseTextArray[baseStart], newTextArray[newStart]
                                    ];
                                }
                                if ((data[0].length > 0 && baseStart === Number(data[0][data[0].length - 1].slice(data[0][data[0].length - 1].indexOf(">") + 1, data[0][data[0].length - 1].lastIndexOf("<"))) - 1) || (data[2].length > 0 && newStart === Number(data[2][data[2].length - 1].slice(data[2][data[2].length - 1].indexOf(">") + 1, data[2][data[2].length - 1].lastIndexOf("<"))) - 1)) {
                                    repeat = true;
                                }
                                if (repeat === false) {
                                    if (baseStart < baseEnd) {
                                        if (options.diff_context < 0 && rowItem < a && (opcodes[a][2] - opcodes[a][1] > 1 || opcodes[a][4] - opcodes[a][3] > 1)) {
                                            rowItem = a;
                                            data[0].push(`<li class="fold" title="folds from line ${foldcount} to line xxx">- ${baseStart + 1}</li>`);
                                            foldstart = data[0].length - 1;
                                        }
                                        else {
                                            data[0].push(`<li>${baseStart + 1}</li>`);
                                        }
                                        data[1].push("<li class=\"");
                                        if (newStart >= newEnd) {
                                            if (options.diff_space_ignore === true && baseItem.replace(/\s+/g, "") === "") {
                                                data[1].push("equal");
                                                diffline = diffline - 1;
                                            }
                                            else {
                                                data[1].push("delete");
                                            }
                                        }
                                        else if (baseItem === "" && newItem !== "" && (options.diff_space_ignore === false || (baseItem.replace(/\s+/g, "") !== "" && newItem.replace(/\s+/g, "") !== ""))) {
                                            data[1].push("empty");
                                        }
                                        else {
                                            data[1].push(change);
                                        }
                                        data[1].push("\">");
                                        data[1].push(charcompOutput[0]);
                                        data[1].push("&#10;</li>");
                                    }
                                    else if (ctest === true) {
                                        if (options.diff_context < 0 && rowItem < a && (opcodes[a][2] - opcodes[a][1] > 1 || opcodes[a][4] - opcodes[a][3])) {
                                            rowItem = a;
                                            if (foldstart > -1) {
                                                data[0][foldstart] = data[0][foldstart].replace("xxx", String(foldcount - 1));
                                            }
                                            data[0].push(`<li class="fold" title="folds from line ${foldcount} to line xxx">- &#10;</li>`);
                                            foldstart = data[0].length - 1;
                                        }
                                        else {
                                            data[0].push("<li class=\"empty\">&#10;</li>");
                                        }
                                        data[1].push("<li class=\"empty\"></li>");
                                    }
                                    if (newStart < newEnd) {
                                        data[2].push(`<li>${newStart + 1}</li>`);
                                        data[3].push("<li class=\"");
                                        if (baseStart >= baseEnd) {
                                            if (options.diff_space_ignore === true && newItem.replace(/\s+/g, "") === "") {
                                                data[3].push("equal");
                                                diffline = diffline - 1;
                                            }
                                            else {
                                                data[3].push("insert");
                                            }
                                        }
                                        else if (newItem === "" && baseItem !== "" && (options.diff_space_ignore === false || (baseItem.replace(/\s+/g, "") !== "" && newItem.replace(/\s+/g, "") !== ""))) {
                                            data[3].push("empty");
                                        }
                                        else {
                                            data[3].push(change);
                                        }
                                        data[3].push("\">");
                                        data[3].push(charcompOutput[1]);
                                        data[3].push("&#10;</li>");
                                    }
                                    else if (ctest === true) {
                                        data[2].push("<li class=\"empty\">&#10;</li>");
                                        data[3].push("<li class=\"empty\"></li>");
                                    }
                                }
                                else {
                                    repeat = false;
                                }
                                if (baseStart < baseEnd) {
                                    baseStart = baseStart + 1;
                                }
                                if (newStart < newEnd) {
                                    newStart = newStart + 1;
                                }
                            }
                            else if (btest === true || (typeof baseItem === "string" && typeof newItem !== "string")) {
                                if (baseStart !== -1 && data[0].length > 0 && baseStart !== Number(data[0][data[0].length - 1].slice(data[0][data[0].length - 1].indexOf(">") + 1, data[0][data[0].length - 1].lastIndexOf("<"))) - 1) {
                                    if (options.diff_context < 0 && rowItem < a && opcodes[a][2] - opcodes[a][1] > 1) {
                                        rowItem = a;
                                        data[0].push(`<li class="fold" title="folds from line ${foldcount} to line xxx">- ${baseStart + 1}</li>`);
                                        foldstart = data[0].length - 1;
                                    }
                                    else {
                                        data[0].push(`<li>${baseStart + 1}</li>`);
                                    }
                                    data[1].push("<li class=\"delete\">");
                                    data[1].push(baseItem);
                                    data[1].push("&#10;</li>");
                                    data[2].push("<li class=\"empty\">&#10;</li>");
                                    data[3].push("<li class=\"empty\"></li>");
                                }
                                btest = false;
                                baseStart = baseStart + 1;
                            }
                            else if (ntest === true || (typeof baseItem !== "string" && typeof newItem === "string")) {
                                if (newStart !== -1 && data[2].length > 0 && newStart !== Number(data[2][data[2].length - 1].slice(data[2][data[2].length - 1].indexOf(">") + 1, data[2][data[2].length - 1].lastIndexOf("<"))) - 1) {
                                    if (options.diff_context < 0 && rowItem < a && opcodes[a][4] - opcodes[a][3] > 1) {
                                        rowItem = a;
                                        data[0].push(`<li class="fold" title="folds from line ${foldcount} to line xxx">-</li>`);
                                        foldstart = data[0].length - 1;
                                    }
                                    else {
                                        data[0].push("<li class=\"empty\">&#10;</li>");
                                    }
                                    data[1].push("<li class=\"empty\"></li>");
                                    data[2].push(`<li>${newStart + 1}</li>`);
                                    data[3].push("<li class=\"insert\">");
                                    data[3].push(newItem);
                                    data[3].push("&#10;</li>");
                                }
                                ntest = false;
                                newStart = newStart + 1;
                            }
                        }
                        i = i + 1;
                    } while (i < rowcnt);
                }
                a = a + 1;
            } while (a < opcodesLength);
            if (options.diff_format === "json") {
                return [
                    JSON.stringify({ diff: json })
                        .replace(/\$#gt;/g, "&gt;")
                        .replace(/\$#lt;/g, "&lt;")
                        .replace(/%#lt;/g, "$#lt;")
                        .replace(/%#gt;/g, "$#gt;"),
                    errorout,
                    0
                ];
            }
            if (options.diff_format === "text") {
                if (options.api === "dom") {
                    clidata.push("</li></ol>");
                    return [
                        clidata.join("").replace("</li>", "<ol class=\"diffcli\">"),
                        foldstart,
                        diffline
                    ];
                }
                if (options.crlf === true) {
                    return [clidata.join("\r\n"), foldstart, diffline];
                }
                return [clidata.join("\n"), foldstart, diffline];
            }
            if (foldstart > -1) {
                data[0][foldstart] = data[0][foldstart].replace("xxx", String(foldcount + rcount));
            }
            node.push(data[0].join(""));
            node.push("</ol><ol class=");
            if (options.diff_view === "inline") {
                node.push("\"count\">");
            }
            else {
                node.push("\"data\" data-prettydiff-ignore=\"true\">");
                node.push(data[1].join(""));
                node.push("</ol></div>");
            }
            node.push(data[2].join(""));
            node.push("</ol><ol class=\"data\" data-prettydiff-ignore=\"true\">");
            node.push(data[3].join(""));
            if (options.diff_view === "inline") {
                node.push("</ol>");
            }
            else {
                node.push("</ol></div>");
            }
            node.push("<p class=\"author\">Diff view written by <a href=\"https://prettydiff.com/\">Pr" + "etty Diff</a>.</p></div>");
            if (errorout === 1) {
                diffplural = "";
            }
            if (diffline === 1) {
                linesplural = "";
            }
            finaldoc = `<p><strong>Number of differences:</strong> <em>${errorout + diffline}</em> difference${diffplural} from <em>${diffline}</em> line${linesplural} of code.</p>${node.join("")}`;
            return [
                finaldoc
                    .replace(/li\u0020class="equal"><\/li/g, "li class=\"equal\">&#10;</li")
                    .replace(/\$#gt;/g, "&gt;")
                    .replace(/\$#lt;/g, "&lt;")
                    .replace(/%#lt;/g, "$#lt;")
                    .replace(/%#gt;/g, "$#gt;"),
                errorout,
                diffline
            ];
        }());
    };
    prettydiff.api
        .diffview = diffview;
}());
(function finalFile_init() {
    const finalFile = {
        css: {
            color: {
                canvas: "#prettydiff.canvas{background:#986 url(\"data:image/png;base64,iVBORw0KGgoAAAANS" +
                    "UhEUgAAAAQAAAAECAIAAAAmkwkpAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKT2lDQ1BQaG90b3Nob3AgS" +
                    "UNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG" +
                    "8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeE" +
                    "eCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0k" +
                    "ThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEA" +
                    "Gg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8" +
                    "lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg" +
                    "/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQ" +
                    "LUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0T" +
                    "KUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+A" +
                    "XuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAAR" +
                    "KCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uw" +
                    "lW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIH" +
                    "fI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2" +
                    "o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMW" +
                    "E7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxp" +
                    "FTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlE" +
                    "OU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol" +
                    "9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKC" +
                    "pVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/" +
                    "YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZ" +
                    "j8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx" +
                    "0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p" +
                    "/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJ" +
                    "gYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnut" +
                    "rxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw" +
                    "+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF" +
                    "2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ" +
                    "+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT" +
                    "8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoy" +
                    "OyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85r" +
                    "y1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFp" +
                    "xapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlL" +
                    "OW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQr" +
                    "AVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5s" +
                    "jxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1Y" +
                    "fqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9Wt" +
                    "O319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7Jv" +
                    "ttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vd" +
                    "y0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R" +
                    "9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4d" +
                    "PKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b" +
                    "/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DB" +
                    "Y+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv2" +
                    "8bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEFdaVRYd" +
                    "FhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIe" +
                    "nJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrP" +
                    "SJBZG9iZSBYTVAgQ29yZSA1LjYtYzAxNCA3OS4xNTY3OTcsIDIwMTQvMDgvMjAtMDk6NTM6MDIgICAgI" +
                    "CAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZ" +
                    "GYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgI" +
                    "CAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sb" +
                    "nM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICAgICAgICAgIHhtbG5zO" +
                    "nN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgI" +
                    "CAgICAgICAgIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb" +
                    "3VyY2VSZWYjIgogICAgICAgICAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzL" +
                    "zEuMS8iCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b" +
                    "3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmL" +
                    "zEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvI" +
                    "j4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b" +
                    "3NoKTwveG1wOkNyZWF0b3JUb29sPgogICAgICAgICA8eG1wOkNyZWF0ZURhdGU+MjAxNi0wMS0xMlQxM" +
                    "joyNDozOC0wNjowMDwveG1wOkNyZWF0ZURhdGU+CiAgICAgICAgIDx4bXA6TWV0YWRhdGFEYXRlPjIwM" +
                    "TYtMDEtMTNUMTM6MTg6MDctMDY6MDA8L3htcDpNZXRhZGF0YURhdGU+CiAgICAgICAgIDx4bXA6TW9ka" +
                    "WZ5RGF0ZT4yMDE2LTAxLTEzVDEzOjE4OjA3LTA2OjAwPC94bXA6TW9kaWZ5RGF0ZT4KICAgICAgICAgP" +
                    "HhtcE1NOkluc3RhbmNlSUQ+eG1wLmlpZDoxZGYzYjhkMy03NzgyLTQ0MGUtYjA5OS1iYjM5NjA0MDVhO" +
                    "WQ8L3htcE1NOkluc3RhbmNlSUQ+CiAgICAgICAgIDx4bXBNTTpEb2N1bWVudElEPmFkb2JlOmRvY2lkO" +
                    "nBob3Rvc2hvcDoxYzM3NjE4MS1mOWU4LTExNzgtOWE5Yy1kODI1ZGZiMGE0NzA8L3htcE1NOkRvY3VtZ" +
                    "W50SUQ+CiAgICAgICAgIDx4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+eG1wLmRpZDo2YjI0ZTI3YS1jZ" +
                    "jA3LTQ5ZDEtOWIwZC02ODEzMTFkNzQwMzE8L3htcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgI" +
                    "CAgPHhtcE1NOkhpc3Rvcnk+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmO" +
                    "mxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvb" +
                    "j5jcmVhdGVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEP" +
                    "nhtcC5paWQ6NmIyNGUyN2EtY2YwNy00OWQxLTliMGQtNjgxMzExZDc0MDMxPC9zdEV2dDppbnN0YW5jZ" +
                    "UlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE2LTAxLTEyVDEyOjI0OjM4LTA2OjAwP" +
                    "C9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQa" +
                    "G90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgI" +
                    "CAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY" +
                    "2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgI" +
                    "CAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6ZDUzYzc4NDMtYTVmMi00ODQ3L" +
                    "ThjNDMtNmUyYzBhNDY4YmViPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFd" +
                    "nQ6d2hlbj4yMDE2LTAxLTEyVDEyOjI0OjM4LTA2OjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgI" +
                    "CAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoK" +
                    "Twvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc" +
                    "3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6b" +
                    "GkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uP" +
                    "mRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y" +
                    "29udmVydGVkIGZyb20gaW1hZ2UvcG5nIHRvIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3A8L" +
                    "3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8c" +
                    "mRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjd" +
                    "Glvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJR" +
                    "D54bXAuaWlkOjgzYTc5MGFkLWMwZWQtNGIzYS05ZDJhLWE5YzQ2MWRmMzVhMTwvc3RFdnQ6aW5zdGFuY" +
                    "2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNi0wMS0xM1QxMzoxMzoyMy0wNjowM" +
                    "Dwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgU" +
                    "GhvdG9zaG9wIENDIDIwMTQgKE1hY2ludG9zaCk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgI" +
                    "CAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvc" +
                    "mRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgI" +
                    "CAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5kZXJpdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgI" +
                    "CAgICAgICAgIDxzdEV2dDpwYXJhbWV0ZXJzPmNvbnZlcnRlZCBmcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZ" +
                    "G9iZS5waG90b3Nob3AgdG8gaW1hZ2UvcG5nPC9zdEV2dDpwYXJhbWV0ZXJzPgogICAgICAgICAgICAgI" +
                    "CA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+C" +
                    "iAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgI" +
                    "CAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDoxZGYzYjhkMy03NzgyLTQ0MGUtYjA5O" +
                    "S1iYjM5NjA0MDVhOWQ8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3a" +
                    "GVuPjIwMTYtMDEtMTNUMTM6MTg6MDctMDY6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgI" +
                    "DxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE0IChNYWNpbnRvc2gpPC9zd" +
                    "EV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2d" +
                    "DpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogI" +
                    "CAgICAgICA8L3htcE1NOkhpc3Rvcnk+CiAgICAgICAgIDx4bXBNTTpEZXJpdmVkRnJvbSByZGY6cGFyc" +
                    "2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgIDxzdFJlZjppbnN0YW5jZUlEPnhtcC5paWQ6ODNhN" +
                    "zkwYWQtYzBlZC00YjNhLTlkMmEtYTljNDYxZGYzNWExPC9zdFJlZjppbnN0YW5jZUlEPgogICAgICAgI" +
                    "CAgICA8c3RSZWY6ZG9jdW1lbnRJRD54bXAuZGlkOjgzYTc5MGFkLWMwZWQtNGIzYS05ZDJhLWE5YzQ2M" +
                    "WRmMzVhMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lb" +
                    "nRJRD54bXAuZGlkOjZiMjRlMjdhLWNmMDctNDlkMS05YjBkLTY4MTMxMWQ3NDAzMTwvc3RSZWY6b3JpZ" +
                    "2luYWxEb2N1bWVudElEPgogICAgICAgICA8L3htcE1NOkRlcml2ZWRGcm9tPgogICAgICAgICA8ZGM6Z" +
                    "m9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8cGhvdG9zaG9wOkNvbG9yTW9kZT4zP" +
                    "C9waG90b3Nob3A6Q29sb3JNb2RlPgogICAgICAgICA8cGhvdG9zaG9wOklDQ1Byb2ZpbGU+c1JHQiBJR" +
                    "UM2MTk2Ni0yLjE8L3Bob3Rvc2hvcDpJQ0NQcm9maWxlPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvb" +
                    "j4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpYUmVzb2x1dGlvbj4zMDAwMDAwLzEwM" +
                    "DAwPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj4zMDAwMDAwLzEwM" +
                    "DAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmO" +
                    "lJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZ" +
                    "T4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjQ8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogI" +
                    "CAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+NDwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgI" +
                    "DwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "AogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgC" +
                    "iAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "AogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgC" +
                    "iAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+bleIyQAAA" +
                    "CBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAANElEQVR42mJ89+4uAwMDA" +
                    "wPD6lkTGd69u/vu3d2ZHXnv3t1lgLPevbvLrCTIEJqWD1EJGADaTRll80WcLAAAAABJRU5ErkJggg==" +
                    "\");color:#420}#prettydiff.canvas *:focus{outline:0.1em dashed #f00}#prettydiff." +
                    "canvas a{color:#039}#prettydiff.canvas .contentarea,#prettydiff.canvas .data li," +
                    "#prettydiff.canvas .diff td,#prettydiff.canvas .diff-right,#prettydiff.canvas .r" +
                    "eport td,#prettydiff.canvas fieldset input,#prettydiff.canvas fieldset select,#p" +
                    "rettydiff.canvas legend{background:#eeeee8;border-color:#420}#prettydiff.canvas " +
                    "#report,#prettydiff.canvas #report .author,#prettydiff.canvas .beautify,#prettyd" +
                    "iff.canvas .beautify h3,#prettydiff.canvas .beautify h4,#prettydiff.canvas .diff" +
                    ",#prettydiff.canvas .diff h3,#prettydiff.canvas .diff h4,#prettydiff.canvas .rep" +
                    "ort,#prettydiff.canvas fieldset,#prettydiff.canvas input,#prettydiff.canvas sele" +
                    "ct{background:#ddddd8;border-color:#420}#prettydiff.canvas fieldset fieldset{bac" +
                    "kground:#eeeee8}#prettydiff.canvas fieldset fieldset input,#prettydiff.canvas fi" +
                    "eldset fieldset select{background:#ddddd8}#prettydiff.canvas h2,#prettydiff.canv" +
                    "as h2 button,#prettydiff.canvas h3,#prettydiff.canvas legend{color:#900}#prettyd" +
                    "iff.canvas #addOptions .disabled{background:#ccbbb8;color:#300}#prettydiff.canva" +
                    "s .contentarea{box-shadow:0 1em 1em #b8a899}#prettydiff.canvas .segment{backgrou" +
                    "nd:#fff}#prettydiff.canvas .options li,#prettydiff.canvas .segment,#prettydiff.c" +
                    "anvas h2 button,#prettydiff.canvas ol.segment li,#prettydiff.canvas th{border-co" +
                    "lor:#420}#prettydiff.canvas th{background:#e8ddcc}#prettydiff.canvas li h4{color" +
                    ":#06f}#prettydiff.canvas code{background:#eee;border-color:#eee;color:#00f}#pret" +
                    "tydiff.canvas ol.segment h4 strong{color:#c00}#prettydiff.canvas button{backgrou" +
                    "nd-color:#ddddd8;border-color:#420;box-shadow:0 0.25em 0.5em #b8a899;color:#900}" +
                    "#prettydiff.canvas button:hover{background-color:#ccb;border-color:#630;box-shad" +
                    "ow:0 0.25em 0.5em #b8a899;color:#630}#prettydiff.canvas td.nested{background:#cc" +
                    "ccc8}#prettydiff.canvas th,#prettydiff.canvas th.nested{background:#ddddd8}#pret" +
                    "tydiff.canvas tr:hover{background:#eee8ee}#prettydiff.canvas th.heading,#prettyd" +
                    "iff.canvas thead th,#prettydiff.canvas tr.header th{background:#ddc}#prettydiff." +
                    "canvas .diff h3{background:#ddd;border-color:#999}#prettydiff.canvas .count li,#" +
                    "prettydiff.canvas .data li,#prettydiff.canvas .data li span,#prettydiff.canvas ." +
                    "diff-right,#prettydiff.canvas .segment,#prettydiff.canvas td{border-color:#ccccc" +
                    "8}#prettydiff.canvas .count{background:#eed;border-color:#999}#prettydiff.canvas" +
                    " .count li.fold{color:#900}#prettydiff.canvas h2 button{background:#f8f8f8;box-s" +
                    "hadow:0.1em 0.1em 0.25em #ddd}#prettydiff.canvas li h4,#prettydiff.canvas li h5{" +
                    "color:#06c}#prettydiff.canvas code{background:#eee;border-color:#eee;color:#009}" +
                    "#prettydiff.canvas ol.segment h4 strong{color:#c00}#prettydiff.canvas .data .del" +
                    "ete{background:#ffd8d8}#prettydiff.canvas .data .delete em{background:#fff8f8;bo" +
                    "rder-color:#c44;color:#900}#prettydiff.canvas .data .insert{background:#d8ffd8}#" +
                    "prettydiff.canvas .data .insert em{background:#f8fff8;border-color:#090;color:#3" +
                    "63}#prettydiff.canvas .data .replace{background:#fec}#prettydiff.canvas .data .r" +
                    "eplace em{background:#ffe;border-color:#a86;color:#852}#prettydiff.canvas .data " +
                    ".empty{background:#ddd}#prettydiff.canvas .data em.s0{border-color:#000;color:#0" +
                    "00}#prettydiff.canvas .data em.s1{border-color:#f66;color:#f66}#prettydiff.canva" +
                    "s .data em.s2{border-color:#12f;color:#12f}#prettydiff.canvas .data em.s3{border" +
                    "-color:#090;color:#090}#prettydiff.canvas .data em.s4{border-color:#d6d;color:#d" +
                    "6d}#prettydiff.canvas .data em.s5{border-color:#7cc;color:#7cc}#prettydiff.canva" +
                    "s .data em.s6{border-color:#c85;color:#c85}#prettydiff.canvas .data em.s7{border" +
                    "-color:#737;color:#737}#prettydiff.canvas .data em.s8{border-color:#6d0;color:#6" +
                    "d0}#prettydiff.canvas .data em.s9{border-color:#dd0;color:#dd0}#prettydiff.canva" +
                    "s .data em.s10{border-color:#893;color:#893}#prettydiff.canvas .data em.s11{bord" +
                    "er-color:#b97;color:#b97}#prettydiff.canvas .data em.s12{border-color:#bbb;color" +
                    ":#bbb}#prettydiff.canvas .data em.s13{border-color:#cc3;color:#cc3}#prettydiff.c" +
                    "anvas .data em.s14{border-color:#333;color:#333}#prettydiff.canvas .data em.s15{" +
                    "border-color:#9d9;color:#9d9}#prettydiff.canvas .data em.s16{border-color:#880;c" +
                    "olor:#880}#prettydiff.canvas .data .l0{background:#eeeee8}#prettydiff.canvas .da" +
                    "ta .l1{background:#fed}#prettydiff.canvas .data .l2{background:#def}#prettydiff." +
                    "canvas .data .l3{background:#efe}#prettydiff.canvas .data .l4{background:#fef}#p" +
                    "rettydiff.canvas .data .l5{background:#eef}#prettydiff.canvas .data .l6{backgrou" +
                    "nd:#fff8cc}#prettydiff.canvas .data .l7{background:#ede}#prettydiff.canvas .data" +
                    " .l8{background:#efc}#prettydiff.canvas .data .l9{background:#ffd}#prettydiff.ca" +
                    "nvas .data .l10{background:#edc}#prettydiff.canvas .data .l11{background:#fdb}#p" +
                    "rettydiff.canvas .data .l12{background:#f8f8f8}#prettydiff.canvas .data .l13{bac" +
                    "kground:#ffb}#prettydiff.canvas .data .l14{background:#eec}#prettydiff.canvas .d" +
                    "ata .l15{background:#cfc}#prettydiff.canvas .data .l16{background:#eea}#prettydi" +
                    "ff.canvas .data .c0{background:inherit}#prettydiff.canvas #report p em{color:#06" +
                    "0}#prettydiff.canvas #report p strong{color:#009}#prettydiff.canvas .diffcli h3{" +
                    "color:#009}#prettydiff.canvas .diffcli del{background:#e8dddd;color:#a00}#pretty" +
                    "diff.canvas .diffcli ins{background:#dde8dd;color:#060}#prettydiff.canvas .diffc" +
                    "li p{color:#555}#prettydiff.canvas .diffcli li{border-bottom-color:#aaa}",
                shadow: "#prettydiff.shadow{background:#333 url(\"data:image/png;base64,iVBORw0KGgoAAAANS" +
                    "UhEUgAAAAQAAAAECAIAAAAmkwkpAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKT2lDQ1BQaG90b3Nob3AgS" +
                    "UNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG" +
                    "8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeE" +
                    "eCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0k" +
                    "ThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEA" +
                    "Gg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8" +
                    "lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg" +
                    "/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQ" +
                    "LUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0T" +
                    "KUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+A" +
                    "XuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAAR" +
                    "KCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uw" +
                    "lW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIH" +
                    "fI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2" +
                    "o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMW" +
                    "E7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxp" +
                    "FTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlE" +
                    "OU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol" +
                    "9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKC" +
                    "pVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/" +
                    "YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZ" +
                    "j8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx" +
                    "0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p" +
                    "/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJ" +
                    "gYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnut" +
                    "rxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw" +
                    "+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF" +
                    "2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ" +
                    "+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT" +
                    "8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoy" +
                    "OyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85r" +
                    "y1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFp" +
                    "xapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlL" +
                    "OW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQr" +
                    "AVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5s" +
                    "jxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1Y" +
                    "fqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9Wt" +
                    "O319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7Jv" +
                    "ttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vd" +
                    "y0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R" +
                    "9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4d" +
                    "PKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b" +
                    "/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DB" +
                    "Y+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv2" +
                    "8bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEQFaVRYd" +
                    "FhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIe" +
                    "nJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrP" +
                    "SJBZG9iZSBYTVAgQ29yZSA1LjYtYzAxNCA3OS4xNTY3OTcsIDIwMTQvMDgvMjAtMDk6NTM6MDIgICAgI" +
                    "CAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZ" +
                    "GYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgI" +
                    "CAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sb" +
                    "nM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICAgICAgICAgIHhtbG5zO" +
                    "nN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgI" +
                    "CAgICAgICAgIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb" +
                    "3VyY2VSZWYjIgogICAgICAgICAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzL" +
                    "zEuMS8iCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b" +
                    "3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmL" +
                    "zEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvI" +
                    "j4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b" +
                    "3NoKTwveG1wOkNyZWF0b3JUb29sPgogICAgICAgICA8eG1wOkNyZWF0ZURhdGU+MjAxNi0wMS0xMlQxM" +
                    "joyNDozOC0wNjowMDwveG1wOkNyZWF0ZURhdGU+CiAgICAgICAgIDx4bXA6TWV0YWRhdGFEYXRlPjIwM" +
                    "TYtMDEtMTNUMTU6MTE6MzMtMDY6MDA8L3htcDpNZXRhZGF0YURhdGU+CiAgICAgICAgIDx4bXA6TW9ka" +
                    "WZ5RGF0ZT4yMDE2LTAxLTEzVDE1OjExOjMzLTA2OjAwPC94bXA6TW9kaWZ5RGF0ZT4KICAgICAgICAgP" +
                    "HhtcE1NOkluc3RhbmNlSUQ+eG1wLmlpZDo4MDAwYTE3Zi1jZTY1LTQ5NTUtYjFmMS05YjVkODIwNDIyN" +
                    "jU8L3htcE1NOkluc3RhbmNlSUQ+CiAgICAgICAgIDx4bXBNTTpEb2N1bWVudElEPmFkb2JlOmRvY2lkO" +
                    "nBob3Rvc2hvcDoxZmZhNDk1Yy1mYTU2LTExNzgtOWE5Yy1kODI1ZGZiMGE0NzA8L3htcE1NOkRvY3VtZ" +
                    "W50SUQ+CiAgICAgICAgIDx4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+eG1wLmRpZDo2YjI0ZTI3YS1jZ" +
                    "jA3LTQ5ZDEtOWIwZC02ODEzMTFkNzQwMzE8L3htcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgI" +
                    "CAgPHhtcE1NOkhpc3Rvcnk+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmO" +
                    "mxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvb" +
                    "j5jcmVhdGVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEP" +
                    "nhtcC5paWQ6NmIyNGUyN2EtY2YwNy00OWQxLTliMGQtNjgxMzExZDc0MDMxPC9zdEV2dDppbnN0YW5jZ" +
                    "UlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE2LTAxLTEyVDEyOjI0OjM4LTA2OjAwP" +
                    "C9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQa" +
                    "G90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgI" +
                    "CAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY" +
                    "2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgI" +
                    "CAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6ZDUzYzc4NDMtYTVmMi00ODQ3L" +
                    "ThjNDMtNmUyYzBhNDY4YmViPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFd" +
                    "nQ6d2hlbj4yMDE2LTAxLTEyVDEyOjI0OjM4LTA2OjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgI" +
                    "CAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoK" +
                    "Twvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc" +
                    "3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6b" +
                    "GkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uP" +
                    "mRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y" +
                    "29udmVydGVkIGZyb20gaW1hZ2UvcG5nIHRvIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3A8L" +
                    "3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8c" +
                    "mRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjd" +
                    "Glvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJR" +
                    "D54bXAuaWlkOjgzYTc5MGFkLWMwZWQtNGIzYS05ZDJhLWE5YzQ2MWRmMzVhMTwvc3RFdnQ6aW5zdGFuY" +
                    "2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNi0wMS0xM1QxMzoxMzoyMy0wNjowM" +
                    "Dwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgU" +
                    "GhvdG9zaG9wIENDIDIwMTQgKE1hY2ludG9zaCk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgI" +
                    "CAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvc" +
                    "mRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgI" +
                    "CAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgI" +
                    "CAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjA0ZGYyNDk5LWE1NTktNDE4MC1iNjA1LWI2M" +
                    "Tk3MWMxNWEwMzwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+M" +
                    "jAxNi0wMS0xM1QxNToxMTozMy0wNjowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0R" +
                    "XZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTQgKE1hY2ludG9zaCk8L3N0RXZ0O" +
                    "nNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoY" +
                    "W5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwY" +
                    "XJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0Z" +
                    "WQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhc" +
                    "HBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVyc" +
                    "z4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlV" +
                    "HlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0R" +
                    "XZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb" +
                    "20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZ" +
                    "XRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwY" +
                    "XJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc" +
                    "3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjgwM" +
                    "DBhMTdmLWNlNjUtNDk1NS1iMWYxLTliNWQ4MjA0MjI2NTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgI" +
                    "CAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNi0wMS0xM1QxNToxMTozMy0wNjowMDwvc3RFdnQ6d2hlb" +
                    "j4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDI" +
                    "DIwMTQgKE1hY2ludG9zaCk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzd" +
                    "EV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgI" +
                    "CAgICAgICA8L3JkZjpTZXE+CiAgICAgICAgIDwveG1wTU06SGlzdG9yeT4KICAgICAgICAgPHhtcE1NO" +
                    "kRlcml2ZWRGcm9tIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgPHN0UmVmOmluc" +
                    "3RhbmNlSUQ+eG1wLmlpZDowNGRmMjQ5OS1hNTU5LTQxODAtYjYwNS1iNjE5NzFjMTVhMDM8L3N0UmVmO" +
                    "mluc3RhbmNlSUQ+CiAgICAgICAgICAgIDxzdFJlZjpkb2N1bWVudElEPnhtcC5kaWQ6ODNhNzkwYWQtY" +
                    "zBlZC00YjNhLTlkMmEtYTljNDYxZGYzNWExPC9zdFJlZjpkb2N1bWVudElEPgogICAgICAgICAgICA8c" +
                    "3RSZWY6b3JpZ2luYWxEb2N1bWVudElEPnhtcC5kaWQ6NmIyNGUyN2EtY2YwNy00OWQxLTliMGQtNjgxM" +
                    "zExZDc0MDMxPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZ" +
                    "EZyb20+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ+CiAgICAgICAgIDxwa" +
                    "G90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob" +
                    "3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgI" +
                    "CAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZ" +
                    "XNvbHV0aW9uPjMwMDAwMDAvMTAwMDA8L3RpZmY6WFJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOllSZ" +
                    "XNvbHV0aW9uPjMwMDAwMDAvMTAwMDA8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOlJlc" +
                    "29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY" +
                    "2U+MTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+NDwvZXhpZ" +
                    "jpQaXhlbFhEaW1lbnNpb24+CiAgICAgICAgIDxleGlmOlBpeGVsWURpbWVuc2lvbj40PC9leGlmOlBpe" +
                    "GVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94Onhtc" +
                    "G1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "AogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgC" +
                    "iAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "AogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgC" +
                    "iAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY" +
                    "2tldCBlbmQ9InciPz5hSvvCAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5Jfx" +
                    "UYAAAAlSURBVHjaPMYxAQAwDAMgVkv1VFFRuy9cvN0F7m66JNNhOvwBAPyqCtNeO5K2AAAAAElFTkSuQ" +
                    "mCC\");color:#fff}#prettydiff.shadow *:focus{outline:0.1em dashed #ff0}#prettydi" +
                    "ff.shadow a:visited{color:#f93}#prettydiff.shadow a{color:#cf3}#prettydiff.shado" +
                    "w .contentarea,#prettydiff.shadow .data li,#prettydiff.shadow .diff td,#prettydi" +
                    "ff.shadow .diff-right,#prettydiff.shadow .report td,#prettydiff.shadow fieldset " +
                    "input,#prettydiff.shadow fieldset select,#prettydiff.shadow legend{background:#3" +
                    "33;border-color:#666}#prettydiff.shadow #report,#prettydiff.shadow #report .auth" +
                    "or,#prettydiff.shadow .beautify,#prettydiff.shadow .beautify h3,#prettydiff.shad" +
                    "ow .beautify h4,#prettydiff.shadow .diff,#prettydiff.shadow .diff h3,#prettydiff" +
                    ".shadow .diff h4,#prettydiff.shadow .report,#prettydiff.shadow fieldset,#prettyd" +
                    "iff.shadow input,#prettydiff.shadow select{background:#222;border-color:#666}#pr" +
                    "ettydiff.shadow fieldset fieldset{background:#333}#prettydiff.shadow .nested td," +
                    "#prettydiff.shadow .segment,#prettydiff.shadow fieldset fieldset input,#prettydi" +
                    "ff.shadow fieldset fieldset select{background:#222}#prettydiff.shadow h2,#pretty" +
                    "diff.shadow h2 button,#prettydiff.shadow h3,#prettydiff.shadow input,#prettydiff" +
                    ".shadow legend,#prettydiff.shadow option,#prettydiff.shadow select{color:#ccc}#p" +
                    "rettydiff.shadow .contentarea{box-shadow:0 1em 1em #000}#prettydiff.shadow .opti" +
                    "ons li,#prettydiff.shadow .segment,#prettydiff.shadow h2 button,#prettydiff.shad" +
                    "ow ol.segment li,#prettydiff.shadow td,#prettydiff.shadow th{border-color:#666}#" +
                    "prettydiff.shadow .count li.fold{color:#cf3}#prettydiff.shadow th{background:#00" +
                    "0}#prettydiff.shadow h2 button{background:#585858;box-shadow:0.1em 0.1em 0.25em " +
                    "#000}#prettydiff.shadow li h4{color:#ff0}#prettydiff.shadow code{background:#585" +
                    "858;border-color:#585858;color:#ccf}#prettydiff.shadow ol.segment h4 strong{colo" +
                    "r:#f30}#prettydiff.shadow button{background-color:#333;border-color:#666;box-sha" +
                    "dow:0 0.25em 0.5em #000;color:#ccc}#prettydiff.shadow button:hover{background-co" +
                    "lor:#777;border-color:#aaa;box-shadow:0 0.25em 0.5em #222;color:#fff}#prettydiff" +
                    ".shadow tr:hover{background:#353}#prettydiff.shadow th,#prettydiff.shadow th.hea" +
                    "ding,#prettydiff.shadow thead th{background:#666;border-color:#999}#prettydiff.s" +
                    "hadow .nested td.nested,#prettydiff.shadow td.nested,#prettydiff.shadow th.neste" +
                    "d{background:#444}#prettydiff.shadow .diff h3{background:#000;border-color:#666}" +
                    "#prettydiff.shadow .beautify li span,#prettydiff.shadow .data li,#prettydiff.sha" +
                    "dow .diff-right,#prettydiff.shadow .segment{border-color:#888}#prettydiff.shadow" +
                    " .count li{border-color:#333}#prettydiff.shadow .count{background:#555;border-co" +
                    "lor:#333}#prettydiff.shadow li h4,#prettydiff.shadow li h5{color:#ff0}#prettydif" +
                    "f.shadow code{background:#000;border-color:#000;color:#ddd}#prettydiff.shadow #a" +
                    "ddOptions .disabled{background:#300;color:#fdd}#prettydiff.shadow ol.segment h4 " +
                    "strong{color:#c00}#prettydiff.shadow .data .delete{background:#300}#prettydiff.s" +
                    "hadow .data .delete em{background:#200;border-color:#c63;color:#c66}#prettydiff." +
                    "shadow .data .insert{background:#030}#prettydiff.shadow .data .insert em{backgro" +
                    "und:#010;border-color:#090;color:#6c0}#prettydiff.shadow .data .replace{backgrou" +
                    "nd:#345}#prettydiff.shadow .data .replace em{background:#023;border-color:#09c;c" +
                    "olor:#7cf}#prettydiff.shadow .data .empty{background:#111}#prettydiff.shadow .di" +
                    "ff .author{border-color:#666}#prettydiff.shadow .data em.s0{border-color:#fff;co" +
                    "lor:#fff}#prettydiff.shadow .data em.s1{border-color:#d60;color:#d60}#prettydiff" +
                    ".shadow .data em.s2{border-color:#aaf;color:#aaf}#prettydiff.shadow .data em.s3{" +
                    "border-color:#0c0;color:#0c0}#prettydiff.shadow .data em.s4{border-color:#f6f;co" +
                    "lor:#f6f}#prettydiff.shadow .data em.s5{border-color:#0cc;color:#0cc}#prettydiff" +
                    ".shadow .data em.s6{border-color:#dc3;color:#dc3}#prettydiff.shadow .data em.s7{" +
                    "border-color:#a7a;color:#a7a}#prettydiff.shadow .data em.s8{border-color:#7a7;co" +
                    "lor:#7a7}#prettydiff.shadow .data em.s9{border-color:#ff6;color:#ff6}#prettydiff" +
                    ".shadow .data em.s10{border-color:#33f;color:#33f}#prettydiff.shadow .data em.s1" +
                    "1{border-color:#933;color:#933}#prettydiff.shadow .data em.s12{border-color:#990" +
                    ";color:#990}#prettydiff.shadow .data em.s13{border-color:#987;color:#987}#pretty" +
                    "diff.shadow .data em.s14{border-color:#fc3;color:#fc3}#prettydiff.shadow .data e" +
                    "m.s15{border-color:#897;color:#897}#prettydiff.shadow .data em.s16{border-color:" +
                    "#f30;color:#f30}#prettydiff.shadow .data .l0{background:#333}#prettydiff.shadow " +
                    ".data .l1{background:#633}#prettydiff.shadow .data .l2{background:#335}#prettydi" +
                    "ff.shadow .data .l3{background:#353}#prettydiff.shadow .data .l4{background:#636" +
                    "}#prettydiff.shadow .data .l5{background:#366}#prettydiff.shadow .data .l6{backg" +
                    "round:#640}#prettydiff.shadow .data .l7{background:#303}#prettydiff.shadow .data" +
                    " .l8{background:#030}#prettydiff.shadow .data .l9{background:#660}#prettydiff.sh" +
                    "adow .data .l10{background:#003}#prettydiff.shadow .data .l11{background:#300}#p" +
                    "rettydiff.shadow .data .l12{background:#553}#prettydiff.shadow .data .l13{backgr" +
                    "ound:#432}#prettydiff.shadow .data .l14{background:#640}#prettydiff.shadow .data" +
                    " .l15{background:#562}#prettydiff.shadow .data .l16{background:#600}#prettydiff." +
                    "shadow .data .c0{background:inherit}#prettydiff.shadow .diffcli h3{color:#9cf}#p" +
                    "rettydiff.shadow .diffcli del{background:#382222;color:#f63}#prettydiff.shadow ." +
                    "diffcli ins{background:#223822;color:#cf3}#prettydiff.shadow .diffcli p{color:#a" +
                    "aa}#prettydiff.shadow .diffcli li{border-bottom-color:#666}",
                white: "#prettydiff.white{background:#f8f8f8 url(\"data:image/png;base64,iVBORw0KGgoAAAA" +
                    "NSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKT2lDQ1BQaG90b3Nob3A" +
                    "gSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUU" +
                    "EG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUI" +
                    "eEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB" +
                    "0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYh" +
                    "EAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABR" +
                    "G8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRH" +
                    "gg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrI" +
                    "PQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz" +
                    "0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo" +
                    "+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAA" +
                    "ARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4" +
                    "uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFV" +
                    "IHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2g" +
                    "P2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFh" +
                    "MWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkm" +
                    "xpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShn" +
                    "lEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5" +
                    "Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZH" +
                    "KCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5" +
                    "Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvO" +
                    "UZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5" +
                    "Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W3" +
                    "6p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423Gbca" +
                    "jJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRapln" +
                    "utrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8W" +
                    "uw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00d" +
                    "nF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MP" +
                    "IQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLf" +
                    "LT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSF" +
                    "oyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU8" +
                    "5ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvS" +
                    "FpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTO" +
                    "lLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7O" +
                    "QrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo" +
                    "5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+" +
                    "1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9" +
                    "WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7" +
                    "JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3" +
                    "vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr" +
                    "8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK" +
                    "4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN" +
                    "6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9" +
                    "DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xm" +
                    "v28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAADo2aVR" +
                    "YdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGl" +
                    "IenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHR" +
                    "rPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzAxNCA3OS4xNTY3OTcsIDIwMTQvMDgvMjAtMDk6NTM6MDIgICA" +
                    "gICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1" +
                    "yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICA" +
                    "gICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1" +
                    "sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICAgICAgICAgIHhtbG5" +
                    "zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiA" +
                    "gICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICA" +
                    "gICAgICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgo" +
                    "gICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICA" +
                    "gICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA" +
                    "8eG1wOkNyZWF0b3JUb29sPkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE0IChNYWNpbnRvc2gpPC94bXA6Q3J" +
                    "lYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE2LTAxLTEyVDEyOjI0OjM4LTA2OjA" +
                    "wPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNi0wMS0xMlQxMjo" +
                    "yNDozOC0wNjowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTY" +
                    "tMDEtMTJUMTI6MjQ6MzgtMDY6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8eG1wTU06SW5zdGF" +
                    "uY2VJRD54bXAuaWlkOmQ1M2M3ODQzLWE1ZjItNDg0Ny04YzQzLTZlMmMwYTQ2OGJlYjwveG1wTU06SW5" +
                    "zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+YWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjF" +
                    "jMzc2MTgxLWY5ZTgtMTE3OC05YTljLWQ4MjVkZmIwYTQ3MDwveG1wTU06RG9jdW1lbnRJRD4KICAgICA" +
                    "gICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjZiMjRlMjdhLWNmMDctNDlkMS05YjB" +
                    "kLTY4MTMxMWQ3NDAzMTwveG1wTU06T3JpZ2luYWxEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06SGl" +
                    "zdG9yeT4KICAgICAgICAgICAgPHJkZjpTZXE+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnN" +
                    "lVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmNyZWF0ZWQ8L3N" +
                    "0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo2YjI" +
                    "0ZTI3YS1jZjA3LTQ5ZDEtOWIwZC02ODEzMTFkNzQwMzE8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICA" +
                    "gICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTYtMDEtMTJUMTI6MjQ6MzgtMDY6MDA8L3N0RXZ0OndoZW4" +
                    "+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyA" +
                    "yMDE0IChNYWNpbnRvc2gpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICA8L3JkZjp" +
                    "saT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICA" +
                    "gICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICA" +
                    "gICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDpkNTNjNzg0My1hNWYyLTQ4NDctOGM0My02ZTJjMGE" +
                    "0NjhiZWI8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTY" +
                    "tMDEtMTJUMTI6MjQ6MzgtMDY6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp" +
                    "zb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE0IChNYWNpbnRvc2gpPC9zdEV2dDpzb2Z" +
                    "0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2V" +
                    "kPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogICAgICAgICA" +
                    "8L3htcE1NOkhpc3Rvcnk+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ+CiA" +
                    "gICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICA" +
                    "gIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2Z" +
                    "pbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICA" +
                    "gIDx0aWZmOlhSZXNvbHV0aW9uPjMwMDAwMDAvMTAwMDA8L3RpZmY6WFJlc29sdXRpb24+CiAgICAgICA" +
                    "gIDx0aWZmOllSZXNvbHV0aW9uPjMwMDAwMDAvMTAwMDA8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICA" +
                    "gIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDxleGl" +
                    "mOkNvbG9yU3BhY2U+MTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnN" +
                    "pb24+NDwvZXhpZjpQaXhlbFhEaW1lbnNpb24+CiAgICAgICAgIDxleGlmOlBpeGVsWURpbWVuc2lvbj4" +
                    "0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJ" +
                    "ERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgCjw/eHBhY2tldCBlbmQ9InciPz5cKgaXAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mA" +
                    "AADqYAAAXb5JfxUYAAAAkSURBVHjaPMahAQAwDMCg7P+/KnsPcq4oHqpqdwNmBt3QDX8AeAUmcrZLnM4" +
                    "AAAAASUVORK5CYII=\");}#prettydiff.white *:focus{outline:0.1em dashed #06f}#prett" +
                    "ydiff.white .contentarea,#prettydiff.white .data li,#prettydiff.white .diff td,#" +
                    "prettydiff.white .diff-right,#prettydiff.white .report td,#prettydiff.white fiel" +
                    "dset input,#prettydiff.white fieldset select,#prettydiff.white legend{background" +
                    ":#fff;border-color:#999}#prettydiff.white #pdsamples li div,#prettydiff.white #r" +
                    "eport,#prettydiff.white #report .author,#prettydiff.white .author,#prettydiff.wh" +
                    "ite .beautify,#prettydiff.white .beautify h3,#prettydiff.white .beautify h4,#pre" +
                    "ttydiff.white .diff,#prettydiff.white .diff h3,#prettydiff.white .diff h4,#prett" +
                    "ydiff.white .report,#prettydiff.white fieldset,#prettydiff.white input,#prettydi" +
                    "ff.white select{background:#eee;border-color:#999}#prettydiff.white .diff h3{bac" +
                    "kground:#ddd;border-color:#999}#prettydiff.white fieldset fieldset,#prettydiff.w" +
                    "hite th.nested{background:#ddd}#prettydiff.white .contentarea{box-shadow:0 1em 1" +
                    "em #999}#prettydiff.white button{background-color:#eee;border-color:#999;box-sha" +
                    "dow:0 0.25em 0.5em #ccc;color:#666}#prettydiff.white button:hover{background-col" +
                    "or:#def;border-color:#03c;box-shadow:0 0.25em 0.5em #ccf;color:#03c}#prettydiff." +
                    "white h2,#prettydiff.white h2 button,#prettydiff.white h3{color:#b00}#prettydiff" +
                    ".white th{background:#eee;color:#333}#prettydiff.white tr:hover{background:#efe}" +
                    "#prettydiff.white thead th,#prettydiff.white tr.header th{background:#eef}#prett" +
                    "ydiff.white .report strong{color:#009}#prettydiff.white .report em{color:#080}#p" +
                    "rettydiff.white .count li,#prettydiff.white .data li,#prettydiff.white .data li " +
                    "span,#prettydiff.white .diff-right,#prettydiff.white .options li,#prettydiff.whi" +
                    "te .segment,#prettydiff.white h2 button,#prettydiff.white ol.segment li,#prettyd" +
                    "iff.white td{border-color:#ccc}#prettydiff.white tbody th{border-color:#999}#pre" +
                    "ttydiff.white td.nested{background:#d8d8d8}#prettydiff.white th.nested{backgroun" +
                    "d:#eee}#prettydiff.white .count li.fold{color:#900}#prettydiff.white .count{back" +
                    "ground:#eed;border-color:#999}#prettydiff.white #addOptions .disabled{background" +
                    ":#fee;color:#300}#prettydiff.white h2 button{background:#f8f8f8;box-shadow:0.1em" +
                    " 0.1em 0.25em #ddd}#prettydiff.white li h4,#prettydiff.white li h5{color:#33c}#p" +
                    "rettydiff.white code{background:#eee;border-color:#eee;color:#009}#prettydiff.wh" +
                    "ite ol.segment h4 strong{color:#c00}#prettydiff.white .data .delete{background:#" +
                    "ffd8d8}#prettydiff.white .data .delete em{background:#fff8f8;border-color:#c44;c" +
                    "olor:#900}#prettydiff.white .data .insert{background:#d8ffd8}#prettydiff.white ." +
                    "data .insert em{background:#f8fff8;border-color:#090;color:#363}#prettydiff.whit" +
                    "e .data .replace{background:#fec}#prettydiff.white .data .replace em{background:" +
                    "#ffe;border-color:#a86;color:#852}#prettydiff.white .data .empty{background:#ddd" +
                    "}#prettydiff.white .data em.s0{border-color:#000;color:#000}#prettydiff.white .d" +
                    "ata em.s1{border-color:#f66;color:#f66}#prettydiff.white .data em.s2{border-colo" +
                    "r:#12f;color:#12f}#prettydiff.white .data em.s3{border-color:#090;color:#090}#pr" +
                    "ettydiff.white .data em.s4{border-color:#d6d;color:#d6d}#prettydiff.white .data " +
                    "em.s5{border-color:#7cc;color:#7cc}#prettydiff.white .data em.s6{border-color:#c" +
                    "85;color:#c85}#prettydiff.white .data em.s7{border-color:#737;color:#737}#pretty" +
                    "diff.white .data em.s8{border-color:#6d0;color:#6d0}#prettydiff.white .data em.s" +
                    "9{border-color:#dd0;color:#dd0}#prettydiff.white .data em.s10{border-color:#893;" +
                    "color:#893}#prettydiff.white .data em.s11{border-color:#b97;color:#b97}#prettydi" +
                    "ff.white .data em.s12{border-color:#bbb;color:#bbb}#prettydiff.white .data em.s1" +
                    "3{border-color:#cc3;color:#cc3}#prettydiff.white .data em.s14{border-color:#333;" +
                    "color:#333}#prettydiff.white .data em.s15{border-color:#9d9;color:#9d9}#prettydi" +
                    "ff.white .data em.s16{border-color:#880;color:#880}#prettydiff.white .data .l0{b" +
                    "ackground:#fff}#prettydiff.white .data .l1{background:#fed}#prettydiff.white .da" +
                    "ta .l2{background:#def}#prettydiff.white .data .l3{background:#efe}#prettydiff.w" +
                    "hite .data .l4{background:#fef}#prettydiff.white .data .l5{background:#eef}#pret" +
                    "tydiff.white .data .l6{background:#fff8cc}#prettydiff.white .data .l7{background" +
                    ":#ede}#prettydiff.white .data .l8{background:#efc}#prettydiff.white .data .l9{ba" +
                    "ckground:#ffd}#prettydiff.white .data .l10{background:#edc}#prettydiff.white .da" +
                    "ta .l11{background:#fdb}#prettydiff.white .data .l12{background:#f8f8f8}#prettyd" +
                    "iff.white .data .l13{background:#ffb}#prettydiff.white .data .l14{background:#ee" +
                    "c}#prettydiff.white .data .l15{background:#cfc}#prettydiff.white .data .l16{back" +
                    "ground:#eea}#prettydiff.white .data .c0{background:inherit}#prettydiff.white #re" +
                    "port p em{color:#080}#prettydiff.white #report p strong{color:#009}#prettydiff.w" +
                    "hite .diffcli h3{color:#009}#prettydiff.white .diffcli del{background:#f8eeee;co" +
                    "lor:#c00}#prettydiff.white .diffcli ins{background:#eef8ee;color:#070}#prettydif" +
                    "f.white .diffcli p{color:#666}#prettydiff.white .diffcli li{border-bottom-color:" +
                    "#ccc}"
            },
            global: "#prettydiff{text-align:center;font-size:10px;overflow-y:scroll}#prettydiff .cont" +
                "entarea{border-style:solid;border-width:0.1em;font-family:\"Century Gothic\",\"T" +
                "rebuchet MS\";margin:0 auto;max-width:93em;padding:1em;text-align:left}#prettydi" +
                "ff dd,#prettydiff dt,#prettydiff p,#prettydiff li,#prettydiff td,#prettydiff blo" +
                "ckquote,#prettydiff th{clear:both;font-family:\"Palatino Linotype\",\"Book Antiq" +
                "ua\",Palatino,serif;font-size:1.6em;line-height:1.6em;text-align:left}#prettydif" +
                "f blockquote{font-style:italic}#prettydiff dt{font-size:1.4em;font-weight:bold;l" +
                "ine-height:inherit}#prettydiff li li,#prettydiff li p{font-size:1em}#prettydiff " +
                "th,#prettydiff td{border-style:solid;border-width:0.1em;padding:0.1em 0.2em}#pre" +
                "ttydiff td span{display:block}#prettydiff code,#prettydiff textarea{font-family:" +
                "\"Courier New\",Courier,\"Lucida Console\",monospace}#prettydiff code,#prettydif" +
                "f textarea{display:block;font-size:0.8em;width:100%}#prettydiff code span{displa" +
                "y:block;white-space:pre}#prettydiff code{border-style:solid;border-width:0.2em;l" +
                "ine-height:1em}#prettydiff textarea{line-height:1.4em}#prettydiff label{display:" +
                "inline;font-size:1.4em}#prettydiff legend{border-radius:1em;border-style:solid;b" +
                "order-width:0.1em;font-size:1.4em;font-weight:bold;margin-left:-0.25em;padding:0" +
                " 0.5em}#prettydiff fieldset fieldset legend{font-size:1.2em}#prettydiff table{bo" +
                "rder-collapse:collapse}#prettydiff div.report{border-style:none}#prettydiff h2,#" +
                "prettydiff h3,#prettydiff h4{clear:both}#prettydiff table{margin:0 0 1em}#pretty" +
                "diff .analysis .bad,#prettydiff .analysis .good{font-weight:bold}#prettydiff h1{" +
                "font-size:3em;font-weight:normal;margin-top:0}#prettydiff h1 span{font-size:0.5e" +
                "m}#prettydiff h1 svg{border-style:solid;border-width:0.05em;float:left;height:1." +
                "5em;margin-right:0.5em;width:1.5em}#prettydiff h2{border-style:none;background:t" +
                "ransparent;font-size:1em;box-shadow:none;margin:0}#prettydiff h2 button{backgrou" +
                "nd:transparent;border-style:solid;cursor:pointer;display:block;font-size:2.5em;f" +
                "ont-weight:normal;text-align:left;width:100%;border-width:0.05em;font-weight:nor" +
                "mal;margin:1em 0 0;padding:0.1em}#prettydiff h2 span{display:block;float:right;f" +
                "ont-size:0.5em}#prettydiff h3{font-size:2em;margin:0;background:transparent;box-" +
                "shadow:none;border-style:none}#prettydiff h4{font-size:1.6em;font-family:\"Centu" +
                "ry Gothic\",\"Trebuchet MS\";margin:0}#prettydiff li h4{font-size:1em}#prettydif" +
                "f button,#prettydiff fieldset,#prettydiff div input,#prettydiff textarea{border-" +
                "style:solid;border-width:0.1em}#prettydiff section{border-style:none}#prettydiff" +
                " h2 button,#prettydiff select,#prettydiff option{font-family:inherit}#prettydiff" +
                " select{border-style:inset;border-width:0.1em;width:13.5em}#prettydiff #dcolorSc" +
                "heme{float:right;margin:-3em 0 0}#prettydiff #dcolorScheme label,#prettydiff #dc" +
                "olorScheme label{display:inline-block;font-size:1em}#prettydiff .clear{clear:bot" +
                "h;display:block}#prettydiff caption,#prettydiff .content-hide{height:1em;left:-1" +
                "000em;overflow:hidden;position:absolute;top:-1000em;width:1em}",
            reports: "#prettydiff #report.contentarea{font-family:\"Lucida Sans Unicode\",\"Helvetica" +
                "\",\"Arial\",sans-serif;max-width:none;overflow:scroll}#prettydiff .diff .delete" +
                " em,#prettydiff .diff .insert em,#prettydiff .diff .replace em{border-style:soli" +
                "d;border-width:0.1em}#prettydiff #report blockquote,#prettydiff #report dd,#pret" +
                "tydiff #report dt,#prettydiff #report li,#prettydiff #report p,#prettydiff #repo" +
                "rt td,#prettydiff #report th{font-family:\"Lucida Sans Unicode\",\"Helvetica\"," +
                "\"Arial\",sans-serif;font-size:1.2em}#prettydiff div#webtool{background:transpar" +
                "ent;font-size:inherit;margin:0;padding:0}#prettydiff #jserror span{display:block" +
                "}#prettydiff #a11y{background:transparent;clear:both;padding:0}#prettydiff #a11y" +
                " div{margin:0.5em 0;border-style:solid;border-width:0.1em}#prettydiff #a11y h4{m" +
                "argin:0.25em 0}#prettydiff #a11y ol{border-style:solid;border-width:0.1em}#prett" +
                "ydiff #cssreport.doc table{clear:none;float:left;margin-left:1em}#prettydiff #cs" +
                "s-size{left:24em}#prettydiff #css-uri{left:40em}#prettydiff #css-uri td{text-ali" +
                "gn:left}#prettydiff .report .analysis th{text-align:left}#prettydiff table.code " +
                "td,#prettydiff table.code th{font-size:0.9em}#prettydiff .report .analysis .pars" +
                "eData td,#prettydiff table.code td,#prettydiff table.code th{font-family:'Courie" +
                "r New',Courier,'Lucida Console',monospace;text-align:left;white-space:pre}#prett" +
                "ydiff .report .analysis td{text-align:right}#prettydiff .analysis{float:left;mar" +
                "gin:0 1em 1em 0}#prettydiff .analysis td,#prettydiff .analysis th{padding:0.5em}" +
                "#prettydiff .diffcli{font-size:Courier,'Courier New','Lucida Console',monospace;" +
                "margin:0;padding:0;text-align:left;white-space:pre;}#prettydiff .diffcli li{bord" +
                "er-bottom-style:solid;border-bottom-width:0.1em;list-style:none;padding-bottom:1" +
                "em}#prettydiff #webtool .diffcli h3{font-size:1.4em;font-weight:normal;margin-to" +
                "p:2em}#prettydiff #webtool .diffcli p,#prettydiff .diffcli del,#prettydiff .diff" +
                "cli ins{display:block;font-family:Courier,'Courier New','Lucida Console',monospa" +
                "ce;font-size:1.2em;font-style:normal;margin:0;text-decoration:none}#prettydiff ." +
                "diffcli em{color:inherit;font-style:normal;font-weight:bold}#prettydiff .diffcli" +
                " del em,#prettydiff .diffcli ins em{text-decoration:underline}#prettydiff #statr" +
                "eport div{border-style:none}#prettydiff .beautify,#prettydiff .diff{border-style" +
                ":solid;border-width:0.1em;display:inline-block;margin:0 1em 1em 0;position:relat" +
                "ive}#prettydiff .beautify,#prettydiff .beautify h3,#prettydiff .beautify h4,#pre" +
                "ttydiff .beautify li,#prettydiff .diff,#prettydiff .diff h4,#prettydiff .diff li" +
                " #prettydiff .diff h3{font-family:'Courier New',Courier,'Lucida Console',monospa" +
                "ce}#prettydiff .beautify h3,#prettydiff .beautify h4,#prettydiff .beautify li,#p" +
                "rettydiff .diff h3,#prettydiff .diff h4,#prettydiff .diff li{border-style:none n" +
                "one solid none;border-width:0 0 0.1em 0;box-shadow:none;display:block;font-size:" +
                "1.2em;margin:0 0 0 -.1em;padding:0.2em 2em;text-align:left}#prettydiff .diff .sk" +
                "ip{border-style:none none solid;border-width:0 0 0.1em}#prettydiff .diff .diff-l" +
                "eft{border-style:none;display:table-cell}#prettydiff .diff .diff-right{border-st" +
                "yle:none none none solid;border-width:0 0 0 0.1em;display:table-cell;margin-left" +
                ":-.1em;min-width:16.5em;right:0;top:0}#prettydiff .diff-right .data{width:100%}#" +
                "prettydiff .beautify .data li,#prettydiff .diff .data li{min-width:16.5em;paddin" +
                "g:0.5em}#prettydiff .beautify h3,#prettydiff .beautify li,#prettydiff .beautify " +
                "p,#prettydiff .diff h3,#prettydiff .diff li,#prettydiff .diff p{font-size:1.2em}" +
                "#prettydiff .beautify li em,#prettydiff .diff li em{font-style:normal;font-weigh" +
                "t:bold;margin:-0.5em -0.09em}#prettydiff .diff p.author{border-style:solid;borde" +
                "r-width:0.2em 0.1em 0.1em;margin:0;overflow:hidden;padding:0.4em;text-align:righ" +
                "t}#prettydiff .difflabel{display:block;height:0}#prettydiff .count{border-style:" +
                "solid;border-width:0 0.1em 0 0;font-weight:normal;padding:0;text-align:right}#pr" +
                "ettydiff .count li{padding:0.5em 1em;text-align:right}#prettydiff .count li.fold" +
                "{cursor:pointer;font-weight:bold;padding-left:0.5em}#prettydiff .data{text-align" +
                ":left;white-space:pre}#prettydiff .beautify .data span{display:inline-block;font" +
                "-style:normal;font-weight:bold}#prettydiff .beautify li,#prettydiff .diff li{bor" +
                "der-style:none none solid;border-width:0 0 0.1em;display:block;height:1em;line-h" +
                "eight:1.2;list-style-type:none;margin:0;white-space:pre}#prettydiff .beautify ol" +
                ",#prettydiff .diff ol{display:table-cell;margin:0;padding:0}#prettydiff .beautif" +
                "y li em{border-style:none none solid;border-width:0 0 0.1em;padding:0 0 0.2em;po" +
                "sition:relative;z-index:5}#prettydiff .beautify li .line{border-style:none}#pret" +
                "tydiff .beautify li span{border-style:none none solid;border-width:0 0 0.1em;hei" +
                "ght:2em;margin:0 0 -1em;position:relative;top:-0.5em}#prettydiff .beautify span." +
                "l0{margin-left:-0.5em;padding-left:0.5em}#prettydiff #webtool table table{margin" +
                ":0 -0.1em -0.1em;width:100%}#prettydiff #webtool table table td,#prettydiff #web" +
                "tool table table th{font-size:1em}#prettydiff #webtool table td.nested{padding:0" +
                ".5em}#prettydiff #report .beautify,#prettydiff #report .beautify li,#prettydiff " +
                "#report .diff,#prettydiff #report .diff li{font-family:\"Courier New\",Courier," +
                "\"Lucida Console\",monospace}#prettydiff #report .beautify{border-style:solid}#p" +
                "rettydiff #report .beautify h3,#prettydiff #report .diff h3{border-top-style:sol" +
                "id;border-top-width:0.1em;margin:0}#prettydiff #webtool #a11y,#prettydiff #webto" +
                "ol #a11y div,#prettydiff #webtool #a11y ol,#prettydiff #webtool #a11y ul{border-" +
                "style:none}"
        },
        html: {
            body: "/\u002a]]>\u002a/</style></head><body id=\"prettydiff\" class=\"",
            color: "white",
            htmlEnd: "</script></body></html>",
            head: "<?xml version=\"1.0\" encoding=\"UTF-8\" ?><!DOCTYPE html PUBLIC \"-//W3C//DTD X" +
                "HTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\"><html xmlns=\"ht" +
                "tp://www.w3.org/1999/xhtml\" xml:lang=\"en\"><head><title>Pretty Diff - The diff" +
                "erence tool</title><meta name=\"robots\" content=\"index, follow\"/> <meta name=" +
                "\"DC.title\" content=\"Pretty Diff - The difference tool\"/> <link rel=\"canonic" +
                "al\" href=\"https://prettydiff.com/\" type=\"application/xhtml+xml\"/><meta http-" +
                "equiv=\"Content-Type\" content=\"application/xhtml+xml;charset=UTF-8\"/><meta ht" +
                "tp-equiv=\"Content-Style-Type\" content=\"text/css\"/><style type=\"text/css\">/" +
                "\u002a<![CDATA[\u002a/",
            intro: "\"><div class=\"contentarea\" id=\"report\"><section role=\"heading\"><h1><svg h" +
                "eight=\"2000.000000pt\" id=\"pdlogo\" preserveAspectRatio=\"xMidYMid meet\" vers" +
                "ion=\"1.0\" viewBox=\"0 0 2000.000000 2000.000000\" width=\"2000.000000pt\" xmln" +
                "s=\"http://www.w3.org/2000/svg\"><g fill=\"#999\" stroke=\"none\" transform=\"tr" +
                "anslate(0.000000,2000.000000) scale(0.100000,-0.100000)\"> <path d=\"M14871 1852" +
                "3 c-16 -64 -611 -2317 -946 -3588 -175 -660 -319 -1202 -320 -1204 -2 -2 -50 39 -1" +
                "07 91 -961 876 -2202 1358 -3498 1358 -1255 0 -2456 -451 -3409 -1279 -161 -140 -4" +
                "24 -408 -560 -571 -507 -607 -870 -1320 -1062 -2090 -58 -232 -386 -1479 -2309 -87" +
                "59 -148 -563 -270 -1028 -270 -1033 0 -4 614 -8 1365 -8 l1364 0 10 38 c16 63 611 " +
                "2316 946 3587 175 660 319 1202 320 1204 2 2 50 -39 107 -91 543 -495 1169 -862 18" +
                "63 -1093 1707 -568 3581 -211 4965 946 252 210 554 524 767 796 111 143 312 445 40" +
                "8 613 229 406 408 854 525 1320 57 225 380 1451 2310 8759 148 563 270 1028 270 10" +
                "33 0 4 -614 8 -1365 8 l-1364 0 -10 -37z m-4498 -5957 c477 -77 889 -256 1245 -542" +
                " 523 -419 850 -998 954 -1689 18 -121 18 -549 0 -670 -80 -529 -279 -972 -612 -135" +
                "9 -412 -480 -967 -779 -1625 -878 -121 -18 -549 -18 -670 0 -494 74 -918 255 -1283" +
                " 548 -523 419 -850 998 -954 1689 -18 121 -18 549 0 670 104 691 431 1270 954 1689" +
                " 365 293 828 490 1283 545 50 6 104 13 120 15 72 10 495 -3 588 -18z\"/></g></svg>" +
                "<a href=\"prettydiff.com.xhtml\">Pretty Diff</a></h1><p id=\"dcolorScheme\"><lab" +
                "el class=\"label\" for=\"colorScheme\">Color Scheme</label><select id=\"colorSch" +
                "eme\"><option>Canvas</option><option>Shadow</option><option selected=\"selected" +
                "\">White</option></select></p><p>Find <a href=\"https://github.com/prettydiff/pr" +
                "ettydiff\">Pretty Diff on GitHub</a>.</p></section><section role=\"main\" class=" +
                "\"report\">",
            scriptEnd: "//]]>",
            scriptStart: "</section></div><script type=\"application/javascript\">//<![CDATA["
        },
        order: [],
        script: {
            beautify: "(function doc(){\"use strict\";let inca=0,incb=0,ol,li,lilen=0;const div=documen" +
                "t.getElementsByTagName(\"div\"),len=div.length,body=document.getElementsByTagNam" +
                "e(\"body\")[0],color=document.getElementById(\"colorScheme\"),change=function do" +
                "c_colorChange(){const name=color[color.selectedIndex].innerHTML.toLowerCase();bo" +
                "dy.setAttribute(\"class\",name" + ")},beaufold=function doc_beaufold(event){let a=0,b=\"\";const el=event.srcElemen" +
                "t||event.target,title=el.getAttribute(\"title\").split(\"line \"),parent=[el.par" +
                "entNode,el.parentNode.nextSibling],min=Number(title[1].substr(0,title[1].indexOf" +
                "(\" \"))),max=Number(title[2]),list=[parent[0].getElementsByTagName(\"li\"),pare" +
                "nt[1].getElementsByTagName(\"li\")];a=min;if(el.innerHTML.charAt(0)===\"-\"){do{" +
                "list[0][a].style.display=\"none\";list[1][a].style.display=\"none\";a=a+1}while(" +
                "a<max);el.innerHTML=\"+\"+el.innerHTML.substr(1)}else{do{list[0][a].style.displa" +
                "y" + "=\"block\";list[1][a].style.display=\"block\";if(list[0][a].getAttribute(\"class" +
                "\")===\"fold\"&&list[0][a].innerHTML.charAt(0)===\"+\"){b=list[0][a].getAttribut" +
                "e(\"title\");b=b.substring(b.indexOf(\"to line \")+1);a=Number(b)-1}a=a+1}while(" +
                "a<max);el.innerHTML=\"-\"+el.innerHTML.substr(1)}};inca=0;do{if(div[inca].getAtt" +
                "r" + "ibute(\"class\")===\"beautify\"){ol=div[inca].getElementsByTagName(\"ol\");if(ol" +
                "[0].getAttribute(\"class\")===\"count\"){li=ol[0].getElementsByTagName(\"li\");l" +
                "ilen=li.length;incb=0;do{if(li[incb].getAttribute(\"class\")===\"fold\"){li[incb" +
                "].onclick=beaufold}incb=incb+1}while(incb<lilen)}}inca=inca+1}while(inca<len);co" +
                "lo" + "r.onchange=change}());",
            diff: "(function doc(){\"use strict\";let diffList=[];const body=document.getElementsBy" +
                "TagName(\"body\")[0],color=document.getElementById(\"colorScheme\"),change=funct" +
                "ion doc_colorChange(){const name=color[color.selectedIndex].innerHTML.toLowerCas" +
                "e();body.setAttribute(\"class\",name)},colSliderGrab=function doc_colSliderGrab(" +
                "event){let subOffset=0,withinRange=false,offset=0,status=\"ew\",diffLeft,node=ev" +
                "ent.srcElement||event.target;const touch=(event!==null&&event.type===\"touchstar" +
                "t\"),diffRight=(function doc_colSliderGrab_nodeFix(){if(node.nodeName===\"li\"){" +
                "node=node.parentNode}return node.parentNode}()),diff=diffRight.parentNode,lists=" +
                "diff.getElementsByTagName(\"ol\"),par1=lists[2].parentNode,par2=lists[2].parentN" +
                "ode.parentNode,counter=lists[0].clientWidth,data=lists[1].clientWidth,width=par1" +
                ".clientWidth,total=par2.clientWidth,min=((total-counter-data-2)-width),max=(tota" +
                "l-width-counter),minAdjust=min+15,maxAdjust=max-20;diffLeft=diffRight.previousSi" +
                "bling;offset=par1.offsetLeft-par2.offsetLeft;event.preventDefault();subOffset=(p" +
                "ar1.scrollLeft>document.body.scrollLeft)?par1.scrollLeft:document.body.scrollLef" +
                "t;offset=offset-subOffset;offset=offset+node.clientWidth;node.style.cursor=\"ew-" +
                "resize\";diff.style.width=(total/10)+\"em\";diff.style.display=\"inline-block\";" +
                "if(diffLeft.nodeType!==1){do{diffLeft=diffLeft.previousSibling}while(diffLeft.no" +
                "deType!==1)}diffLeft.style.display=\"block\";diffRight.style.width=(diffRight.cl" +
                "ientWidth/10)+\"em\";diffRight.style.position=\"absolute\";if(touch===true){docu" +
                "ment.ontouchmove=function doc_colSliderGrab_Touchboxmove(f){f.preventDefault();s" +
                "ubOffset=offset-f.touches[0].clientX;if(subOffset>minAdjust&&subOffset<maxAdjust" +
                "){withinRange=true}if(withinRange===true&&subOffset>maxAdjust){diffRight.style.w" +
                "idth=((total-counter-2)/10)+\"em\";status=\"e\"}else if(withinRange===true&&subO" +
                "ffset<minAdjust){diffRight.style.width=((total-counter-data-2)/10)+\"em\";status" +
                "=\"w\"}else if(subOffset<max&&subOffset>min){diffRight.style.width=((width+subOf" +
                "fset)/10)+\"em\";status=\"ew\"}document.ontouchend=function doc_colSliderGrab_To" +
                "uchboxmove_drop(f){f.preventDefault();node.style.cursor=status+\"-resize\";docum" +
                "ent.ontouchmove=null;document.ontouchend=null}};document.ontouchstart=null}else{" +
                "document.onmousemove=function doc_colSliderGrab_Mouseboxmove(f){f.preventDefault" +
                "();subOffset=offset-f.clientX;if(subOffset>minAdjust&&subOffset<maxAdjust){withi" +
                "nRange=true}if(withinRange===true&&subOffset>maxAdjust){diffRight.style.width=((" +
                "total-counter-2)/10)+\"em\";status=\"e\"}else if(withinRange===true&&subOffset<m" +
                "inAdjust){diffRight.style.width=((total-counter-data-2)/10)+\"em\";status=\"w\"}" +
                "else if(subOffset<max&&subOffset>min){diffRight.style.width=((width+subOffset)/1" +
                "0)+\"em\";status=\"ew\"}document.onmouseup=function doc_colSliderGrab_Mouseboxmo" +
                "ve_drop(f){f.preventDefault();node.style.cursor=status+\"-resize\";document.onmo" +
                "usemove=null;document.onmouseup=null}};document.onmousedown=null}return false},d" +
                "ifffold=function doc_difffold(event){let a=0,b=0,max,lists=[];const node=event.s" +
                "rcElement||event.target,title=node.getAttribute(\"title\").split(\"line \"),min=" +
                "Number(title[1].substr(0,title[1].indexOf(\" \"))),inner=node.innerHTML,parent=n" +
                "ode.parentNode.parentNode,par1=parent.parentNode,listnodes=(parent.getAttribute(" +
                "\"class\")===\"diff\")?parent.getElementsByTagName(\"ol\"):par1.getElementsByTag" +
                "Name(\"ol\"),listLen=listnodes.length;do{lists.push(listnodes[a].getElementsByTa" +
                "gName(\"li\"));a=a+1}while(a<listLen);max=(max>=lists[0].length)?lists[0].length" +
                ":Number(title[2]);if(inner.charAt(0)===\"-\"){node.innerHTML=\"+\"+inner.substr(" +
                "1);a=min;if(min<max){do{b=0;do{lists[b][a].style.display=\"none\";b=b+1}while(b<l" +
                "istLen);a=a+1}while(a<max)}}else{node.innerHTML=\"-\"+inner.substr(1);a=min;if(m" +
                "in<max){do{b=0;do{lists[b][a].style.display=\"block\";b=b+1}while(b<listLen);a=a+" +
                "1}while(a<max)}}};diffList=document.getElementsByTagName(\"ol\");if(diffList.len" +
                "gth>0){const cells=diffList[0].getElementsByTagName(\"li\"),len=cells.length;let" +
                " a=0;do{if(cells[a].getAttribute(\"class\")===\"fold\"){cells[a].onclick=difffol" +
                "d}a=a+1}while(a<len)}if(diffList.length>3){diffList[2].onmousedown=colSliderGrab" +
                ";diffList[2].ontouchstart=colSliderGrab}color.onchange=change}());",
            minimal: "(function doc(){\"use strict\";const body=document.getElementsByTagName(\"body\"" +
                ")[0],color" + "=document.getElementById(\"colorScheme\"),change=function doc_colorChange(){cons" +
                "t name=color[color.selectedIndex].innerHTML.toLowerCase();body.setAttribute(\"cl" +
                "ass\",name)};color.onchange=change}());"
        }
    };
    finalFile.order = [
        finalFile.html.head,
        finalFile
            .css
            .color
            .canvas,
        finalFile
            .css
            .color
            .shadow,
        finalFile
            .css
            .color
            .white,
        finalFile.css.reports,
        finalFile.css.global,
        finalFile.html.body,
        finalFile.html.color,
        finalFile.html.intro,
        "",
        "",
        finalFile.html.scriptStart,
        "\n",
        finalFile.script.minimal,
        finalFile.html.scriptEnd,
        "\n",
        finalFile.html.htmlEnd // 16
    ];
    prettydiff.api
        .finalFile = finalFile;
}());

(function beautify_script_init() {
    const script = function beautify_script(options) {
        let scolon = 0, news = 0;
        const data = options.parsed, lexer = "script", scopes = prettydiff.scopes, b = (prettydiff.end < 1 || prettydiff.end > data.token.length)
            ? data.token.length
            : prettydiff.end + 1, externalIndex = {}, 
        // levels sets the white space value between the current token and the next token
        // * -20 value means no white space
        // * -10 means to separate with a space
        // * 0 and above is the number of indentation to insert
        levels = (function beautify_script_level() {
            let a = prettydiff.start, //will store the current level of indentation
            indent = (isNaN(options.indent_level) === true)
                ? 0
                : Number(options.indent_level), notcomment = false, // if in comments before any code
            lastlist = false, //remembers the list status of the most recently closed block
            ctype = "", //ctype stands for "current type"
            ctoke = "", //ctoke standa for "current token"
            ltype = data.types[0], //ltype stands for "last type"
            ltoke = data.token[0]; //ltype stands for "last token"
            const varindex = [-1], //index in current scope of last var, let, or const keyword
            list = [], //stores comma status of current block
            level = (prettydiff.start > 0)
                ? Array(prettydiff.start).fill(0, 0, prettydiff.start)
                : [], ternary = [], //used to identify ternary statments
            extraindent = [
                []
            ], //stores token indexes where extra indentation occurs from ternaries and broken method chains
            arrbreak = [], //array where a method break has occurred
            destruct = [], //attempt to identify object destructuring
            itemcount = [], //counts items in destructured lists
            assignlist = [false], //are you in a list right now?
            wordlist = [], count = [], comment = function beautify_script_level_comment() {
                destructfix(false, false);
                let ind = (options.comments === true)
                    ? 0
                    : indent;
                if (notcomment === false && (/\/\u002a\s*global\s/).test(data.token[a]) === true) {
                    let globallist = data.token[a].replace(/\/\u002a\s*global\s+/, "").replace(/\s*\u002a\/$/, "").split(","), aa = globallist.length;
                    do {
                        aa = aa - 1;
                        globallist[aa] = globallist[aa].replace(/\s+/g, "");
                        if (globallist[aa] !== "") {
                            scopes.push([globallist[aa], -1]);
                        }
                    } while (aa > 0);
                }
                if (data.types[a - 1] === "comment" || data.types[a + 1] === "comment") {
                    level[a - 1] = ind;
                }
                else if (data.lines[a] < 2) {
                    let aa = a + 1;
                    if (data.types[aa] === "comment") {
                        do {
                            aa = aa + 1;
                        } while (aa < b && data.types[aa] === "comment");
                    }
                    if (a < b - 1 && data.stack[aa] !== "block" && (data.token[aa] === "{" || data.token[aa] === "x{")) {
                        let bb = scopes.length;
                        data.begin.splice(a, 0, data.begin[aa]);
                        data.ender.splice(a, 0, data.ender[aa]);
                        data.lexer.splice(a, 0, data.lexer[aa]);
                        data.lines.splice(a, 0, data.lines[aa]);
                        data.stack.splice(a, 0, data.stack[aa]);
                        data.token.splice(a, 0, data.token[aa]);
                        data.types.splice(a, 0, data.types[aa]);
                        if (bb > 0) {
                            do {
                                bb = bb - 1;
                                if (scopes[bb][1] === aa) {
                                    scopes[bb][1] = a;
                                }
                                else if (scopes[bb][1] < a) {
                                    break;
                                }
                            } while (bb > 0);
                        }
                        aa = aa + 1;
                        data.begin.splice(aa, 1);
                        data.ender.splice(aa, 1);
                        data.lexer.splice(aa, 1);
                        data.lines.splice(aa, 1);
                        data.stack.splice(aa, 1);
                        data.token.splice(aa, 1);
                        data.types.splice(aa, 1);
                        bb = a + 1;
                        do {
                            data.begin[bb] = a;
                            data.stack[bb] = data.stack[aa];
                            bb = bb + 1;
                        } while (bb < aa);
                        bb = bb + 1;
                        do {
                            if (data.begin[bb] === data.begin[aa]) {
                                data.begin[bb] = a;
                                if (data.types[bb] === "end") {
                                    break;
                                }
                            }
                            bb = bb + 1;
                        } while (bb < b - 1);
                        data.begin[aa] = a;
                        a = a - 1;
                    }
                    else {
                        level[a - 1] = -10;
                        if (data.stack[a] === "paren" || data.stack[a] === "method") {
                            level.push(indent + 2);
                        }
                        else {
                            level.push(indent);
                        }
                        if (options.comment_line === true && level[a] > -1 && data.lines[a] < 3) {
                            data.lines[a] = 3;
                        }
                    }
                    if (data.types[a + 1] !== "comment") {
                        notcomment = true;
                    }
                    return;
                }
                else if (data.token[a - 1] === ",") {
                    level[a - 1] = ind;
                }
                else if (ltoke === "=" && data.types[a - 1] !== "comment" && (/^(\/\*\*\s*@[a-z_]+\s)/).test(ctoke) === true) {
                    level[a - 1] = -10;
                }
                else if (ltoke === "{" && data.types[a - 1] !== "comment" && data.lines[0] < 2) {
                    level[a - 1] = -10;
                }
                else {
                    level[a - 1] = ind;
                }
                if (data.types[a + 1] !== "comment") {
                    notcomment = true;
                }
                if (data.token[data.begin[a]] === "(") {
                    level.push(indent + 1);
                }
                else {
                    level.push(indent);
                }
                if (options.comment_line === true && level[a] > -1 && data.lines[a] < 3) {
                    data.lines[a] = 3;
                }
            }, destructfix = function beautify_script_level_destructFix(listFix, override) {
                // listfix  - at the end of a list correct the containing list override - to
                // break arrays with more than 4 items into a vertical list
                let c = a - 1, d = (listFix === true)
                    ? 0
                    : 1;
                const ei = (extraindent[extraindent.length - 1] === undefined)
                    ? []
                    : extraindent[extraindent.length - 1], arrayCheck = (override === false && data.stack[a] === "array" && listFix === true && ctoke !== "[");
                if (destruct[destruct.length - 1] === false || (data.stack[a] === "array" && options.formatArray === "inline") || (data.stack[a] === "object" && options.format_object === "inline")) {
                    return;
                }
                destruct[destruct.length - 1] = false;
                do {
                    if (data.types[c] === "end") {
                        d = d + 1;
                    }
                    else if (data.types[c] === "start") {
                        d = d - 1;
                    }
                    if (data.stack[c] === "global") {
                        break;
                    }
                    if (d === 0) {
                        if (data.stack[a] === "class" || data.stack[a] === "map" || (arrayCheck === false && ((listFix === false && data.token[c] !== "(" && data.token[c] !== "x(") || (listFix === true && data.token[c] === ",")))) {
                            if (data.types[c + 1] === "template_start") {
                                if (data.lines[c] < 1) {
                                    level[c] = -20;
                                }
                                else {
                                    level[c] = indent - 1;
                                }
                            }
                            else if (ei.length > 0 && ei[ei.length - 1] > -1) {
                                level[c] = indent - 1;
                            }
                            else {
                                level[c] = indent;
                            }
                        }
                        else if (data.stack[a] === "array" && data.types[a] === "operator") {
                            if (data.token[c] === ",") {
                                level[c] = indent;
                            }
                            if (c === data.begin[a]) {
                                break;
                            }
                        }
                        if (listFix === false) {
                            break;
                        }
                    }
                    if (d < 0) {
                        if (data.types[c + 1] === "template_start" || data.types[c + 1] === "template_string_start") {
                            if (data.lines[c] < 1) {
                                level[c] = -20;
                            }
                            else {
                                level[c] = indent - 1;
                            }
                        }
                        else if (ei.length > 0 && ei[ei.length - 1] > -1) {
                            level[c] = indent - 1;
                        }
                        else {
                            level[c] = indent;
                        }
                        break;
                    }
                    c = c - 1;
                } while (c > -1);
            }, end = function beautify_script_level_end() {
                const ei = (extraindent[extraindent.length - 1] === undefined)
                    ? []
                    : extraindent[extraindent.length - 1], markupList = function beautify_script_level_end_markupList() {
                    let aa = a, markup = false;
                    const begin = data.begin[aa];
                    do {
                        aa = aa - 1;
                        if (data.lexer[aa] === "markup") {
                            markup = true;
                            break;
                        }
                        if (data.begin[aa] !== begin) {
                            aa = data.begin[aa];
                        }
                    } while (aa > begin);
                    if (markup === true) {
                        aa = a;
                        do {
                            aa = aa - 1;
                            if (data.begin[aa] !== begin) {
                                aa = data.begin[aa];
                            }
                            else if (data.token[aa] === ",") {
                                level[aa] = indent + 1;
                            }
                        } while (aa > begin);
                        level[begin] = indent + 1;
                        level[a - 1] = indent;
                    }
                    else {
                        level[a - 1] = -20;
                    }
                };
                if (ctoke === ")" && data.token[a + 1] === "." && ei[ei.length - 1] > -1 && data.token[ei[0]] !== ":") {
                    let c = data.begin[a], d = false, e = false;
                    do {
                        c = c - 1;
                    } while (c > 0 && level[c] < -9);
                    d = (level[c] === indent);
                    c = a + 1;
                    do {
                        c = c + 1;
                        if (data.token[c] === "{") {
                            e = true;
                            break;
                        }
                        if (data.begin[c] === data.begin[a + 1] && (data.types[c] === "separator" || data.types[c] === "end")) {
                            break;
                        }
                    } while (c < b);
                    if (d === false && e === true && extraindent.length > 1) {
                        extraindent[extraindent.length - 2].push(data.begin[a]);
                        indent = indent + 1;
                    }
                }
                if (ltype !== "separator") {
                    fixchain();
                }
                if (data.token[a + 1] === "," && (data.stack[a] === "object" || data.stack[a] === "array")) {
                    destructfix(true, false);
                }
                if ((data.token[a + 1] === "}" || data.token[a + 1] === "]") && (data.stack[a] === "object" || data.stack[a] === "array") && data.token[data.begin[a] - 1] === ",") {
                    destructfix(true, false);
                }
                if (data.stack[a] !== "attribute") {
                    if (ctoke !== ")" && ctoke !== "x)" && (data.lexer[a - 1] !== "markup" || (data.lexer[a - 1] === "markup" && data.token[a - 2] !== "return"))) {
                        indent = indent - 1;
                    }
                    if (ctoke === "}" && data.stack[a] === "switch" && options.no_case_indent === false) {
                        indent = indent - 1;
                    }
                }
                if (ctoke === "}" || ctoke === "x}") {
                    if (data.types[a - 1] !== "comment" &&
                        ltoke !== "{" &&
                        ltoke !== "x{" &&
                        ltype !== "end" &&
                        ltype !== "string" &&
                        ltype !== "number" &&
                        ltype !== "separator" &&
                        ltoke !== "++" &&
                        ltoke !== "--" &&
                        (a < 2 || data.token[a - 2] !== ";" || data.token[a - 2] !== "x;" || ltoke === "break" || ltoke === "return")) {
                        let c = a - 1, begin = data.begin[a], assign = false, listlen = list.length;
                        do {
                            if (data.begin[c] === begin) {
                                if (data.token[c] === "=" || data.token[c] === ";" || data.token[c] === "x;") {
                                    assign = true;
                                }
                                if (data.token[c] === "." && level[c - 1] > -1) {
                                    // setting destruct is necessary to prevent a rule below
                                    destruct[destruct.length - 1] = false;
                                    level[begin] = indent + 1;
                                    level[a - 1] = indent;
                                    break;
                                }
                                if (c > 0 && data.token[c] === "return" && (data.token[c - 1] === ")" || data.token[c - 1] === "x)" || data.token[c - 1] === "{" || data.token[c - 1] === "x{" || data.token[c - 1] === "}" || data.token[c - 1] === "x}" || data.token[c - 1] === ";" || data.token[c - 1] === "x;")) {
                                    indent = indent - 1;
                                    level[a - 1] = indent;
                                    break;
                                }
                                if ((data.token[c] === ":" && ternary.length === 0) ||
                                    (data.token[c] === "," && assign === false)) {
                                    break;
                                }
                                if ((c === 0 || data.token[c - 1] === "{" || data.token[c - 1] === "x{") || data.token[c] === "for" || data.token[c] === "if" || data.token[c] === "do" || data.token[c] === "function" || data.token[c] === "while" || data.token[c] === "var" || data.token[c] === "let" || data.token[c] === "const" || data.token[c] === "with") {
                                    if (list[listlen - 1] === false && listlen > 1 && (a === b - 1 || (data.token[a + 1] !== ")" && data.token[a + 1] !== "x)")) && data.stack[a] !== "object") {
                                        indent = indent - 1;
                                    }
                                    break;
                                }
                            }
                            else {
                                c = data.begin[c];
                            }
                            c = c - 1;
                        } while (c > begin);
                    }
                    varindex.pop();
                }
                if (options.brace_padding === false && ctoke !== "}" && ltype !== "markup") {
                    level[a - 1] = -20;
                }
                if (options.brace_padding === true && ltype !== "start" && ltoke !== ";" && (level[data.begin[a]] < -9 || destruct[destruct.length - 1] === true)) {
                    level[data.begin[a]] = -10;
                    level[a - 1] = -10;
                    level.push(-20);
                }
                else if (options.language === "qml") {
                    if (ltype === "start" || ctoke === ")" || ctoke === "x)") {
                        level[a - 1] = -20;
                    }
                    else {
                        level[a - 1] = indent;
                    }
                    level.push(indent);
                }
                else if (data.stack[a] === "attribute") {
                    level[a - 1] = -20;
                    level.push(indent);
                }
                else if (data.stack[a] === "array" && (ei.length > 0 || arrbreak[arrbreak.length - 1] === true)) {
                    endExtraInd();
                    destruct[destruct.length - 1] = false;
                    level[data.begin[a]] = indent + 1;
                    level[a - 1] = indent;
                    level.push(-20);
                }
                else if ((data.stack[a] === "object" || (data.begin[a] === 0 && ctoke === "}")) && ei.length > 0) {
                    endExtraInd();
                    destruct[destruct.length - 1] = false;
                    level[data.begin[a]] = indent + 1;
                    level[a - 1] = indent;
                    level.push(-20);
                }
                else if (ctoke === ")" || ctoke === "x)") {
                    const countx = (ctoke === ")" && ltoke !== "(" && count.length > 0)
                        ? count.pop() + 1
                        : 0, countIf = (data.token[data.begin[a] - 1] === "if")
                        ? (function beautify_script_level_end_countIf() {
                            let bb = a;
                            do {
                                bb = bb - 1;
                                if (data.token[bb] === ")" && level[bb - 1] > -1) {
                                    return countx;
                                }
                            } while (bb > data.begin[a]);
                            return countx + 5;
                        }())
                        : countx;
                    if (countx > 0 && (options.language !== "jsx" || (options.language === "jsx" && data.token[data.begin[a] - 1] !== "render"))) {
                        const wrap = options.wrap, begin = data.begin[a], len = count.length;
                        let aa = a - 2;
                        if (countIf > wrap) {
                            level[data.begin[a]] = indent + 1;
                            level[a - 1] = indent;
                            do {
                                if (data.begin[aa] === begin) {
                                    if (data.token[aa] === "&&" || data.token[aa] === "||") {
                                        level[aa] = indent + 1;
                                    }
                                    else if (level[aa] > -1 && data.types[aa] !== "comment" && data.token[aa + 1] !== ".") {
                                        level[aa] = level[aa] + 1;
                                    }
                                }
                                else if (level[aa] > -1 && data.token[aa + 1] !== ".") {
                                    level[aa] = level[aa] + 1;
                                }
                                aa = aa - 1;
                            } while (aa > begin);
                        }
                        else if (len > 0) {
                            count[len - 1] = count[len - 1] + countx;
                        }
                    }
                    else if (ctoke === ")" && a > data.begin[a] + 2 && data.lexer[data.begin[a] + 1] === lexer && data.token[data.begin[a] + 1] !== "function") {
                        const open = (data.begin[a] < 0)
                            ? 0
                            : data.begin[a];
                        let len = 0, aa = 0, short = 0, first = 0, inc = 0, comma = false, array = false, wrap = options.wrap, ind = (indent + 1), exl = ei.length, ready = false, mark = false, tern = false;
                        if (level[open] < -9) {
                            aa = open;
                            do {
                                aa = aa + 1;
                            } while (aa < a && level[aa] < -9);
                            first = aa;
                            do {
                                len = len + data.token[aa].length;
                                if (level[aa] === -10) {
                                    len = len + 1;
                                }
                                if (data.token[aa] === "(" && short > 0 && short < wrap - 1 && first === a) {
                                    short = -1;
                                }
                                if (data.token[aa] === ")") {
                                    inc = inc - 1;
                                }
                                else if (data.token[aa] === "(") {
                                    inc = inc + 1;
                                }
                                if (aa === open && inc > 0) {
                                    short = len;
                                }
                                aa = aa - 1;
                            } while (aa > open && level[aa] < -9);
                            if (data.token[aa + 1] === ".") {
                                ind = level[aa] + 1;
                            }
                            if (len > wrap - 1 && wrap > 0 && ltoke !== "(" && short !== -1 && destruct[destruct.length - 2] === false) {
                                if ((data.token[open - 1] === "if" && list[list.length - 1] === true) || data.token[open - 1] !== "if") {
                                    level[open] = ind;
                                    if (data.token[open - 1] === "for") {
                                        aa = open;
                                        do {
                                            aa = aa + 1;
                                            if (data.token[aa] === ";" && data.begin[aa] === open) {
                                                level[aa] = ind;
                                            }
                                        } while (aa < a);
                                    }
                                }
                            }
                        }
                        aa = a;
                        len = 0;
                        do {
                            aa = aa - 1;
                            if (data.stack[aa] === "function") {
                                aa = data.begin[aa];
                            }
                            else if (data.begin[aa] === open) {
                                if (data.token[aa] === "?") {
                                    tern = true;
                                }
                                else if (data.token[aa] === "," && comma === false) {
                                    comma = true;
                                    if (len >= wrap && wrap > 0) {
                                        ready = true;
                                    }
                                }
                                else if (data.types[aa] === "markup" && mark === false) {
                                    mark = true;
                                }
                                if (level[aa] > -9 && data.token[aa] !== "," && data.types[aa] !== "markup") {
                                    len = 0;
                                }
                                else {
                                    if (level[aa] === -10) {
                                        len = len + 1;
                                    }
                                    len = len + data.token[aa].length;
                                    if (len >= wrap && wrap > 0 && (comma === true || mark === true)) {
                                        ready = true;
                                    }
                                }
                            }
                            else {
                                if (level[aa] > -9) {
                                    len = 0;
                                }
                                else {
                                    len = len + data.token[aa].length;
                                    if (len >= wrap && wrap > 0 && (comma === true || mark === true)) {
                                        ready = true;
                                    }
                                }
                            }
                        } while (aa > open && ready === false);
                        if (comma === false && data.token[data.begin[a] + 1].charAt(0) === "`") {
                            level[data.begin[a]] = -20;
                            level[a - 1] = -20;
                        }
                        else if (((comma === true || mark === true) && len >= wrap && wrap > 0) || level[open] > -9) {
                            if (tern === true) {
                                ind = level[open];
                                if (data.token[open - 1] === "[") {
                                    aa = a;
                                    do {
                                        aa = aa + 1;
                                        if (data.types[aa] === "end" || data.token[aa] === "," || data.token[aa] === ";") {
                                            break;
                                        }
                                    } while (aa < b);
                                    if (data.token[aa] === "]") {
                                        ind = ind - 1;
                                        array = true;
                                    }
                                }
                            }
                            else if (exl > 0 && ei[exl - 1] > aa) {
                                ind = ind - exl;
                            }
                            destruct[destruct.length - 1] = false;
                            aa = a;
                            do {
                                aa = aa - 1;
                                if (data.begin[aa] === open) {
                                    if (data.token[aa].indexOf("=") > -1 && data.types[aa] === "operator" && data.token[aa].indexOf("!") < 0 && data.token[aa].indexOf("==") < 0 && data.token[aa] !== "<=" && data.token[aa].indexOf(">") < 0) {
                                        len = aa;
                                        do {
                                            len = len - 1;
                                            if (data.begin[len] === open && (data.token[len] === ";" || data.token[len] === "," || len === open)) {
                                                break;
                                            }
                                        } while (len > open);
                                    }
                                    else if (data.token[aa] === ",") {
                                        level[aa] = ind;
                                    }
                                    else if (level[aa] > -9 && array === false && (data.token[open - 1] !== "for" || data.token[aa + 1] === "?" || data.token[aa + 1] === ":") && (data.token[data.begin[a]] !== "(" || data.token[aa] !== "+")) {
                                        level[aa] = level[aa] + 1;
                                    }
                                }
                                else if (level[aa] > -9 && array === false) {
                                    level[aa] = level[aa] + 1;
                                }
                            } while (aa > open);
                            level[open] = ind;
                            level[a - 1] = ind - 1;
                        }
                        else {
                            level[a - 1] = -20;
                        }
                        if (data.token[data.begin[a] - 1] === "+" && level[data.begin[a]] > -9) {
                            level[data.begin[a] - 1] = -10;
                        }
                    }
                    else if (options.language === "jsx") {
                        markupList();
                    }
                    else {
                        level[a - 1] = -20;
                    }
                    level.push(-20);
                }
                else if (destruct[destruct.length - 1] === true) {
                    if (ctoke === "]" && data.begin[a] - 1 > 0 && data.token[data.begin[data.begin[a] - 1]] === "[") {
                        destruct[destruct.length - 2] = false;
                    }
                    if (data.begin[a] < level.length) {
                        level[data.begin[a]] = -20;
                    }
                    if (options.language === "jsx") {
                        markupList();
                    }
                    else if (ctoke === "]" && level[data.begin[a]] > -1) {
                        level[a - 1] = level[data.begin[a]] - 1;
                    }
                    else {
                        level[a - 1] = -20;
                    }
                    level.push(-20);
                }
                else if (data.types[a - 1] === "comment" && data.token[a - 1].substr(0, 2) === "//") {
                    if (data.token[a - 2] === "x}") {
                        level[a - 3] = indent + 1;
                    }
                    level[a - 1] = indent;
                    level.push(-20);
                }
                else if (data.types[a - 1] !== "comment" && ((ltoke === "{" && ctoke === "}") || (ltoke === "[" && ctoke === "]"))) {
                    level[a - 1] = -20;
                    if (ctoke === "}" && options.language === "titanium") {
                        level.push(indent);
                    }
                    else {
                        level.push(-20);
                    }
                }
                else if (ctoke === "]") {
                    if ((list[list.length - 1] === true && destruct[destruct.length - 1] === false && options.format_array !== "inline") || (ltoke === "]" && level[a - 2] === indent + 1)) {
                        level[a - 1] = indent;
                        level[data.begin[a]] = indent + 1;
                    }
                    else if (level[a - 1] === -10) {
                        level[a - 1] = -20;
                    }
                    if (data.token[data.begin[a] + 1] === "function") {
                        level[a - 1] = indent;
                    }
                    else if (list[list.length - 1] === false) {
                        if (ltoke === "}" || ltoke === "x}") {
                            level[a - 1] = indent;
                        }
                        let c = a - 1, d = 1;
                        do {
                            if (data.token[c] === "]") {
                                d = d + 1;
                            }
                            if (data.token[c] === "[") {
                                d = d - 1;
                                if (d === 0) {
                                    if (c > 0 && (data.token[c + 1] === "{" || data.token[c + 1] === "x{" || data.token[c + 1] === "[")) {
                                        level[c] = indent + 1;
                                        break;
                                    }
                                    if (data.token[c + 1] !== "[" || lastlist === false) {
                                        level[c] = -20;
                                        break;
                                    }
                                    break;
                                }
                            }
                            if (d === 1 && data.token[c] === "+" && level[c] > 1) {
                                level[c] = level[c] - 1;
                            }
                            c = c - 1;
                        } while (c > -1);
                    }
                    else if (options.language === "jsx") {
                        markupList();
                    }
                    if (options.format_array === "inline") {
                        let c = a, begin = data.begin[a];
                        do {
                            c = c - 1;
                            if (data.types[c] === "end") {
                                break;
                            }
                        } while (c > begin);
                        if (c > begin) {
                            level[data.begin[a]] = indent + 1;
                            level[a - 1] = indent;
                        }
                        else {
                            level[data.begin[a]] = -20;
                            level[a - 1] = -20;
                        }
                    }
                    else if (level[data.begin[a]] > -1) {
                        level[a - 1] = level[data.begin[a]] - 1;
                    }
                    level.push(-20);
                }
                else if (ctoke === "}" || ctoke === "x}" || list[list.length - 1] === true) {
                    if (ctoke === "}" && ltoke === "x}" && data.token[a + 1] === "else") {
                        level[a - 2] = indent + 2;
                        level.push(-20);
                    }
                    else {
                        level.push(indent);
                    }
                    level[a - 1] = indent;
                }
                else {
                    level.push(-20);
                }
                if (data.types[a - 1] === "comment") {
                    level[a - 1] = indent;
                }
                endExtraInd();
                lastlist = list[list.length - 1];
                list.pop();
                extraindent.pop();
                arrbreak.pop();
                itemcount.pop();
                wordlist.pop();
                destruct.pop();
                assignlist.pop();
            }, endExtraInd = function beautify_script_level_endExtraInd() {
                const ei = extraindent[extraindent.length - 1];
                let c = 0;
                if (ei === undefined) {
                    return;
                }
                c = ei.length - 1;
                if (c < 1 && ei[c] < 0 && (ctoke === ";" || ctoke === "x;" || ctoke === ")" || ctoke === "x)" || ctoke === "}" || ctoke === "x}")) {
                    ei.pop();
                    return;
                }
                if (c < 0 || ei[c] < 0) {
                    return;
                }
                if (ctoke === ":") {
                    if (data.token[ei[c]] !== "?") {
                        do {
                            ei.pop();
                            c = c - 1;
                            indent = indent - 1;
                        } while (c > -1 && ei[c] > -1 && data.token[ei[c]] !== "?");
                    }
                    ei[c] = a;
                    level[a - 1] = indent;
                }
                else {
                    do {
                        ei.pop();
                        c = c - 1;
                        indent = indent - 1;
                    } while (c > -1 && ei[c] > -1);
                }
                if ((data.stack[a] === "array" || ctoke === ",") && ei.length < 1) {
                    ei.push(-1);
                }
            }, external = function beautify_script_level_external() {
                let skip = a;
                do {
                    if (data.lexer[a + 1] === lexer && data.begin[a + 1] < skip) {
                        break;
                    }
                    if (data.token[skip - 1] === "return" && data.types[a] === "end" && data.begin[a] === skip) {
                        break;
                    }
                    level.push(0);
                    a = a + 1;
                } while (a < b);
                externalIndex[skip] = a;
                level.push(indent - 1);
            }, fixchain = function beautify_script_level_fixchain() {
                let bb = a - 1, cc = data.begin[a];
                if (indent < 1) {
                    return;
                }
                do {
                    if (cc !== data.begin[bb]) {
                        bb = data.begin[bb];
                    }
                    else {
                        if (data.types[bb] === "separator" || data.types[bb] === "operator") {
                            if (data.token[bb] === "." && level[bb - 1] > 0) {
                                if (data.token[cc - 1] === "if") {
                                    indent = indent - 2;
                                }
                                else {
                                    indent = indent - 1;
                                }
                            }
                            break;
                        }
                    }
                    bb = bb - 1;
                } while (bb > 0 && bb > cc);
            }, markup = function beautify_script_level_markup() {
                if ((data.token[a + 1] !== "," && ctoke.indexOf("/>") !== ctoke.length - 2) || (data.token[a + 1] === "," && data.token[data.begin[a] - 3] !== "React")) {
                    destructfix(false, false);
                }
                if (ltoke === "return" || ltoke === "?" || ltoke === ":") {
                    level[a - 1] = -10;
                    level.push(-20);
                }
                else if (ltype === "start" || (data.token[a - 2] === "return" && data.stack[a - 1] === "method")) {
                    level.push(indent);
                }
                else {
                    level.push(-20);
                }
            }, operator = function beautify_script_level_operator() {
                const ei = (extraindent[extraindent.length - 1] === undefined)
                    ? []
                    : extraindent[extraindent.length - 1], opWrap = function beautify_script_level_operator_opWrap() {
                    const aa = data.token[a + 1];
                    let line = 0, next = 0, c = a, ind = (ctoke === "+")
                        ? indent + 2
                        : indent, meth = 0;
                    if (options.wrap < 1) {
                        level.push(-10);
                        return;
                    }
                    do {
                        c = c - 1;
                        if (data.token[data.begin[a]] === "(") {
                            if (c === data.begin[a]) {
                                meth = line;
                            }
                            if (data.token[c] === "," && data.begin[c] === data.begin[a] && list[list.length - 1] === true) {
                                break;
                            }
                        }
                        if (line > options.wrap - 1) {
                            break;
                        }
                        if (level[c] > -9) {
                            break;
                        }
                        if (data.types[c] === "operator" && data.token[c] !== "=" && data.token[c] !== "+" && data.begin[c] === data.begin[a]) {
                            break;
                        }
                        line = line + data.token[c].length;
                        if (c === data.begin[a] && data.token[c] === "[" && line < options.wrap - 1) {
                            break;
                        }
                        if (data.token[c] === "." && level[c] > -9) {
                            break;
                        }
                        if (level[c] === -10) {
                            line = line + 1;
                        }
                    } while (c > 0);
                    if (meth > 0) {
                        meth = meth + aa.length;
                    }
                    line = line + aa.length;
                    next = c;
                    if (line > options.wrap - 1 && level[c] < -9) {
                        do {
                            next = next - 1;
                        } while (next > 0 && level[next] < -9);
                    }
                    if (data.token[next + 1] === "." && data.begin[a] <= data.begin[next]) {
                        ind = ind + 1;
                    }
                    else if (data.types[next] === "operator") {
                        ind = level[next];
                    }
                    next = aa.length;
                    if (line + next < options.wrap) {
                        level.push(-10);
                        return;
                    }
                    if (data.token[data.begin[a]] === "(" && (data.token[ei[0]] === ":" || data.token[ei[0]] === "?")) {
                        ind = indent + 3;
                    }
                    else if (data.stack[a] === "method") {
                        level[data.begin[a]] = indent;
                        if (list[list.length - 1] === true) {
                            ind = indent + 3;
                        }
                        else {
                            ind = indent + 1;
                        }
                    }
                    else if (data.stack[a] === "object" || data.stack[a] === "array") {
                        destructfix(true, false);
                    }
                    if (data.token[c] === "var" || data.token[c] === "let" || data.token[c] === "const") {
                        line = line - (options.indent_size * options.indent_char.length * 2);
                    }
                    if (meth > 0) {
                        c = options.wrap - meth;
                    }
                    else {
                        c = options.wrap - line;
                    }
                    if (c > 0 && c < 5) {
                        level.push(ind);
                        if (data.token[a].charAt(0) === "\"" || data.token[a].charAt(0) === "'") {
                            a = a + 1;
                            level.push(-10);
                        }
                        return;
                    }
                    if (data.token[data.begin[a]] !== "(" || meth > options.wrap - 1 || meth === 0) {
                        if (meth > 0) {
                            line = meth;
                        }
                        if (line - aa.length < options.wrap - 1 && (aa.charAt(0) === "\"" || aa.charAt(0) === "'")) {
                            a = a + 1;
                            line = line + 3;
                            if (line - aa.length > options.wrap - 4) {
                                level.push(ind);
                                return;
                            }
                            level.push(-10);
                            return;
                        }
                        level.push(ind);
                        return;
                    }
                    level.push(-10);
                };
                fixchain();
                if (ei.length > 0 && ei[ei.length - 1] > -1 && data.stack[a] === "array") {
                    arrbreak[arrbreak.length - 1] = true;
                }
                if (ctoke !== ":") {
                    if (data.token[data.begin[a]] !== "(" && data.token[data.begin[a]] !== "x(" && destruct.length > 0) {
                        destructfix(true, false);
                    }
                    if (ctoke !== "?" && data.token[ei[ei.length - 1]] === ".") {
                        let c = a, d = data.begin[c], e = 0;
                        do {
                            if (data.begin[c] === d) {
                                if (data.token[c + 1] === "{" || data.token[c + 1] === "[" || data.token[c] === "function") {
                                    break;
                                }
                                if (data.token[c] === "," || data.token[c] === ";" || data.types[c] === "end" || data.token[c] === ":") {
                                    ei.pop();
                                    indent = indent - 1;
                                    break;
                                }
                                if (data.token[c] === "?" || data.token[c] === ":") {
                                    if (data.token[ei[ei.length - 1]] === "." && e < 2) {
                                        ei[ei.length - 1] = d + 1;
                                    }
                                    break;
                                }
                                if (data.token[c] === ".") {
                                    e = e + 1;
                                }
                            }
                            c = c + 1;
                        } while (c < b);
                    }
                }
                if (ctoke === "!" || ctoke === "...") {
                    if (ltoke === "}" || ltoke === "x}") {
                        level[a - 1] = indent;
                    }
                    level.push(-20);
                    return;
                }
                if (ltoke === ";" || ltoke === "x;") {
                    if (data.token[data.begin[a] - 1] !== "for") {
                        level[a - 1] = indent;
                    }
                    level.push(-20);
                    return;
                }
                if (ctoke === "*") {
                    if (ltoke === "function" || ltoke === "yield") {
                        level[a - 1] = -20;
                    }
                    else {
                        level[a - 1] = -10;
                    }
                    level.push(-10);
                    return;
                }
                if (ctoke === "?") {
                    if (data.lines[a] === 0 && data.types[a - 2] === "word" && data.token[a - 2] !== "return" && data.token[a - 2] !== "in" && data.token[a - 2] !== "instanceof" && data.token[a - 2] !== "typeof" && (ltype === "reference" || ltype === "word")) {
                        if (data.types[a + 1] === "word" || data.types[a + 1] === "reference" || ((data.token[a + 1] === "(" || data.token[a + 1] === "x(") && data.token[a - 2] === "new")) {
                            level[a - 1] = -20;
                            if (data.types[a + 1] === "word" || data.types[a + 1] === "reference") {
                                level.push(-10);
                                return;
                            }
                            level.push(-20);
                            return;
                        }
                    }
                    if (data.token[a + 1] === ":") {
                        level[a - 1] = -20;
                        level.push(-20);
                        return;
                    }
                    ternary.push(a);
                    if (options.ternary_line === true) {
                        level[a - 1] = -10;
                    }
                    else {
                        let c = a - 1;
                        do {
                            c = c - 1;
                        } while (c > -1 && level[c] < -9);
                        ei.push(a);
                        indent = indent + 1;
                        if (level[c] === indent && data.token[c + 1] !== ":") {
                            indent = indent + 1;
                            ei.push(a);
                        }
                        level[a - 1] = indent;
                        if (data.token[data.begin[a]] === "(" && (ei.length < 2 || ei[0] === ei[1])) {
                            destruct[destruct.length - 1] = false;
                            if (a - 2 === data.begin[a]) {
                                level[data.begin[a]] = indent - 1;
                            }
                            else {
                                level[data.begin[a]] = indent;
                            }
                            c = a - 2;
                            do {
                                if (data.types[c] === "end" && level[c - 1] > -1) {
                                    break;
                                }
                                if (level[c] > -1) {
                                    level[c] = level[c] + 1;
                                }
                                c = c - 1;
                            } while (c > data.begin[a]);
                        }
                    }
                    level.push(-10);
                    return;
                }
                if (ctoke === ":") {
                    if (data.stack[a] === "map" || data.types[a + 1] === "type" || data.types[a + 1] === "type_start") {
                        level[a - 1] = -20;
                        level.push(-10);
                        return;
                    }
                    if (ternary.length > 0 && data.begin[ternary[ternary.length - 1]] === data.begin[a]) {
                        let c = a, d = data.begin[a];
                        do {
                            c = c - 1;
                            if (data.begin[c] === d) {
                                if (data.token[c] === "," || data.token[c] === ";") {
                                    level[a - 1] = -20;
                                    break;
                                }
                                if (data.token[c] === "?") {
                                    ternary.pop();
                                    endExtraInd();
                                    if (options.ternary_line === true) {
                                        level[a - 1] = -10;
                                    }
                                    level.push(-10);
                                    return;
                                }
                            }
                            else if (data.types[c] === "end") {
                                c = data.begin[c];
                            }
                        } while (c > d);
                    }
                    if (data.token[a - 2] === "where" && data.stack[a - 2] === data.stack[a]) {
                        level[a - 1] = -10;
                        level.push(-10);
                        return;
                    }
                    if (ltype === "reference" && data.token[data.begin[a]] !== "(" && data.token[data.begin[a]] !== "x(") {
                        level[a - 1] = -20;
                        level.push(-10);
                        return;
                    }
                    if ((ltoke === ")" || ltoke === "x)") && data.token[data.begin[a - 1] - 2] === "function") {
                        level[a - 1] = -20;
                        level.push(-10);
                        return;
                    }
                    if (data.stack[a] === "attribute") {
                        level[a - 1] = -20;
                        level.push(-10);
                        return;
                    }
                    if (data.token[data.begin[a]] !== "(" &&
                        data.token[data.begin[a]] !== "x(" &&
                        (ltype === "reference" || ltoke === ")" || ltoke === "]" || ltoke === "?") &&
                        (data.stack[a] === "map" || data.stack[a] === "class" || data.types[a + 1] === "reference") &&
                        (ternary.length === 0 || ternary[ternary.length - 1] < data.begin[a]) &&
                        ("mapclassexpressionmethodglobalparen".indexOf(data.stack[a]) > -1 || (data.types[a - 2] === "word" && data.stack[a] !== "switch"))) {
                        level[a - 1] = -20;
                        level.push(-10);
                        return;
                    }
                    if (data.stack[a] === "switch" && (ternary.length < 1 || ternary[ternary.length - 1] < data.begin[a])) {
                        level[a - 1] = -20;
                        if (options.case_space === true) {
                            level.push(-10);
                        }
                        else {
                            level.push(indent);
                        }
                        return;
                    }
                    if (data.stack[a] === "object") {
                        level[a - 1] = -20;
                    }
                    else if (ternary.length > 0) {
                        level[a - 1] = indent;
                    }
                    else {
                        level[a - 1] = -10;
                    }
                    level.push(-10);
                    return;
                }
                if (ctoke === "++" || ctoke === "--") {
                    if (ltype === "number" || ltype === "reference") {
                        level[a - 1] = -20;
                        level.push(-10);
                    }
                    else if (a < b - 1 && (data.types[a + 1] === "number" || data.types[a + 1] === "reference")) {
                        level.push(-20);
                    }
                    else {
                        level.push(-10);
                    }
                    return;
                }
                if (ctoke === "+") {
                    if (ltype === "start") {
                        level[a - 1] = -20;
                    }
                    else {
                        level[a - 1] = -10;
                    }
                    if (options.wrap < 1 || data.token[data.begin[a]] === "x(") {
                        level.push(-10);
                        return;
                    }
                    let aa = data.token[a + 1];
                    if (aa === undefined) {
                        level.push(-10);
                        return;
                    }
                    if (data.types[a - 1] === "operator" || data.types[a - 1] === "start") {
                        if (data.types[a + 1] === "reference" || aa === "(" || aa === "[") {
                            level.push(-20);
                            return;
                        }
                        if (Number(aa.slice(1, -1)) > -1 && ((/\d/).test(aa.charAt(1)) === true || aa.charAt(1) === "." || aa.charAt(1) === "-" || aa.charAt(1) === "+")) {
                            level.push(-20);
                            return;
                        }
                    }
                    return opWrap();
                }
                if (data.types[a - 1] !== "comment") {
                    if (ltoke === "(") {
                        level[a - 1] = -20;
                    }
                    else if (ctoke === "*" && data.stack[a] === "object" && data.types[a + 1] === "reference" && (ltoke === "{" || ltoke === ",")) {
                        level[a - 1] = indent;
                    }
                    else if (ctoke !== "?" || ternary.length === 0) {
                        level[a - 1] = -10;
                    }
                }
                if (ctoke.indexOf("=") > -1 && ctoke !== "==" && ctoke !== "===" && ctoke !== "!=" && ctoke !== "!==" && ctoke !== ">=" && ctoke !== "<=" && ctoke !== "=>" && data.stack[a] !== "method" && data.stack[a] !== "object") {
                    let c = a + 1, d = 0, e = false, f = "";
                    if ((data.token[data.begin[a]] === "(" || data.token[data.begin[a]] === "x(") && data.token[a + 1] !== "function") {
                        return;
                    }
                    do {
                        if (data.types[c] === "start") {
                            if (e === true && data.token[c] !== "[") {
                                if (assignlist[assignlist.length - 1] === true) {
                                    assignlist[assignlist.length - 1] = false;
                                }
                                break;
                            }
                            d = d + 1;
                        }
                        if (data.types[c] === "end") {
                            d = d - 1;
                        }
                        if (d < 0) {
                            if (assignlist[assignlist.length - 1] === true) {
                                assignlist[assignlist.length - 1] = false;
                            }
                            break;
                        }
                        if (d === 0) {
                            f = data.token[c];
                            if (e === true) {
                                if (data.types[c] === "operator" || data.token[c] === ";" || data.token[c] === "x;" || data.token[c] === "?" || data.token[c] === "var" || data.token[c] === "let" || data.token[c] === "const") {
                                    if (f !== undefined && (f === "?" || (f.indexOf("=") > -1 && f !== "==" && f !== "===" && f !== "!=" && f !== "!==" && f !== ">=" && f !== "<="))) {
                                        if (assignlist[assignlist.length - 1] === false) {
                                            assignlist[assignlist.length - 1] = true;
                                        }
                                    }
                                    if ((f === ";" || f === "x;" || f === "var" || f === "let" || f === "const") && assignlist[assignlist.length - 1] === true) {
                                        assignlist[assignlist.length - 1] = false;
                                    }
                                    break;
                                }
                                if (assignlist[assignlist.length - 1] === true && (f === "return" || f === "break" || f === "continue" || f === "throw")) {
                                    assignlist[assignlist.length - 1] = false;
                                }
                            }
                            if (f === ";" || f === "x;" || f === ",") {
                                e = true;
                            }
                        }
                        c = c + 1;
                    } while (c < b);
                    level.push(-10);
                    return;
                }
                if ((ctoke === "-" && ltoke === "return") || ltoke === "=") {
                    level.push(-20);
                    return;
                }
                if (ltype === "operator" && data.types[a + 1] === "reference" && ltoke !== "--" && ltoke !== "++" && ctoke !== "&&" && ctoke !== "||") {
                    level.push(-20);
                    return;
                }
                return opWrap();
            }, reference = function beautify_script_level_reference() {
                const hoist = function beautify_script_level_reference_hoist() {
                    let func = data.begin[a];
                    if (func < 0) {
                        scopes.push([data.token[a], -1]);
                    }
                    else {
                        if (data.stack[func + 1] !== "function") {
                            do {
                                func = data.begin[func];
                            } while (func > -1 && data.stack[func + 1] !== "function");
                        }
                        scopes.push([data.token[a], func]);
                    }
                };
                if (data.types[a - 1] === "comment") {
                    level[a - 1] = indent;
                }
                else if (ltype === "end" && ltoke !== ")" && data.token[data.begin[a - 1] - 1] !== ")") {
                    level[a - 1] = -10;
                }
                else if (ltype !== "separator" && ltype !== "start" && ltype !== "end" && ltype.indexOf("template_string") < 0) {
                    if (ltype === "word" || ltype === "operator" || ltype === "property" || ltype === "type" || ltype === "reference") {
                        level[a - 1] = -10;
                    }
                    else {
                        level[a - 1] = -20;
                    }
                }
                if (ltoke === "var" && data.lexer[a - 1] === lexer) {
                    // hoisted references following declaration keyword
                    hoist();
                }
                else if (ltoke === "function") {
                    scopes.push([data.token[a], a]);
                }
                else if (ltoke === "let" || ltoke === "const") {
                    // not hoisted references following declaration keyword
                    scopes.push([data.token[a], a]);
                }
                else if (data.stack[a] === "arguments") {
                    scopes.push([data.token[a], a]);
                }
                else if (ltoke === ",") {
                    // references following a comma, must be tested to see if a declaration list
                    let index = a;
                    do {
                        index = index - 1;
                    } while (index > data.begin[a] && data.token[index] !== "var" && data.token[index] !== "let" && data.token[index] !== "const");
                    if (data.token[index] === "var") {
                        hoist();
                    }
                    else if (data.token[index] === "let" || data.token[index] === "const") {
                        scopes.push([data.token[a], a]);
                    }
                }
                level.push(-10);
            }, separator = function beautify_script_level_separator() {
                const ei = (extraindent[extraindent.length - 1] === undefined)
                    ? []
                    : extraindent[extraindent.length - 1], propertybreak = function beautify_script_level_separator_propertybreak() {
                    if (options.method_chain > 0) {
                        let x = a, y = data.begin[a], z = [a], ify = (data.token[y - 1] === "if");
                        do {
                            x = x - 1;
                            if (data.types[x] === "end") {
                                x = data.begin[x];
                            }
                            if (data.begin[x] === y) {
                                if (data.types[x] === "string" && data.token[x].indexOf("${") === data.token[x].length - 2) {
                                    break;
                                }
                                if (data.token[x] === ".") {
                                    if (level[x - 1] > 0) {
                                        level[a - 1] = (ify === true)
                                            ? indent + 1
                                            : indent;
                                        return;
                                    }
                                    z.push(x);
                                }
                                else if (data.token[x] === ";" ||
                                    data.token[x] === "," ||
                                    data.types[x] === "operator" ||
                                    ((data.types[x] === "word" || data.types[x] === "reference") &&
                                        (data.types[x - 1] === "word" || data.types[x - 1] === "reference"))) {
                                    break;
                                }
                            }
                        } while (x > y);
                        if (z.length < options.method_chain) {
                            level[a - 1] = -20;
                            return;
                        }
                        x = 0;
                        y = z.length;
                        do {
                            level[z[x] - 1] = (ify === true)
                                ? indent + 1
                                : indent;
                            x = x + 1;
                        } while (x < y);
                        x = z[z.length - 1] - 1;
                        do {
                            if (level[x] > -1) {
                                level[x] = level[x] + 1;
                            }
                            x = x + 1;
                        } while (x < a);
                        indent = (ify === true)
                            ? indent + 2
                            : indent + 1;
                    }
                    level[a - 1] = indent;
                };
                if (ctoke === "::") {
                    level[a - 1] = -20;
                    level.push(-20);
                    return;
                }
                if (ctoke === ".") {
                    if (data.token[data.begin[a]] !== "(" && data.token[data.begin[a]] !== "x(" && ei.length > 0) {
                        if (data.stack[a] === "object" || data.stack[a] === "array") {
                            destructfix(true, false);
                        }
                        else {
                            destructfix(false, false);
                        }
                    }
                    if (options.method_chain === 0) {
                        // methodchain is 0 so methods and properties should be chained together
                        level[a - 1] = -20;
                    }
                    else if (options.method_chain < 0) {
                        if (data.lines[a] > 0) {
                            propertybreak();
                        }
                        else {
                            level[a - 1] = -20;
                        }
                    }
                    else {
                        // methodchain is greater than 0 and should break methods if the chain reaches this value
                        propertybreak();
                    }
                    level.push(-20);
                    return;
                }
                if (ctoke === ",") {
                    fixchain();
                    if (list[list.length - 1] === false && (data.stack[a] === "object" || data.stack[a] === "array" || data.stack[a] === "paren" || data.stack[a] === "expression" || data.stack[a] === "method")) {
                        list[list.length - 1] = true;
                        if (data.token[data.begin[a]] === "(") {
                            let aa = a;
                            do {
                                aa = aa - 1;
                                if (data.begin[aa] === data.begin[a] && data.token[aa] === "+" && level[aa] > -9) {
                                    level[aa] = level[aa] + 2;
                                }
                            } while (aa > data.begin[a]);
                        }
                    }
                    if (data.stack[a] === "array" && options.format_array === "indent") {
                        level[a - 1] = -20;
                        level.push(indent);
                        return;
                    }
                    if (data.stack[a] === "array" && options.format_array === "inline") {
                        level[a - 1] = -20;
                        level.push(-10);
                        return;
                    }
                    if (data.stack[a] === "object" && options.format_object === "indent") {
                        level[a - 1] = -20;
                        level.push(indent);
                        return;
                    }
                    if (data.stack[a] === "object" && options.format_object === "inline") {
                        level[a - 1] = -20;
                        level.push(-10);
                        return;
                    }
                    if (ei.length > 0) {
                        if (ei[ei.length - 1] > -1) {
                            endExtraInd();
                        }
                        level[a - 1] = -20;
                        level.push(indent);
                        return;
                    }
                    if (data.token[a - 2] === ":" && data.token[a - 4] === "where") {
                        level[a - 1] = -20;
                        level.push(-10);
                        return;
                    }
                    level[a - 1] = -20;
                    if (data.types[a + 1] !== "end") {
                        itemcount[itemcount.length - 1] = itemcount[itemcount.length - 1] + 1;
                    }
                    if ((data.token[data.begin[a]] === "(" || data.token[data.begin[a]] === "x(") && options.language !== "jsx" && data.stack[a] !== "global" && ((data.types[a - 1] !== "string" && data.types[a - 1] !== "number") || data.token[a - 2] !== "+" || (data.types[a - 1] === "string" && data.types[a - 1] !== "number" && data.token[a - 2] === "+" && data.types[a - 3] !== "string" && data.types[a - 3] !== "number"))) {
                        level.push(-10);
                        return;
                    }
                    if (ltype === "reference" && data.types[a - 2] === "word" && "var-let-const-from".indexOf(data.token[a - 2]) < 0 && (data.types[a - 3] === "end" || data.token[a - 3] === ";")) {
                        wordlist[wordlist.length - 1] = true;
                        level.push(-10);
                        return;
                    }
                    if (wordlist[wordlist.length - 1] === true || data.stack[a] === "notation") {
                        level.push(-10);
                        return;
                    }
                    if (itemcount[itemcount.length - 1] > 3 && (data.stack[a] === "array" || data.stack[a] === "object")) {
                        if (destruct[destruct.length - 1] === true) {
                            destructfix(true, true);
                        }
                        level[a - 1] = -20;
                        if (arrbreak[arrbreak.length - 1] === true) {
                            level.push(indent);
                            return;
                        }
                        let begin = data.begin[a], c = a;
                        do {
                            if (data.types[c] === "end") {
                                c = data.begin[c];
                            }
                            else {
                                if (data.token[c] === "," && data.types[c + 1] !== "comment") {
                                    level[c] = indent;
                                }
                            }
                            c = c - 1;
                        } while (c > begin);
                        level[begin] = indent;
                        arrbreak[arrbreak.length - 1] = true;
                        return;
                    }
                    if (data.stack[a] === "object") {
                        if (destruct[destruct.length - 1] === true && data.types[data.begin[a] - 1] !== "word" && data.types[data.begin[a] - 1] !== "reference" && data.token[data.begin[a] - 1] !== "(" && data.token[data.begin[a] - 1] !== "x(") {
                            const bb = data.begin[a];
                            let aa = a - 1;
                            do {
                                if (data.begin[aa] === bb) {
                                    if (data.token[aa] === ",") {
                                        break;
                                    }
                                    if (data.token[aa] === ":") {
                                        destructfix(true, false);
                                        break;
                                    }
                                }
                                aa = aa - 1;
                            } while (aa > bb);
                        }
                    }
                    if ((data.types[a - 1] === "word" || data.types[a - 1] === "reference") && data.token[a - 2] === "for") {
                        //This is for Volt templates
                        level.push(-10);
                        return;
                    }
                    if (destruct[destruct.length - 1] === false || (data.token[a - 2] === "+" && (ltype === "string" || ltype === "number") && level[a - 2] > 0 && (ltoke.charAt(0) === "\"" || ltoke.charAt(0) === "'"))) {
                        if (data.stack[a] === "method") {
                            if (data.token[a - 2] === "+" && (ltoke.charAt(0) === "\"" || ltoke.charAt(0) === "'") && (data.token[a - 3].charAt(0) === "\"" || data.token[a - 3].charAt(0) === "'")) {
                                level.push(indent + 2);
                                return;
                            }
                            if (data.token[a - 2] !== "+") {
                                level.push(-10);
                                return;
                            }
                        }
                        level.push(indent);
                        return;
                    }
                    if (destruct[destruct.length - 1] === true && data.stack[a] !== "object") {
                        level.push(-10);
                        return;
                    }
                    if (itemcount[itemcount.length - 1] < 4 && (data.stack[a] === "array" || data.stack[a] === "object")) {
                        level.push(-10);
                        return;
                    }
                    level.push(indent);
                    return;
                }
                if (ctoke === ";" || ctoke === "x;") {
                    fixchain();
                    if (data.token[a + 1] !== undefined && data.types[a + 1].indexOf("attribute") > 0 && data.types[a + 1].indexOf("end") > 0) {
                        level[a - 1] = -20;
                        level.push(indent - 1);
                        return;
                    }
                    if (varindex[varindex.length - 1] > -1 && data.stack[varindex[varindex.length - 1]] !== "expression") {
                        let aa = a;
                        do {
                            aa = aa - 1;
                            if (data.token[aa] === ";") {
                                break;
                            }
                            if (data.token[aa] === ",") {
                                indent = indent - 1;
                                break;
                            }
                            if (data.types[aa] === "end") {
                                aa = data.begin[aa];
                            }
                        } while (aa > 0 && aa > data.begin[a]);
                    }
                    varindex[varindex.length - 1] = -1;
                    endExtraInd();
                    if (data.token[data.begin[a] - 1] !== "for") {
                        destructfix(false, false);
                    }
                    if (ctoke === "x;") {
                        scolon = scolon + 1;
                    }
                    wordlist[wordlist.length - 1] = false;
                    level[a - 1] = -20;
                    if (data.begin[a] > 0 && data.token[data.begin[a] - 1] === "for" && data.stack[a] !== "for") {
                        level.push(-10);
                        return;
                    }
                    level.push(indent);
                    return;
                }
                level.push(-20);
            }, start = function beautify_script_level_start() {
                const deep = data.stack[a + 1], deeper = (a === 0)
                    ? data.stack[a]
                    : data.stack[a - 1];
                if (ltoke === ")" || ((deeper === "object" || deeper === "array") && ltoke !== "]")) {
                    if (deep !== "method" || (deep === "method" && data.token[a + 1] !== ")" && data.token[a + 2] !== ")")) {
                        if (ltoke === ")" && (deep !== "function" || data.token[data.begin[data.begin[a - 1] - 1]] === "(" || data.token[data.begin[data.begin[a - 1] - 1]] === "x(")) {
                            destructfix(false, false);
                        }
                        else if (data.types[a + 1] !== "end" && data.types[a + 2] !== "end") {
                            destructfix(true, false);
                        }
                    }
                }
                list.push(false);
                extraindent.push([]);
                assignlist.push(false);
                arrbreak.push(false);
                wordlist.push(false);
                itemcount.push(0);
                if (options.never_flatten === true || (deep === "array" && options.format_array === "indent") || options.language === "qml" || deep === "attribute" || ltype === "generic" || (deep === "class" && ltoke !== "(" && ltoke !== "x(") || (ctoke === "[" && data.token[a + 1] === "function")) {
                    destruct.push(false);
                }
                else {
                    if (deep === "expression" || deep === "method") {
                        destruct.push(true);
                    }
                    else if ((deep === "object" || deep === "class") && (ltoke === "(" || ltoke === "x(" || ltype === "word" || ltype === "reference")) {
                        //array or object literal following `return` or `(`
                        destruct.push(true);
                    }
                    else if (deep === "array" || ctoke === "(" || ctoke === "x(") {
                        //array, method, paren
                        destruct.push(true);
                    }
                    else if (ctoke === "{" && deep === "object" && ltype !== "operator" && ltype !== "start" && ltype !== "string" && ltype !== "number" && deeper !== "object" && deeper !== "array" && a > 0) {
                        //curly brace not in a list and not assigned
                        destruct.push(true);
                    }
                    else {
                        //not destructured (multiline)
                        destruct.push(false);
                    }
                }
                if (ctoke !== "(" && ctoke !== "x(" && data.stack[a + 1] !== "attribute") {
                    indent = indent + 1;
                }
                if (ctoke === "{" || ctoke === "x{") {
                    varindex.push(-1);
                    if (data.types[a - 1] !== "comment") {
                        if (ltype === "markup") {
                            level[a - 1] = indent;
                        }
                        else if (options.braces === true && ltype !== "operator" && ltoke !== "return") {
                            level[a - 1] = indent - 1;
                        }
                        else if (data.stack[a + 1] !== "block" && (deep === "function" || ltoke === ")" || ltoke === "x)" || ltoke === "," || ltoke === "}" || ltype === "markup")) {
                            level[a - 1] = -10;
                        }
                        else if (ltoke === "{" || ltoke === "x{" || ltoke === "[" || ltoke === "}" || ltoke === "x}") {
                            level[a - 1] = indent - 1;
                        }
                    }
                    if (deep === "object") {
                        if (options.format_object === "indent") {
                            destruct[destruct.length - 1] = false;
                            level.push(indent);
                            return;
                        }
                        if (options.format_object === "inline") {
                            destruct[destruct.length - 1] = true;
                            level.push(-20);
                            return;
                        }
                    }
                    if (deep === "switch") {
                        if (options.no_case_indent === true) {
                            level.push(indent - 1);
                            return;
                        }
                        indent = indent + 1;
                        level.push(indent);
                        return;
                    }
                    if (destruct[destruct.length - 1] === true) {
                        if (ltype !== "word" && ltype !== "reference") {
                            level.push(-20);
                            return;
                        }
                    }
                    level.push(indent);
                    return;
                }
                if (ctoke === "(" || ctoke === "x(") {
                    if (options.wrap > 0 && ctoke === "(" && data.token[a + 1] !== ")") {
                        count.push(1);
                    }
                    if (ltoke === "-" && (data.token[a - 2] === "(" || data.token[a - 2] === "x(")) {
                        level[a - 2] = -20;
                    }
                    if (ltype === "end" && deeper !== "if" && deeper !== "for" && deeper !== "catch" && deeper !== "else" && deeper !== "do" && deeper !== "try" && deeper !== "finally" && deeper !== "catch") {
                        if (data.types[a - 1] === "comment") {
                            level[a - 1] = indent;
                        }
                        else {
                            level[a - 1] = -20;
                        }
                    }
                    if (ltoke === "async") {
                        level[a - 1] = -10;
                    }
                    else if (deep === "method" || (data.token[a - 2] === "function" && ltype === "reference")) {
                        if (ltoke === "import" || ltoke === "in" || options.function_name === true) {
                            level[a - 1] = -10;
                        }
                        else if ((ltoke === "}" && data.stack[a - 1] === "function") || ltype === "word" || ltype === "reference" || ltype === "property") {
                            level[a - 1] = -20;
                        }
                        else if (deeper !== "method" && deep !== "method") {
                            level[a - 1] = indent;
                        }
                    }
                    if (ltoke === "+" && (data.token[a - 2].charAt(0) === "\"" || data.token[a - 2].charAt(0) === "'")) {
                        level.push(indent);
                        return;
                    }
                    if (ltoke === "}" || ltoke === "x}") {
                        level.push(-20);
                        return;
                    }
                    if ((ltoke === "-" && (a < 2 || (data.token[a - 2] !== ")" && data.token[a - 2] !== "x)" && data.token[a - 2] !== "]" && data.types[a - 2] !== "reference" && data.types[a - 2] !== "string" && data.types[a - 2] !== "number"))) || (options.space === false && ltoke === "function")) {
                        level[a - 1] = -20;
                    }
                    level.push(-20);
                    return;
                }
                if (ctoke === "[") {
                    if (ltoke === "[") {
                        list[list.length - 2] = true;
                    }
                    if (ltoke === "return" || ltoke === "var" || ltoke === "let" || ltoke === "const") {
                        level[a - 1] = -10;
                    }
                    else if (data.types[a - 1] !== "comment" && data.stack[a - 1] !== "attribute" && (ltype === "end" || ltype === "word" || ltype === "reference")) {
                        level[a - 1] = -20;
                    }
                    else if (ltoke === "[" || ltoke === "{" || ltoke === "x{") {
                        level[a - 1] = indent - 1;
                    }
                    if (data.stack[a] === "attribute") {
                        level.push(-20);
                        return;
                    }
                    if (options.format_array === "indent") {
                        destruct[destruct.length - 1] = false;
                        level.push(indent);
                        return;
                    }
                    if (options.format_array === "inline") {
                        destruct[destruct.length - 1] = true;
                        level.push(-20);
                        return;
                    }
                    if (deep === "method" || destruct[destruct.length - 1] === true) {
                        level.push(-20);
                        return;
                    }
                    let c = a + 1;
                    do {
                        if (data.token[c] === "]") {
                            level.push(-20);
                            return;
                        }
                        if (data.token[c] === ",") {
                            level.push(indent);
                            return;
                        }
                        c = c + 1;
                    } while (c < b);
                    level.push(-20);
                    return;
                }
            }, string = function beautify_script_level_string() {
                if (ctoke.length === 1) {
                    level.push(-20);
                    if (data.lines[a] === 0) {
                        level[a - 1] = -20;
                    }
                }
                else if (ctoke.indexOf("#!/") === 0) {
                    level.push(indent);
                }
                else {
                    level.push(-10);
                }
                if ((ltoke === "," || ltype === "start") && (data.stack[a] === "object" || data.stack[a] === "array") && destruct[destruct.length - 1] === false && a > 0) {
                    level[a - 1] = indent;
                }
            }, template = function beautify_script_level_template() {
                if (ctype === "template_else") {
                    level[a - 1] = indent - 1;
                    level.push(indent);
                }
                else if (ctype === "template_start") {
                    indent = indent + 1;
                    if (data.lines[a - 1] < 1) {
                        level[a - 1] = -20;
                    }
                    if (data.lines[a] > 0 || ltoke.length === 1 && ltype === "string") {
                        level.push(indent);
                    }
                    else {
                        level.push(-20);
                    }
                }
                else if (ctype === "template_end") {
                    indent = indent - 1;
                    if (ltype === "template_start" || data.lines[a - 1] < 1) {
                        level[a - 1] = -20;
                    }
                    else {
                        level[a - 1] = indent;
                    }
                    if (data.lines[a] > 0) {
                        level.push(indent);
                    }
                    else {
                        level.push(-20);
                    }
                }
                else if (ctype === "template") {
                    if (data.lines[a] > 0) {
                        level.push(indent);
                    }
                    else {
                        level.push(-20);
                    }
                }
            }, templateString = function beautify_script_level_templateString() {
                if (ctype === "template_string_start") {
                    indent = indent + 1;
                    level.push(indent);
                }
                else if (ctype === "template_string_else") {
                    fixchain();
                    level[a - 1] = indent - 1;
                    level.push(indent);
                }
                else {
                    fixchain();
                    indent = indent - 1;
                    level[a - 1] = indent;
                    level.push(-10);
                }
                if (a > 2 && (data.types[a - 2] === "template_string_else" || data.types[a - 2] === "template_string_start")) {
                    if (options.brace_padding === true) {
                        level[a - 2] = -10;
                        level[a - 1] = -10;
                    }
                    else {
                        level[a - 2] = -20;
                        level[a - 1] = -20;
                    }
                }
            }, types = function beautify_script_level_types() {
                if (data.token[a - 1] === "," || (data.token[a - 1] === ":" && data.stack[a - 1] !== "data_type")) {
                    level[a - 1] = -10;
                }
                else {
                    level[a - 1] = -20;
                }
                if (data.types[a] === "type" || data.types[a] === "type_end") {
                    level.push(-10);
                }
                if (data.types[a] === "type_start") {
                    level.push(-20);
                }
            }, word = function beautify_script_level_word() {
                if ((ltoke === ")" || ltoke === "x)") && data.stack[a] === "class" && (data.token[data.begin[a - 1] - 1] === "static" || data.token[data.begin[a - 1] - 1] === "final" || data.token[data.begin[a - 1] - 1] === "void")) {
                    level[a - 1] = -10;
                    level[data.begin[a - 1] - 1] = -10;
                }
                if (ltoke === "]") {
                    level[a - 1] = -10;
                }
                if (ltoke === "}" || ltoke === "x}") {
                    level[a - 1] = indent;
                }
                if (ctoke === "else" && ltoke === "}") {
                    if (data.token[a - 2] === "x}") {
                        level[a - 3] = level[a - 3] - 1;
                    }
                    if (options.braces === true) {
                        level[a - 1] = indent;
                    }
                }
                if (ctoke === "new") {
                    let apiword = [
                        "ActiveXObject",
                        "ArrayBuffer",
                        "AudioContext",
                        "Canvas",
                        "CustomAnimation",
                        "DOMParser",
                        "DataView",
                        "Date",
                        "Error",
                        "EvalError",
                        "FadeAnimation",
                        "FileReader",
                        "Flash",
                        "Float32Array",
                        "Float64Array",
                        "FormField",
                        "Frame",
                        "Generator",
                        "HotKey",
                        "Image",
                        "Iterator",
                        "Intl",
                        "Int16Array",
                        "Int32Array",
                        "Int8Array",
                        "InternalError",
                        "Loader",
                        "Map",
                        "MenuItem",
                        "MoveAnimation",
                        "Notification",
                        "ParallelArray",
                        "Point",
                        "Promise",
                        "Proxy",
                        "RangeError",
                        "Rectangle",
                        "ReferenceError",
                        "Reflect",
                        "RegExp",
                        "ResizeAnimation",
                        "RotateAnimation",
                        "Set",
                        "SQLite",
                        "ScrollBar",
                        "Set",
                        "Shadow",
                        "StopIteration",
                        "Symbol",
                        "SyntaxError",
                        "Text",
                        "TextArea",
                        "Timer",
                        "TypeError",
                        "URL",
                        "Uint16Array",
                        "Uint32Array",
                        "Uint8Array",
                        "Uint8ClampedArray",
                        "URIError",
                        "WeakMap",
                        "WeakSet",
                        "Web",
                        "Window",
                        "XMLHttpRequest"
                    ];
                    if (apiword.indexOf(data.token[a + 1]) < 0) {
                        news = news + 1;
                    }
                    if (options.jsscope !== "none") {
                        data.token[a] = "<strong class='new'>new</strong>";
                    }
                }
                if (ctoke === "from" && ltype === "end" && a > 0 && (data.token[data.begin[a - 1] - 1] === "import" || data.token[data.begin[a - 1] - 1] === ",")) {
                    level[a - 1] = -10;
                }
                if (ctoke === "this" && options.jsscope !== "none") {
                    data.token[a] = "<strong class=\"new\">this</strong>";
                }
                if (ctoke === "function") {
                    if (options.space === false && a < b - 1 && (data.token[a + 1] === "(" || data.token[a + 1] === "x(")) {
                        level.push(-20);
                        return;
                    }
                    level.push(-10);
                    return;
                }
                if (ltoke === "-" && a > 1) {
                    if (data.types[a - 2] === "operator" || data.token[a - 2] === ",") {
                        level[a - 1] = -20;
                    }
                    else if (data.types[a - 2] === "start") {
                        level[a - 2] = -20;
                        level[a - 1] = -20;
                    }
                }
                else if (ctoke === "while" && (ltoke === "}" || ltoke === "x}")) {
                    //verify if this is a do/while block
                    let c = a - 1, d = 0;
                    do {
                        if (data.token[c] === "}" || data.token[c] === "x}") {
                            d = d + 1;
                        }
                        if (data.token[c] === "{" || data.token[c] === "x{") {
                            d = d - 1;
                        }
                        if (d === 0) {
                            if (data.token[c - 1] === "do") {
                                level[a - 1] = -10;
                                break;
                            }
                            level[a - 1] = indent;
                            break;
                        }
                        c = c - 1;
                    } while (c > -1);
                }
                else if (ctoke === "in" || (((ctoke === "else" && options.else_line === false && options.braces === false) || ctoke === "catch") && (ltoke === "}" || ltoke === "x}"))) {
                    level[a - 1] = -10;
                }
                else if (ctoke === "var" || ctoke === "let" || ctoke === "const") {
                    varindex[varindex.length - 1] = a;
                    if (ltype === "end") {
                        level[a - 1] = indent;
                    }
                    if (data.token[data.begin[a] - 1] !== "for") {
                        let c = a + 1, d = 0;
                        do {
                            if (data.types[c] === "end") {
                                d = d - 1;
                            }
                            if (data.types[c] === "start") {
                                d = d + 1;
                            }
                            if (d < 0 || (d === 0 && (data.token[c] === ";" || data.token[c] === ","))) {
                                break;
                            }
                            c = c + 1;
                        } while (c < b);
                        if (data.token[c] === ",") {
                            indent = indent + 1;
                        }
                    }
                    level.push(-10);
                    return;
                }
                if ((ctoke === "default" || ctoke === "case") && ltype !== "word" && data.stack[a] === "switch") {
                    level[a - 1] = indent - 1;
                    level.push(-10);
                    return;
                }
                if (ctoke === "catch" && ltoke === ".") {
                    level[a - 1] = -20;
                    level.push(-20);
                    return;
                }
                if (ctoke === "catch" || ctoke === "finally") {
                    level[a - 1] = -10;
                    level.push(-10);
                    return;
                }
                if (options.brace_padding === false && a < b - 1 && data.token[a + 1].charAt(0) === "}") {
                    level.push(-20);
                    return;
                }
                if (data.stack[a] === "object" && (ltoke === "{" || ltoke === ",") && (data.token[a + 1] === "(" || data.token[a + 1] === "x(")) {
                    level.push(-20);
                    return;
                }
                if (data.types[a - 1] === "comment" && data.token[data.begin[a]] === "(") {
                    level[a - 1] = indent + 1;
                }
                level.push(-10);
            };
            if (options.language === "titanium") {
                indent = indent - 1;
            }
            do {
                if (data.lexer[a] === lexer) {
                    ctype = data.types[a];
                    ctoke = data.token[a];
                    if (ctype === "comment") {
                        comment();
                    }
                    else if (ctype === "regex") {
                        level.push(-20);
                    }
                    else if (ctype === "string") {
                        string();
                    }
                    else if (ctype.indexOf("template_string") === 0) {
                        templateString();
                    }
                    else if (ctype === "separator") {
                        separator();
                    }
                    else if (ctype === "start") {
                        start();
                    }
                    else if (ctype === "end") {
                        end();
                    }
                    else if (ctype === "type" || ctype === "type_start" || ctype === "type_end") {
                        types();
                    }
                    else if (ctype === "operator") {
                        operator();
                    }
                    else if (ctype === "word") {
                        word();
                    }
                    else if (ctype === "reference") {
                        reference();
                    }
                    else if (ctype === "markup") {
                        markup();
                    }
                    else if (ctype.indexOf("template") === 0) {
                        template();
                    }
                    else if (ctype === "generic") {
                        if (ltoke !== "return" && ltoke.charAt(0) !== "#" && ltype !== "operator" && ltoke !== "public" && ltoke !== "private" && ltoke !== "static" && ltoke !== "final" && ltoke !== "implements" && ltoke !== "class" && ltoke !== "void") {
                            level[a - 1] = -20;
                        }
                        if (data.token[a + 1] === "(" || data.token[a + 1] === "x(") {
                            level.push(-20);
                        }
                        else {
                            level.push(-10);
                        }
                    }
                    else {
                        level.push(-10);
                    }
                    if (ctype !== "comment") {
                        ltype = ctype;
                        ltoke = ctoke;
                    }
                    if (count.length > 0 && data.token[a] !== ")") {
                        if (data.types[a] === "comment" && count[count.length - 1] > -1) {
                            count[count.length - 1] = options.wrap + 1;
                        }
                        else if (level[a] > -1 || (data.token[a].charAt(0) === "`" && data.token[a].indexOf("\n") > 0)) {
                            count[count.length - 1] = -1;
                        }
                        else if (count[count.length - 1] > -1) {
                            count[count.length - 1] = count[count.length - 1] + data.token[a].length;
                            if (level[a] === -10) {
                                count[count.length - 1] = count[count.length - 1] + 1;
                            }
                        }
                    }
                }
                else {
                    external();
                }
                a = a + 1;
            } while (a < b);
            return level;
        }()), output = (function beautify_script_output() {
            const build = [], tab = (function beautify_script_output_tab() {
                const ch = options.indent_char, tabby = [];
                let index = options.indent_size;
                if (typeof index !== "number" || index < 1) {
                    return "";
                }
                do {
                    tabby.push(ch);
                    index = index - 1;
                } while (index > 0);
                return tabby.join("");
            }()), lf = (options.crlf === true)
                ? "\r\n"
                : "\n", pres = options.preserve + 1, nl = function beautify_script_output_outnl(tabs) {
                const linesout = [], total = (function beautify_script_output_outnl_total() {
                    if (a === b - 1) {
                        return 1;
                    }
                    if (data.lines[a + 1] - 1 > pres) {
                        return pres;
                    }
                    if (data.lines[a + 1] > 1) {
                        return data.lines[a + 1] - 1;
                    }
                    return 1;
                }());
                let index = 0;
                if (tabs < 0) {
                    tabs = 0;
                }
                do {
                    linesout.push(lf);
                    index = index + 1;
                } while (index < total);
                if (tabs > 0) {
                    index = 0;
                    do {
                        linesout.push(tab);
                        index = index + 1;
                    } while (index < tabs);
                }
                return linesout.join("");
            }, reference = function beautify_script_output_reference() {
                let s = scopes.length, t = 0;
                const applyScope = function beautify_script_output_reference_applyScope() {
                    // applyScope function exists to prevent presenting spaces as part of reference names if option 'vertical' is set to true
                    let token = data.token[a], space = "";
                    const spaceIndex = token.indexOf(" "), scopeValue = (function beautify_script_output_reference_applyScope_scopeValue() {
                        let begin = data.begin[scopes[s][1]], value = "";
                        if (scopes[s][1] < 0 || begin < 0) {
                            return "0";
                        }
                        if (data.token[scopes[s][1]] !== undefined && data.token[scopes[s][1]].indexOf("<em") === 0) {
                            begin = scopes[s][1];
                        }
                        else if (data.token[begin] === undefined || data.token[begin].indexOf("<em") !== 0) {
                            do {
                                begin = data.begin[begin];
                            } while (begin > 0 && data.token[begin].indexOf("<em") !== 0);
                        }
                        if (begin < 0) {
                            value = "0";
                        }
                        else {
                            value = data.token[begin];
                            value = value.slice(value.indexOf("class=") + 8);
                            value = value.slice(0, value.indexOf(">") - 1);
                        }
                        if (data.stack[a] === "arguments" || data.stack[scopes[s][1]] === "arguments") {
                            return String(Number(value) + 1);
                        }
                        return value;
                    }());
                    if (spaceIndex > 0) {
                        space = token.slice(spaceIndex);
                        token = token.slice(0, spaceIndex);
                    }
                    data.token[a] = `prettydiffltem class="s${scopeValue}"prettydiffgt${token}prettydifflt/emprettydiffgt${space}`;
                    build.push(data.token[a]);
                };
                if (scopes.length < 1) {
                    return;
                }
                do {
                    s = s - 1;
                    if (data.token[a].replace(/\s+/, "") === scopes[s][0]) {
                        if (scopes[s][1] <= a) {
                            t = scopes[s][1];
                            if (t < 0 || data.stack[a] === "arguments" || t === a) {
                                applyScope();
                                return;
                            }
                            do {
                                t = t + 1;
                                if (data.types[t] === "end" && data.begin[t] === scopes[s][1]) {
                                    break;
                                }
                            } while (t < a);
                            if (t === a) {
                                applyScope();
                                return;
                            }
                        }
                        else if (data.begin[scopes[s][1]] < data.begin[a]) {
                            applyScope();
                            return;
                        }
                    }
                } while (s > 0);
                build.push(data.token[a]);
            }, invisibles = ["x;", "x}", "x{", "x(", "x)"];
            let a = prettydiff.start, external = "", lastLevel = options.indent_level;
            if (options.vertical === true) {
                const vertical = function beautify_script_output_vertical(end) {
                    let longest = 0, complex = 0, aa = end - 1, bb = 0, cc = 0;
                    const begin = data.begin[a], list = [];
                    do {
                        if ((data.begin[aa] === begin || data.token[aa] === "]" || data.token[aa] === ")") && ((data.token[aa + 1] === ":" && data.stack[aa] === "object") || data.token[aa + 1] === "=")) {
                            bb = aa;
                            complex = 0;
                            do {
                                if (data.begin[bb] === begin) {
                                    if (data.token[bb] === "," || data.token[bb] === ";" || data.token[bb] === "x;" || (levels[bb] > -1 && data.types[bb] !== "comment")) {
                                        if (data.token[bb + 1] === ".") {
                                            complex = complex + (options.indent_size * options.indent_char.length);
                                        }
                                        break;
                                    }
                                }
                                else if (levels[bb] > -1) {
                                    break;
                                }
                                if (data.types[bb] !== "comment") {
                                    if (levels[bb - 1] === -10) {
                                        complex = complex + 1;
                                    }
                                    complex = data.token[bb].length + complex;
                                }
                                bb = bb - 1;
                            } while (bb > begin);
                            cc = bb;
                            if (data.token[cc] === "," && data.token[aa + 1] === "=") {
                                do {
                                    if (data.types[cc] === "end") {
                                        cc = data.begin[cc];
                                    }
                                    if (data.begin[cc] === begin) {
                                        if (data.token[cc] === ";" || data.token[cc] === "x;") {
                                            break;
                                        }
                                        if (data.token[cc] === "var" || data.token[cc] === "const" || data.token[cc] === "let") {
                                            complex = complex + (options.indent_size * options.indent_char.length);
                                            break;
                                        }
                                    }
                                    cc = cc - 1;
                                } while (cc > begin);
                            }
                            if (complex > longest) {
                                longest = complex;
                            }
                            list.push([aa, complex]);
                            aa = bb;
                        }
                        else if (data.types[aa] === "end") {
                            aa = data.begin[aa];
                        }
                        aa = aa - 1;
                    } while (aa > begin);
                    aa = list.length;
                    if (aa > 0) {
                        do {
                            aa = aa - 1;
                            bb = list[aa][1];
                            if (bb < longest) {
                                do {
                                    data.token[list[aa][0]] = data.token[list[aa][0]] + " ";
                                    bb = bb + 1;
                                } while (bb < longest);
                            }
                        } while (aa > 0);
                    }
                };
                a = b;
                do {
                    a = a - 1;
                    if (data.lexer[a] === "script") {
                        if (data.token[a] === "}" && data.token[a - 1] !== "{" && levels[data.begin[a]] > 0) {
                            vertical(a);
                        }
                    }
                    else {
                        a = data.begin[a];
                    }
                } while (a > 0);
            }
            if (options.jsscope !== "none" && options.jsscope !== "interim") {
                let linecount = 1, last = "", scope = 0, scoped = [], indent = options.indent_level, foldindex = [], start = prettydiff.start, exlines = [], exlevel = 0, exline;
                const code = [], optionValue = options.jsscope, foldstart = function beautify_script_output_scope_foldstart() {
                    let index = code.length;
                    do {
                        index = index - 1;
                    } while (index > 0 && code[index] !== "<li>");
                    if (code[index] === "<li>") {
                        code[index] = `<li class="fold" title="folds from line ${linecount} to line xxx">`;
                        code[index + 1] = `-${code[index + 1]}`;
                        foldindex.push([index, a]);
                    }
                }, foldend = function beautify_script_output_scope_foldend() {
                    const lastfold = foldindex[foldindex.length - 1];
                    if (data.types[a] === "end" && lastfold[1] === data.begin[a]) {
                        code[lastfold[0]] = code[lastfold[0]].replace("xxx", String(linecount));
                        foldindex.pop();
                    }
                    else if (data.types[a - 1] === "comment") {
                        let endfold = (a === b - 1)
                            ? linecount
                            : linecount - 1;
                        code[lastfold[0]] = code[lastfold[0]].replace("xxx", String(endfold));
                        foldindex.pop();
                    }
                }, 
                // splits block comments, which are single tokens, into multiple lines of output
                blockline = function beautify_script_output_scope_blockline(x) {
                    const commentLines = x.split(lf), ii = commentLines.length;
                    let hh = 0;
                    if (levels[a] > 0) {
                        do {
                            commentLines[0] = tab + commentLines[0];
                            hh = hh + 1;
                        } while (hh < levels[a]);
                    }
                    hh = 1;
                    build.push(commentLines[0]);
                    if (hh < ii) {
                        do {
                            linecount = linecount + 1;
                            code.push("<li>");
                            code.push(String(linecount));
                            code.push("</li>");
                            build.push(`<em class="line">&#xA;</em></li><li class="c0">${commentLines[hh]}`);
                            hh = hh + 1;
                        } while (hh < ii);
                    }
                }, 
                //a function for calculating indentation after each new line
                nlscope = function beautify_script_output_scope_nlscope(x) {
                    let dd = 0;
                    const total = (function beautify_script_output_scope_nlscope_total() {
                        if (a === b - 1) {
                            return 0;
                        }
                        if (data.lines[a + 1] - 1 > pres) {
                            return pres - 1;
                        }
                        if (data.lines[a + 1] > 1) {
                            return data.lines[a + 1] - 2;
                        }
                        return 0;
                    }()), scopepush = function beautify_script_output_scope_nlscope_scopepush() {
                        let aa = 0, bb = 0;
                        if (x > 0) {
                            do {
                                build.push(`<span class="l${bb}">${tab}</span>`);
                                if (scoped[aa] === true) {
                                    bb = bb + 1;
                                }
                                aa = aa + 1;
                            } while (aa < x);
                        }
                    };
                    if (data.token[a] !== "x}" || (data.token[a] === "x}" && data.token[a + 1] !== "}")) {
                        let index = 0;
                        if (total > 0) {
                            do {
                                linecount = linecount + 1;
                                code.push("<li>");
                                code.push(String(linecount));
                                code.push("</li>");
                                build.push(`<em class="line">&#xA;</em></li><li class="s0">`);
                                index = index + 1;
                            } while (index < total);
                        }
                        linecount = linecount + 1;
                        code.push("<li>");
                        code.push(String(linecount));
                        code.push("</li>");
                        if (a < b - 1 && data.types[a + 1] === "comment") {
                            build.push(`<em class="line">&#xA;</em></li><li class="c0">`);
                            do {
                                build.push(tab);
                                dd = dd + 1;
                            } while (dd < levels[a]);
                        }
                        else {
                            if (data.token[a + 1] === "}" && data.stack[a + 1] !== "object" && data.stack[a + 1] !== "class") {
                                build.push(`<em class="line">&#xA;</em></li><li class="l${scope - 1}">`);
                            }
                            else {
                                build.push(`<em class="line">&#xA;</em></li><li class="l${scope}">`);
                            }
                            scopepush();
                        }
                    }
                    else {
                        scopepush();
                    }
                }, multiline = function beautify_script_output_scope_multiline(x) {
                    const temparray = x.split(lf), d = temparray.length;
                    let c = 1;
                    build.push(temparray[0]);
                    do {
                        nlscope(indent);
                        build.push(temparray[c]);
                        c = c + 1;
                    } while (c < d);
                };
                options.jsscope = "interim";
                code.push("<div class=\"beautify\" data-prettydiff-ignore=\"true\"><ol class=\"count\">");
                code.push("<li>");
                code.push("1");
                code.push("</li>");
                if (data.types[a] === "comment" && data.token[a].indexOf("/*") === 0) {
                    build.push(`<ol class="data"><li class="c0">${tab}`);
                }
                else {
                    build.push("<ol class=\"data\"><li>");
                }
                a = 0;
                if (indent > 0) {
                    do {
                        build.push(tab);
                        a = a + 1;
                    } while (a < indent);
                }
                scope = 0;
                // this loops combines the white space as determined from the algorithm with the
                // tokens to create the output
                a = prettydiff.start;
                do {
                    if (data.lexer[a] === lexer || prettydiff.beautify[data.lexer[a]] === undefined) {
                        if (levels[a] > -1 && a < b - 1) {
                            if (levels[a] < scoped.length) {
                                do {
                                    scoped.pop();
                                } while (levels[a] < scoped.length);
                            }
                        }
                        if (data.types[a] === "comment" && data.token[a].indexOf("/*") === 0) {
                            blockline(data.token[a]);
                        }
                        else if (invisibles.indexOf(data.token[a]) < 0) {
                            if (data.types[a] === "start" && (levels[a] > -1 || data.types[a + 1] === "comment")) {
                                foldstart();
                            }
                            else if (data.token[a].indexOf("//") === 0 && a < b - 1 && data.token[a + 1].indexOf("//") === 0 && data.token[a - 1].indexOf("//") !== 0 && levels[a - 1] > -1) {
                                foldstart();
                            }
                            else if (foldindex.length > 0) {
                                if (data.types[a] === "end") {
                                    foldend();
                                }
                                else if ((data.token[a].indexOf("//") !== 0 || a === b - 1) && data.token[foldindex[foldindex.length - 1][1]].indexOf("//") === 0) {
                                    foldend();
                                }
                            }
                            if (data.types[a] === "reference") {
                                reference();
                            }
                            else if (data.token[a] === "{") {
                                if (data.stack[a + 1] === "object" || data.stack[a + 1] === "class") {
                                    scoped.push(false);
                                    build.push("{");
                                }
                                else {
                                    if (scoped.length === levels[a]) {
                                        if (scoped[scoped.length - 1] === false) {
                                            scoped[scoped.length - 1] = true;
                                            scope = scope + 1;
                                        }
                                    }
                                    else {
                                        scoped.push(true);
                                        scope = scope + 1;
                                    }
                                    data.token[a] = `<em class="s${scope}">{</em>`;
                                    build.push(data.token[a]);
                                }
                                if (levels[a] > scoped.length) {
                                    do {
                                        scoped.push(false);
                                    } while (levels[a] > scoped.length);
                                }
                            }
                            else if (data.token[a] === "}") {
                                if (data.stack[a] === "object" || data.stack[a] === "class") {
                                    build.push("}");
                                }
                                else {
                                    build.push(`<em class="s${scope}">}</em>`);
                                    scope = scope - 1;
                                }
                            }
                            else {
                                if (data.types[a].indexOf("string") > -1 && data.token[a].indexOf("\n") > 0) {
                                    multiline(data.token[a].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"));
                                }
                                else if (data.types[a] === "operator" || data.types[a] === "comment" || data.types[a].indexOf("string") > -1 || data.types[a] === "regex") {
                                    build.push(data.token[a].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"));
                                }
                                else {
                                    if (data.types[a] === "start" && levels[a] > -1) {
                                        scoped.push(false);
                                    }
                                    if (data.token[a] !== ";" || options.no_semicolon === false) {
                                        build.push(data.token[a]);
                                    }
                                    else if (levels[a] < 0 && data.types[a + 1] !== "comment") {
                                        build.push(";");
                                    }
                                }
                            }
                        }
                        if (a < b - 1 && data.lexer[a + 1] !== lexer && data.begin[a] === data.begin[a + 1] && data.types[a + 1].indexOf("end") < 0 && data.token[a] !== ",") {
                            build.push(" ");
                        }
                        else if (levels[a] > -1 && a < b - 1) {
                            lastLevel = levels[a];
                            nlscope(levels[a]);
                        }
                        else if (levels[a] === -10) {
                            build.push(" ");
                            if (data.lexer[a + 1] !== lexer) {
                                lastLevel = lastLevel + 1;
                            }
                        }
                    }
                    else {
                        if (externalIndex[a] === a) {
                            build.push(data.token[a]
                                .replace(/&/g, "&amp;")
                                .replace(/</g, "&lt;")
                                .replace(/>/g, "&gt;")
                                .replace(/&lt;strong class="new"&gt;this&lt;\/strong&gt;/g, "<strong class=\"new\">this</strong>")
                                .replace(/&lt;strong class="new"&gt;new&lt;\/strong&gt;/g, "<strong class=\"new\">new</strong>"));
                        }
                        else {
                            prettydiff.end = externalIndex[a];
                            options.indent_level = lastLevel;
                            prettydiff.start = a;
                            external = prettydiff.beautify[data.lexer[a]](options)
                                .replace(/\s+$/, "")
                                .replace(/&/g, "&amp;")
                                .replace(/</g, "&lt;")
                                .replace(/>/g, "&gt;")
                                .replace(/&lt;strong class="new"&gt;this&lt;\/strong&gt;/g, "<strong class=\"new\">this</strong>")
                                .replace(/&lt;strong class="new"&gt;new&lt;\/strong&gt;/g, "<strong class=\"new\">new</strong>");
                            if (external.indexOf(lf) > -1) {
                                if (start === 0) {
                                    exline = new RegExp(`\\r?\\n(${tab}){${lastLevel}}`, "g");
                                    external = external.replace(exline, lf);
                                }
                                exlines = external.split(lf);
                                exlevel = 0;
                                if (exlines.length > 1) {
                                    do {
                                        build.push(exlines[exlevel]);
                                        nlscope(lastLevel);
                                        exlevel = exlevel + 1;
                                    } while (exlevel < exlines.length - 1);
                                    build.push(exlines[exlevel]);
                                }
                            }
                            else {
                                build.push(external);
                            }
                            a = prettydiff.iterator;
                            if (levels[a] === -10) {
                                build.push(" ");
                            }
                            else if (levels[a] > -1) {
                                nlscope(levels[a]);
                            }
                        }
                    }
                    a = a + 1;
                } while (a < b);
                a = build.length - 1;
                do {
                    if (build[a] === tab) {
                        build.pop();
                    }
                    else {
                        break;
                    }
                    a = a - 1;
                } while (a > -1);
                //this logic is necessary to some line counting corrections to the HTML output
                last = build[build.length - 1];
                if (last.indexOf("<li") > 0) {
                    build[build.length - 1] = "<em class=\"line\">&#xA;</em></li>";
                }
                else if (last.indexOf("</li>") < 0) {
                    build.push("<em class=\"line\">&#xA;</em></li>");
                }
                build.push("</ol></div>");
                last = build.join("").replace(/prettydifflt/g, "<").replace(/prettydiffgt/g, ">");
                if (last.match(/<li/g) !== null) {
                    scope = last
                        .match(/<li/g)
                        .length;
                    if (linecount - 1 > scope) {
                        linecount = linecount - 1;
                        do {
                            code.pop();
                            code.pop();
                            code.pop();
                            linecount = linecount - 1;
                        } while (linecount > scope);
                    }
                }
                code.push("</ol>");
                code.push(lf);
                code.push(last);
                if (options.new_line === true) {
                    code.push(lf);
                }
                options.jsscope = optionValue;
                return [
                    "<p>Scope analysis does not provide support for undeclared variables.</p>",
                    "<p><em>",
                    scolon,
                    "</em> instances of <strong>missing semicolons</strong> counted.</p>",
                    "<p><em>",
                    news,
                    "</em> unnecessary instances of the keyword <strong>new</strong> counted.</p>",
                    code.join("")
                ].join("").replace(/(\s+)$/, "").replace(options.binary_check, "");
            }
            a = prettydiff.start;
            do {
                if (data.lexer[a] === lexer || prettydiff.beautify[data.lexer[a]] === undefined) {
                    if (invisibles.indexOf(data.token[a]) < 0) {
                        if (data.types[a] === "reference" && options.jsscope === "interim") {
                            reference();
                        }
                        else {
                            if (data.token[a] !== ";" || options.no_semicolon === false) {
                                build.push(data.token[a]);
                            }
                            else if (levels[a] < 0 && data.types[a + 1] !== "comment") {
                                build.push(";");
                            }
                        }
                    }
                    if (a < b - 1 && data.lexer[a + 1] !== lexer && data.begin[a] === data.begin[a + 1] && data.types[a + 1].indexOf("end") < 0 && data.token[a] !== ",") {
                        build.push(" ");
                    }
                    else if (levels[a] > -1) {
                        if (((levels[a] > -1 && data.token[a] === "{") || (levels[a] > -1 && data.token[a + 1] === "}")) && data.lines[a] < 3 && options.brace_line === true) {
                            build.push(nl(0));
                        }
                        lastLevel = levels[a];
                        build.push(nl(levels[a]));
                    }
                    else if (levels[a] === -10) {
                        build.push(" ");
                        if (data.lexer[a + 1] !== lexer) {
                            lastLevel = lastLevel + 1;
                        }
                    }
                }
                else {
                    if (externalIndex[a] === a) {
                        build.push(data.token[a]);
                    }
                    else {
                        prettydiff.end = externalIndex[a];
                        options.indent_level = lastLevel;
                        prettydiff.start = a;
                        external = prettydiff.beautify[data.lexer[a]](options).replace(/\s+$/, "");
                        build.push(external);
                        a = prettydiff.iterator;
                        if (levels[a] === -10) {
                            build.push(" ");
                        }
                        else if (levels[a] > -1) {
                            build.push(nl(levels[a]));
                        }
                    }
                }
                a = a + 1;
            } while (a < b);
            prettydiff.iterator = b - 1;
            return build.join("");
        }());
        return output;
    };
    prettydiff.beautify.script = script;
}());
prettydiff.sparser=sparser;prettydiff.version={"date":"18 Aug 2019","number":"101.2.6","parse":"1.4.12"};module.exports=prettydiff;return prettydiff;}());
});

const tabsToSpaces = (data, tabSize = 4) => {
    if (typeof data !== 'string') {
        return data;
    }

    tabSize = parseInt(tabSize);

    let charIndex = data.indexOf('\t');
    const newLineIndex = data.substr(0, charIndex).lastIndexOf('\n');

    if (charIndex === -1) {
        return data;
    }

    charIndex -= newLineIndex > 0 ? newLineIndex : 0;
    let buffer = charIndex % tabSize;

    if (charIndex < tabSize) {
        buffer = charIndex;
    } else if (charIndex === tabSize) {
        buffer = 0;
    }

    /**
     * Converting tab character to appropriate number of spaces
     */
    while (charIndex < data.length) {
        if (data[charIndex] === '\t') {
            data = data.replace(data[charIndex], ' '.repeat(tabSize - buffer));
            charIndex += tabSize - buffer;
            buffer = 0;
            continue;
        } else {
            buffer++;
        }

        if (buffer >= tabSize || data[charIndex] === '\n') {
            buffer = 0;
        }
        charIndex++;
    }

    return data;
};

var tabsToSpaces_1 = tabsToSpaces;

/* eslint-disable */

const beautifyHtml = js$1.html;




const { log: log$2 } = helpers;

class PHPFormatter {
    constructor(server) {
        this.server = server;
        this.extensionConfig = config();
        this.formattedText = new Map();
        this.localCSConfig = this.findLocalCSConfig();
    }

    /*
     * Process
     * called on event "onWillSave"
     */
    async process(editor) {
        if (!this.extensionConfig.onsave || (this.extensionConfig.ignoreremote && editor.document.isRemote)) {
            log$2("File not processed because the extension it's configured to not format on save or not format remote files");
            return;
        }

        const filePath = editor.document.path;
        const fileName = nova.path.basename(filePath.toLowerCase());
        const allowedExtensions = {
            php: true,
            blade: this.extensionConfig.blade,
            twig: this.extensionConfig.twig
        };

        let extension = nova.path.extname(editor.document.path).substring(1);

        if (fileName.endsWith('.blade.php')) {
            extension = 'blade';
        }

        if (!allowedExtensions.hasOwnProperty(extension) || !allowedExtensions[extension]) {
            log$2(`File not processed because the extension it's configured to not format on save files with extension ${extension}`);
            return;
        }

        await this.format(editor, true);
    }

    /*
     * Format
     * start the format process
     */
    async format(editor) {
        const filePath = editor.document.path;
        const fileName = nova.path.basename(filePath.toLowerCase());
        const extension = nova.path.extname(fileName).substring(1);
        const documentRange = new Range(0, editor.document.length);
        const content = editor.getTextInRange(documentRange);
        const shouldProcess = this.shouldProcess(editor, content);

        if (!shouldProcess) {
            return;
        }

        let text = content;
        let formatted = false;

        text = tabsToSpaces_1(text, 4);

        if (fileName.endsWith('.blade.php')) {
            formatted = this.formatBlade(text);
            await this.setFormattedValue({ editor, content, formatted });
            return true;
        }

        if (extension == 'twig') {
            formatted = this.formatTwig(text);
            await this.setFormattedValue({ editor, content, formatted });
            return true;
        }

        if (this.extensionConfig.htmltry) {
            text = this.formatHTML(text);
            formatted = text;
            if (extension == 'html') {
                await this.setFormattedValue({ editor, content, formatted });
                return true;
            }
        }

        //text = this.prePHPClenup(text);

        const tmpFile = await this.tmpFile(filePath, text);
        const command = await this.getCommand(tmpFile);

        if (this.extensionConfig.server) {
            formatted = await this.formatOnServer(command, tmpFile);
        } else {
            formatted = await this.formatUsingProcess(command, tmpFile);
        }

        if (!formatted || !formatted.content) {
            log$2('Unable to format document' + formatted.error, true);
            return;
        }

        if (this.extensionConfig.htmladditional) {
            formatted.content = this.additionalHTMLFixes(formatted.content);
        }

        await this.setFormattedValue({ editor, content, formatted });
    }

    /*
     * Format on server
     * call php cs fixer using
     * the running server
     *
     * @param string command
     * @param string temp file path
     * @returns mixed
     */
    async formatOnServer(cmd, filePath) {
        const startTime = Date.now();
        const serverPort = this.extensionConfig.port;
        const serverURL = `http://localhost:${serverPort}/index.php`;

        log$2('Calling PHP Formatting server on URL');
        log$2(serverURL);

        const rawResponse = await fetch(serverURL, {
            method: 'post',
            headers: { Accept: 'application/json', 'Content-Type': 'application/json' },
            body: JSON.stringify({
                file: filePath,
                cmd: cmd,
                config: this.extensionConfig
            })
        });

        if (!rawResponse.ok) {
            log$2('The server returned an error', true);
        }

        let response = false;

        try {
            response = await rawResponse.json();
        } catch (error) {
            log$2(error, true);
        }

        if (typeof response == 'object' && response.success) {
            log$2('Server response');
            log$2(JSON.stringify(response));
        }

        const elapsedTime = Date.now() - startTime;
        log$2(`PHP formatted in server took ${elapsedTime}ms`);

        return response;
    }

    /*
     * Format with a process
     * call php cs fixer using
     * a process
     *
     * @param string command
     * @param string temp file path
     * @returns mixed
     */
    async formatUsingProcess(cmd, filePath) {
        return new Promise((resolve, reject) => {
            const startTime = Date.now();
            const format = { error: false, success: false, content: '' };
            const stdOut = [];
            const stdErr = [];
            const process = new Process('/usr/bin/env', {
                args: cmd
            });

            log$2('Calling PHP Formatting using a process');

            process.onStdout((result) => {
                stdOut.push(result);
            });
            process.onStderr((line) => {
                stdErr.push(line);
            });

            process.onDidExit((status) => {
                const elapsedTime = Date.now() - startTime;
                log$2(`PHP formatted in process took ${elapsedTime}ms`);

                if (stdOut && stdOut.join('').includes('Fixed all files')) {
                    let phpCode = '';

                    const file = nova.fs.open(filePath);
                    phpCode = file.read();
                    file.close();

                    format.success = true;
                    format.content = phpCode;

                    resolve(format);
                } else if (stdErr && stdErr.length > 0) {
                    let errorMessage = stdErr.join(' ');
                    log$2('Formatting process error');
                    log$2(errorMessage);

                    format.error = errorMessage;
                    reject(format);
                }
            });

            process.start();
        });
    }

    /*
     * Format HTML
     * format using js-beautify
     *
     * @param string
     * @return string
     */
    formatHTML(text, formatRules = false) {
        if (!formatRules) {
            formatRules = this.stringToObject(this.extensionConfig.htmlrules);
        }

        const HTMLConfig = Object.assign(
            {
                indent_size: this.extensionConfig.htmlTabWidth,
                indent_with_tabs: this.extensionConfig.htmlUseTabs,
                preserve_newlines: true,
                indent_scripts: 'keep',
                indent_with_tabs: false,
                max_preserve_newlines: 3,
                content_unformatted: ['pre', 'code']
            },
            formatRules
        );

        HTMLConfig.end_with_newline = false;
        log$2('Format HTML inside PHP before processing PHP with config');

        const startTime = Date.now();
        log$2(JSON.stringify(HTMLConfig));
        text = beautifyHtml(text, HTMLConfig);
        const elapsedTime = Date.now() - startTime;
        log$2(`HTML in PHP formatted in ${elapsedTime}ms`);

        return text;
    }

    /*
     * Format Blade
     * format using js-beautify
     * https://gist.github.com/brnmonteiro/3660b71dbc68691cdc8ac41cec379e2f
     * https://gist.github.com/mpryvkin/0c46e2493b450f92492e8e9a46ad5d97
     * https://gist.github.com/maliouris/f84b7f3dcb2a71455e693716e76ce302
     *
     * @param string
     * @return string
     */
    formatBlade(text) {
        log$2('Starting Blade format');

        let html = text;
        html = html.replace(/\{\{((?:(?!\}\}).)+)\}\}/g, function (m, c) {
            if (c) {
                c = c.replace(/(^[ \t]*|[ \t]*$)/g, '');
                c = c.replace(/'/g, '&#39;');
                c = c.replace(/"/g, '&#34;');
                c = encodeURIComponent(c);
            }
            return '{{' + c + '}}';
        });

        html = html.replace(/^[ \t]*@([a-z]+)([^\r\n]*)$/gim, function (m, d, c) {
            if (c) {
                c = c.replace(/'/g, '&#39;');
                c = c.replace(/"/g, '&#34;');
                c = '|' + encodeURIComponent(c);
            }
            switch (d) {
                case 'php':
                case 'break':
                case 'continue':
                case 'empty':
                case 'elseif':
                case 'else':
                case 'extends':
                case 'case':
                case 'csrf':
                case 'spaceless':
                case 'includeFirst':
                case 'include':
                case 'json':
                case 'method':
                case 'parent':
                case 'stack':
                case 'yield':
                    return '<blade ' + d + c + '/>';
                default:
                    if (d.startsWith('end')) {
                        return '</blade ' + d + c + '>';
                    } else {
                        return '<blade ' + d + c + '>';
                    }
            }
        });

        let bladeFormatRules = this.stringToObject(this.extensionConfig.bladerules);
        bladeFormatRules.indent_size = this.extensionConfig.bladeTabWidth;
        bladeFormatRules.indent_with_tabs = this.extensionConfig.bladeUseTabs;

        log$2('Converted Blade to HTML');
        log$2(html);

        html = this.formatHTML(html, bladeFormatRules);

        html = html.replace(/^([ \t]*)<\/?blade ([a-z]+)\|?([^>\/]+)?\/?>$/gim, function (m, s, d, c) {
            if (c) {
                c = decodeURIComponent(c);
                c = c.replace(/&#39;/g, "'");
                c = c.replace(/&#34;/g, '"');
                c = c.replace(/^[ \t]*/g, '');
            } else {
                c = '';
            }
            if (!s) {
                s = '';
            }
            return s + '@' + d + c;
        });
        html = html.replace(/\{\{((?:(?!\}\}).)+)\}\}/g, function (m, c) {
            if (c) {
                c = decodeURIComponent(c);
                c = c.replace(/&#39;/g, "'");
                c = c.replace(/&#34;/g, '"');
                c = c.replace(/(^[ \t]*|[ \t]*$)/g, ' ');
            }
            return '{{' + c + '}}';
        });

        // Dedent elseif|else inside if blocks
        let elsereg = /(\s+)?@if(.*)?@endif/gms;
        let m1;
        do {
            m1 = elsereg.exec(html);
            if (m1) {
                let fullmatch = m1[0];
                let initialTabSize = m1[1];
                let innerMatch = m1[2];

                if (innerMatch.includes('@else')) {
                    let indentedElse = fullmatch.replace(/^.+?@else/gm, (f) => {
                        if (!bladeFormatRules.indent_with_tabs && f.startsWith(' '.repeat(bladeFormatRules.indent_size))) {
                            f = f.replace(' '.repeat(bladeFormatRules.indent_size), '');
                        }
                        if (bladeFormatRules.indent_with_tabs) {
                            f = f.replace('\t', '');
                        }
                        return f;
                    });
                    html = html.replace(fullmatch, indentedElse);
                }
            }
        } while (m1);

        html = html.replace(/\{\{ --/g, '{{--');
        html = html.replace(/\-- \}\}/g, '--}}');

        log$2('Restored Blade from formatted HTML');
        log$2(html);

        return html;
    }

    /*
     * Format Twig
     * format using prettydiff
     * https://github.com/prettydiff/prettydiff
     *
     * @param string
     * @return string
     */
    formatTwig(text) {
        log$2('Starting Twig format');

        let source = text;
        let output = '',
            options = prettydiff.options;
        options.mode = 'beautify';
        options.language = 'twig';
        options.preserve = 3;
        options.source = source;

        let tabSize = this.extensionConfig.twigTabWidth;
        let indentChar = ' ';

        if (this.extensionConfig.twigUseTabs) {
            tabSize = 0;
            indentChar = '\t';
        }

        options.indent_char = indentChar;
        options.indent_size = tabSize;

        log$2('Twig options');
        log$2(JSON.stringify(options));

        output = prettydiff();

        if (!output) {
            log$2('Twig error, no output available', true);
            return text;
        }

        log$2('Twig formatted text');
        log$2(output);

        return output;
    }

    /*
     * Some precleanup for more
     * accurate results
     */
    prePHPClenup(text) {
        var re = / *?<\?php([\n\r] +)[A-Za-z]+/g;
        var m;
        do {
            m = re.exec(text);
            if (m) {
                const cleanedStr = m[0].replace(m[1], '\n' + m[0].substring(0, m[0].indexOf('<')));
                text = text.replace(m[0], cleanedStr);
            }
        } while (m);

        return text;
    }

    additionalHTMLFixes(text) {
        let re = /( +).*\?>[\n\r]+?(^<[\S]+.*>[\s\S]*?[\n\r]+?^<\?php)/gm;
        let m;
        do {
            m = re.exec(text);
            if (m) {
                if (m.length == 3) {
                    const fullmatch = m[0];
                    const toindent = m[2];
                    let space = m[1];

                    if (space.length == 1) {
                        space = '';
                    }

                    // Fix Inlined HTML fix id 1
                    const reindented = this.indentLines(space, toindent);
                    const newFixed = fullmatch.replace(toindent, reindented);
                    text = text.replace(fullmatch, newFixed);
                }
            }
        } while (m);

        // Fix no space in closing PHP tag id 2
        text = text.replace(/}\?>/, '} ?>');

        // Fix no space in closing PHP tag and html tag id 3
        let re3 = /( +)?\?>( +)?<\w+>/gm;
        let m3;
        do {
            m3 = re3.exec(text);
            if (m3) {
                const fullmatch = m3[0];
                let fixed = '';

                if (m3.length == 2) {
                    fixed = fullmatch.replace(m3[1], '\n');
                }
                if (m3.length == 3) {
                    let space = m3[1] ? m3[1] : '';
                    if (!m3[2]) {
                        fixed = fullmatch.replace('?><', '?>\n<' + space);
                    } else {
                        fixed = fullmatch.replace('>' + m3[2], '>\n' + space);
                    }
                }
                if (fixed) {
                    text = text.replace(fullmatch, fixed);
                }
            }
        } while (m3);

        // Fix PHP open tag indentation fix id 4
        let re4 = /(^\s+<\?php)[\s+]?\n(.*?)^\?>$/gms;
        let m4;
        do {
            m4 = re4.exec(text);
            if (m4) {
                const fullmatch = m4[0];
                const startTag = m4[1];
                const innerMatch = m4[2];

                if (!startTag.startsWith('<')) {
                    let innerLines = innerMatch.split('\n');
                    let firstLine = '';

                    for (let i = 0; i < innerLines.length; i++) {
                        if (innerLines[i].trim() !== '') {
                            firstLine = innerLines[i];
                            break;
                        }
                    }

                    if (firstLine.charAt(0).trim() !== '') {
                        let cleanedStart = startTag.trim();
                        let cleanedMatch = fullmatch.replace(startTag, cleanedStart);
                        text = text.replace(fullmatch, cleanedMatch);
                        console.log('firstLine char');
                        console.log(firstLine.charAt(0));
                    }
                }
            }
        } while (m4);

        // Fix < ? php tags  id 5
        if (text.includes('<script') && text.includes('</script>')) {
            text = text.replace(/< \?/g, '<?');
            text = text.replace(/<\? php/g, '<?php');
            text = text.replace(/ - > /g, '->');
            text = text.replace(/\? >/g, '?>');
            text = text.replace(/\?> ;/g, '?>;');
            text = text.replace(/\?\n.+>$/gm, '?>');
        }

        return text;
    }

    /**
     * Indent lines
     * passed a string it will indent
     * each line with the specified
     * content
     */
    indentLines(before, text) {
        const result = text.split('\n').map((line) => {
            return before + line;
        });

        return result.join('\n');
    }

    /*
     * Set Formatted value
     * once the content is formatted
     * set the editor content and cursor
     * position if required
     * Code by alexanderweiss from the prettier extension
     * https://github.com/alexanderweiss/nova-prettier
     *
     */
    async setFormattedValue({ editor, content, formatted }) {
        let formattedText = '';
        if (typeof formatted == 'string') {
            formattedText = formatted;
        } else {
            formattedText = formatted.content;
        }

        // No need to update if the content and the
        // formatted content are the same
        if (content == formattedText) {
            log$2('Nothing changed so the content will not be updated');
            return false;
        }

        const [cursor, edits] = this.diff(content, formattedText, editor.selectedRanges);

        if (edits) {
            return this.applyDiff(editor, cursor, edits);
        }

        return this.replace(editor, formattedText);
    }

    diff(original, formatted, selectedRanges) {
        // Find a cursor that does not occur in this document
        const POSSIBLE_CURSORS = String.fromCharCode(0xfffd, 0xffff, 0x1f094, 0x1f08d, 0xe004, 0x1f08d).split('');
        const cursor = POSSIBLE_CURSORS.find((cursor) => !original.includes(cursor) && !formatted.includes(cursor));

        if (!cursor) {
            return null;
        }

        let originalWithCursors = '';
        let lastEnd = 0;

        for (const selection of selectedRanges) {
            originalWithCursors += original.slice(lastEnd, selection.start) + cursor + original.slice(selection.start, selection.end) + cursor;
            lastEnd = selection.end;
        }

        originalWithCursors += original.slice(lastEnd);

        // Diff
        return [cursor, diff_1(originalWithCursors, formatted)];
    }

    async applyDiff(editor, cursor, edits) {
        const selections = [];
        await editor.edit((e) => {
            let offset = 0;
            let toRemove = 0;

            // Add an extra empty edit so any trailing delete is actually run.
            edits.push([diff_1.EQUAL, '']);

            for (const [edit, str] of edits) {
                if (edit === diff_1.DELETE) {
                    toRemove += str.length;

                    // Check if the cursors are in here
                    let cursorIndex = -1;
                    while (true) {
                        cursorIndex = str.indexOf(cursor, cursorIndex + 1);
                        if (cursorIndex === -1) {
                            break;
                        }

                        const lastSelection = selections[selections.length - 1];
                        if (!lastSelection || lastSelection[1]) {
                            selections[selections.length] = [offset];
                        } else {
                            lastSelection[1] = offset;
                        }
                        toRemove -= cursor.length;
                    }

                    continue;
                }

                if (edit === diff_1.EQUAL && toRemove) {
                    e.replace(new Range(offset, offset + toRemove), '');
                } else if (edit === diff_1.INSERT) {
                    e.replace(new Range(offset, offset + toRemove), str);
                }

                toRemove = 0;
                offset += str.length;
            }
        });

        editor.selectedRanges = selections.map((s) => new Range(s[0], s[1]));
        //editor.scrollToCursorPosition();
    }

    async replace(editor, formatted) {
        const { document } = editor;

        const cursorPosition = editor.selectedRange.end;
        const documentRange = new Range(0, document.length);

        await editor.edit((e) => {
            e.replace(documentRange, formatted);
        });

        editor.selectedRanges = [new Range(cursorPosition, cursorPosition)];
    }

    /*
     * Get command
     * generate the command
     * used to call php fixer
     *
     * @return array
     */
    async getCommand(filePath) {
        let phpPath = this.extensionConfig.phppath;
        let csfixerPath = this.extensionConfig.csfixerpath;
        let userRules = this.extensionConfig.rules;
        let globalCSConfig = this.extensionConfig.phpcsconfig;
        let localConfigFile = this.localCSConfig;

        if (!phpPath) {
            phpPath = 'php';
        }
        if (!csfixerPath) {
            csfixerPath = nova.path.join(nova.extension.globalStoragePath, 'php', 'php-cs-fixer');
        }

        if (this.extensionConfig.server) {
            phpPath = phpPath.replace(/(\s+)/g, '\\$1');
            csfixerPath = csfixerPath.replace(/(\s+)/g, '\\$1');
            filePath = filePath.replace(/(\s+)/g, '\\$1');
        }

        const cmd = [phpPath, csfixerPath, 'fix', filePath];

        if (localConfigFile) {
            localConfigFile = localConfigFile.replace(/(\s+)/g, '\\$1');
            cmd.push(`--config=${localConfigFile}`);
        } else if (globalCSConfig) {
            globalCSConfig = globalCSConfig.replace(/(\s+)/g, '\\$1');
            cmd.push(`--config=${globalCSConfig}`);
        } else if (userRules) {
            const rulesLines = userRules.split('\n');

            if (rulesLines.length == 1) {
                let rules = `--rules=${userRules}`;
                cmd.push(rules);
            } else {
                const rulesString = JSON.stringify(this.stringToObject(userRules));
                let rules = `--rules='${rulesString}'`;
                cmd.push(rules);
            }
        }

        log$2('Generated command to fix file');
        log$2(cmd.join(' '));

        return cmd;
    }

    /*
     * Check if should process
     * formatting, this extension will trigger
     * save and in those cases the process
     * must be ignored
     *
     * @return bool
     */
    shouldProcess(editor, content) {
        const previouslyFormattedText = this.formattedText.get(editor);
        if (previouslyFormattedText) {
            this.formattedText.delete(editor);
            if (previouslyFormattedText === content) {
                return false;
            }
        }

        return true;
    }

    /*
     * PHP CS FIxer temp file
     * a temp file is required to process PHP
     *
     * @return string temp file path
     */
    async tmpFile(file, content) {
        const tempdir = nova.fs.stat(nova.extension.workspaceStoragePath);
        if (!tempdir) {
            nova.fs.mkdir(nova.extension.workspaceStoragePath);
        }

        const fileID =
            file
                .replace('.php', '')
                .replace(/[^a-zA-Z]/g, '')
                .toLowerCase()
                .trim() + '.php';
        const tmpFilePath = nova.path.join(nova.extension.workspaceStoragePath, fileID);

        const tmpfile = await nova.fs.open(tmpFilePath, 'w');
        await tmpfile.write(content, 'utf-8');
        tmpfile.close();

        log$2('temp file created in');
        log$2(tmpFilePath);

        return tmpFilePath;
    }

    /*
     * Find local cs fixer config file
     * this file must exist in the root
     * of the active workspace
     *
     * @return boolean
     */
    findLocalCSConfig() {
        if (!nova.workspace.path) {
            return false;
        }

        let found = false;
        const csconf = ['.php_cs.dist', '.php_cs'];
        csconf.forEach((name) => {
            const cfpath = nova.path.join(nova.workspace.path, name);
            const hasConfig = nova.fs.stat(cfpath);

            if (hasConfig) {
                found = cfpath;
            }
        });

        return found;
    }

    /*
     * rescan workspace
     * looking for local config file
     */
    rescanLocalCSConfig() {}

    /**
     * Convert a string
     * into an object
     */
    stringToObject(str) {
        const rulesLines = str.split('\n');

        const rulesObj = {};

        rulesLines.forEach((ruleLine) => {
            ruleLine = ruleLine.trim();

            if (ruleLine == '{' || ruleLine == '}') {
                return;
            }

            let ruleName = ruleLine.substring(0, ruleLine.indexOf(':')).trim();
            let ruleValue = ruleLine.substring(ruleLine.indexOf(':') + 1).trim();

            if (ruleValue.startsWith('[') && ruleValue.endsWith(']')) {
                ruleValue = ruleValue.replace('[', '').replace(']', '');
                ruleValue = ruleValue.replace(/, '/g, ',');
                ruleValue = ruleValue.replace(/, "/g, ',');
                ruleValue = ruleValue.replace(/'/g, '');
                ruleValue = ruleValue.replace(/"/g, '');
                ruleValue = ruleValue.trim().split(',');
            } else if (ruleValue.includes('{') && ruleValue.includes('}')) {
                ruleValue = JSON.parse(ruleValue);
            }

            ruleName = ruleName.replace(/"/g, '');
            ruleName = ruleName.replace(/'/g, '');

            ruleValue = ruleValue == 'true' ? true : ruleValue;
            ruleValue = ruleValue == 'false' ? false : ruleValue;
            rulesObj[ruleName] = ruleValue;
        });

        return rulesObj;
    }
}

var formatter = PHPFormatter;

const compositeDisposable$1 = new CompositeDisposable();
const serverInstance = new server('PHP CS Fixer');
const { log: log$3, cleanDirectory: cleanDirectory$1 } = helpers;

var activate = function () {
    const formater = new formatter(serverInstance);

    nova.commands.register(nova.extension.identifier + '.format', (editor) => {
        return formater.format(editor, false);
    });

    nova.workspace.onDidAddTextEditor(async (editor) => {
        return editor.onWillSave(formater.process.bind(formater));
    });

    installer(compositeDisposable$1, log$3)
        .catch((err) => {
            log$3('Failed to activate PHP Fixer', true);
            log$3(err, true);
            nova.workspace.showErrorMessage(err);
        })
        .then(() => {
            serverInstance.start();
        });
};

var deactivate = function () {
    cleanDirectory$1(nova.extension.workspaceStoragePath);
    compositeDisposable$1.dispose();
};

var main = {
	activate: activate,
	deactivate: deactivate
};

exports.activate = activate;
exports.deactivate = deactivate;
exports.default = main;
